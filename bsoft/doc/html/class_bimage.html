<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bsoft: Bimage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Bsoft_icon128.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">Bsoft<span id="projectnumber">&#160;2.1.4</span>
   </div>
   <div id="projectbrief">Bernard&#39;s software package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_bimage.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_bimage-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Bimage Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>General image parameter class.  
 <a href="class_bimage.html#details">More...</a></p>

<p><code>#include &lt;Bimage.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a425d720ea28e3566a1cbc1eca8ed9c8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a425d720ea28e3566a1cbc1eca8ed9c8d">Bimage</a> ()</td></tr>
<tr class="memdesc:a425d720ea28e3566a1cbc1eca8ed9c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an image.  <a href="class_bimage.html#a425d720ea28e3566a1cbc1eca8ed9c8d">More...</a><br /></td></tr>
<tr class="separator:a425d720ea28e3566a1cbc1eca8ed9c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2019f6168e64ab28ee4aecf26c608bec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2019f6168e64ab28ee4aecf26c608bec">Bimage</a> (const <a class="el" href="class_bimage.html">Bimage</a> &amp;p)</td></tr>
<tr class="memdesc:a2019f6168e64ab28ee4aecf26c608bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor.  <a href="class_bimage.html#a2019f6168e64ab28ee4aecf26c608bec">More...</a><br /></td></tr>
<tr class="separator:a2019f6168e64ab28ee4aecf26c608bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bf591cb81fbd5a134f22a4996f9e2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a43bf591cb81fbd5a134f22a4996f9e2a">Bimage</a> (<a class="el" href="class_bstring.html">Bstring</a> &amp;fn, int readdata, int img_select)</td></tr>
<tr class="memdesc:a43bf591cb81fbd5a134f22a4996f9e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an image from a file.  <a href="class_bimage.html#a43bf591cb81fbd5a134f22a4996f9e2a">More...</a><br /></td></tr>
<tr class="separator:a43bf591cb81fbd5a134f22a4996f9e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fefb596c7347a4bbc1f484ae90f6bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a05fefb596c7347a4bbc1f484ae90f6bb">Bimage</a> (<a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> type, <a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a> ctype, long nx, long ny, long nz, long nn)</td></tr>
<tr class="memdesc:a05fefb596c7347a4bbc1f484ae90f6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an image.  <a href="class_bimage.html#a05fefb596c7347a4bbc1f484ae90f6bb">More...</a><br /></td></tr>
<tr class="separator:a05fefb596c7347a4bbc1f484ae90f6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcb3757ada7420ce5a48fff2fb1ce0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8fcb3757ada7420ce5a48fff2fb1ce0c">Bimage</a> (<a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> type, <a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a> ctype, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; <a class="el" href="class_bimage.html#aa73f430809a61cffcf9313c60a417090">size</a>, long nn)</td></tr>
<tr class="memdesc:a8fcb3757ada7420ce5a48fff2fb1ce0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an image.  <a href="class_bimage.html#a8fcb3757ada7420ce5a48fff2fb1ce0c">More...</a><br /></td></tr>
<tr class="separator:a8fcb3757ada7420ce5a48fff2fb1ce0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8f2cf3ae088ca3d5d171e159571e90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abd8f2cf3ae088ca3d5d171e159571e90">Bimage</a> (<a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> type, <a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a> ctype, vector&lt; long &gt; <a class="el" href="class_bimage.html#aa73f430809a61cffcf9313c60a417090">size</a>, long nn)</td></tr>
<tr class="memdesc:abd8f2cf3ae088ca3d5d171e159571e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an image.  <a href="class_bimage.html#abd8f2cf3ae088ca3d5d171e159571e90">More...</a><br /></td></tr>
<tr class="separator:abd8f2cf3ae088ca3d5d171e159571e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e9eef81a78901639de38bbdba0a5d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af7e9eef81a78901639de38bbdba0a5d1">Bimage</a> (<a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> type, long nc, long nx, long ny, long nz, long nn)</td></tr>
<tr class="memdesc:af7e9eef81a78901639de38bbdba0a5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a generic multi-channel image.  <a href="class_bimage.html#af7e9eef81a78901639de38bbdba0a5d1">More...</a><br /></td></tr>
<tr class="separator:af7e9eef81a78901639de38bbdba0a5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dde3db934477ded98998ebec647881a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6dde3db934477ded98998ebec647881a">Bimage</a> (<a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> type, long nc, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; <a class="el" href="class_bimage.html#aa73f430809a61cffcf9313c60a417090">size</a>, long nn)</td></tr>
<tr class="memdesc:a6dde3db934477ded98998ebec647881a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a generic multi-channel image.  <a href="class_bimage.html#a6dde3db934477ded98998ebec647881a">More...</a><br /></td></tr>
<tr class="separator:a6dde3db934477ded98998ebec647881a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9104e8dd80432d70e95570fb4c593fa0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9104e8dd80432d70e95570fb4c593fa0">Bimage</a> (<a class="el" href="class_matrix.html">Matrix</a> &amp;mat, long scale)</td></tr>
<tr class="memdesc:a9104e8dd80432d70e95570fb4c593fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an image from a 2D matrix.  <a href="class_bimage.html#a9104e8dd80432d70e95570fb4c593fa0">More...</a><br /></td></tr>
<tr class="separator:a9104e8dd80432d70e95570fb4c593fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad612df25d03e9be007a57ab619e5e76e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad612df25d03e9be007a57ab619e5e76e">~Bimage</a> ()</td></tr>
<tr class="memdesc:ad612df25d03e9be007a57ab619e5e76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image destructor.  <a href="class_bimage.html#ad612df25d03e9be007a57ab619e5e76e">More...</a><br /></td></tr>
<tr class="separator:ad612df25d03e9be007a57ab619e5e76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6a9ea88106962dc7045dc5d21437e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9d6a9ea88106962dc7045dc5d21437e2">guess_compoundtype</a> (long nc)</td></tr>
<tr class="separator:a9d6a9ea88106962dc7045dc5d21437e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f620f446bf442126513d907d05752a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a49f620f446bf442126513d907d05752a">check_compoundtype</a> (long nc, <a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a> ct)</td></tr>
<tr class="separator:a49f620f446bf442126513d907d05752a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab123614e965e5ca895a14ccf30c234a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab123614e965e5ca895a14ccf30c234a5">check</a> ()</td></tr>
<tr class="memdesc:ab123614e965e5ca895a14ccf30c234a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks an image for reasonable properties.  <a href="class_bimage.html#ab123614e965e5ca895a14ccf30c234a5">More...</a><br /></td></tr>
<tr class="separator:ab123614e965e5ca895a14ccf30c234a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881571949007af044036c47b07b8a3c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a881571949007af044036c47b07b8a3c6">check_if_same_size</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:a881571949007af044036c47b07b8a3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two images are the same size.  <a href="class_bimage.html#a881571949007af044036c47b07b8a3c6">More...</a><br /></td></tr>
<tr class="separator:a881571949007af044036c47b07b8a3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981cab4e4430114b52918a2791586777"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a981cab4e4430114b52918a2791586777">check_if_same_image_size</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:a981cab4e4430114b52918a2791586777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two images are the same size.  <a href="class_bimage.html#a981cab4e4430114b52918a2791586777">More...</a><br /></td></tr>
<tr class="separator:a981cab4e4430114b52918a2791586777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e389c2208e3cae5d498ec60fd95a75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a74e389c2208e3cae5d498ec60fd95a75">check_sampling</a> ()</td></tr>
<tr class="memdesc:a74e389c2208e3cae5d498ec60fd95a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the sampling is properly specified.  <a href="class_bimage.html#a74e389c2208e3cae5d498ec60fd95a75">More...</a><br /></td></tr>
<tr class="separator:a74e389c2208e3cae5d498ec60fd95a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad464e07a4843fb9d38eb11345b2325b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad464e07a4843fb9d38eb11345b2325b6">check_resolution</a> (double &amp;resolution)</td></tr>
<tr class="memdesc:ad464e07a4843fb9d38eb11345b2325b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the resolution falls within reasonable limits.  <a href="class_bimage.html#ad464e07a4843fb9d38eb11345b2325b6">More...</a><br /></td></tr>
<tr class="separator:ad464e07a4843fb9d38eb11345b2325b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb42c15f87e1e551f9d2dbef8491dcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2bb42c15f87e1e551f9d2dbef8491dcd">compatible</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:a2bb42c15f87e1e551f9d2dbef8491dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this image has the same number of channels and data type as another.  <a href="class_bimage.html#a2bb42c15f87e1e551f9d2dbef8491dcd">More...</a><br /></td></tr>
<tr class="separator:a2bb42c15f87e1e551f9d2dbef8491dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bdc9cb92f3deebd4cd66188048fea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab7bdc9cb92f3deebd4cd66188048fea6">identifier</a> (<a class="el" href="class_bstring.html">Bstring</a> s)</td></tr>
<tr class="separator:ab7bdc9cb92f3deebd4cd66188048fea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ac44ea27081b2cd7b3ccae2de8a082"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bstring.html">Bstring</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a41ac44ea27081b2cd7b3ccae2de8a082">identifier</a> ()</td></tr>
<tr class="separator:a41ac44ea27081b2cd7b3ccae2de8a082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2f9330ca3541625f7a55d6e4ed94ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_j_svalue.html">JSvalue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4d2f9330ca3541625f7a55d6e4ed94ca">meta_data</a> ()</td></tr>
<tr class="separator:a4d2f9330ca3541625f7a55d6e4ed94ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba0b9cd4a35c4bde1e08cf50c0c951a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_j_svalue.html">JSvalue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aeba0b9cd4a35c4bde1e08cf50c0c951a">operator[]</a> (string tag)</td></tr>
<tr class="separator:aeba0b9cd4a35c4bde1e08cf50c0c951a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1a95f271379fca8636f8e1b68d74c4"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_j_svalue.html">JSvalue</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8d1a95f271379fca8636f8e1b68d74c4">query</a> (string &amp;path)</td></tr>
<tr class="separator:a8d1a95f271379fca8636f8e1b68d74c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48733dde4aaf8c925278d983fb252fb"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab48733dde4aaf8c925278d983fb252fb">erase</a> (string tag)</td></tr>
<tr class="separator:ab48733dde4aaf8c925278d983fb252fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772035b309aa215414b94b3e1f991920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a772035b309aa215414b94b3e1f991920">meta_data_update</a> ()</td></tr>
<tr class="memdesc:a772035b309aa215414b94b3e1f991920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update metadata from the sub-image information.  <a href="class_bimage.html#a772035b309aa215414b94b3e1f991920">More...</a><br /></td></tr>
<tr class="separator:a772035b309aa215414b94b3e1f991920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42dd5c73484665555ed8068a6fc0f63c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a42dd5c73484665555ed8068a6fc0f63c">update_from_meta_data</a> ()</td></tr>
<tr class="memdesc:a42dd5c73484665555ed8068a6fc0f63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update sub-image information from the metadata.  <a href="class_bimage.html#a42dd5c73484665555ed8068a6fc0f63c">More...</a><br /></td></tr>
<tr class="separator:a42dd5c73484665555ed8068a6fc0f63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6882144669b3c67abb55e76d4623a40b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6882144669b3c67abb55e76d4623a40b">meta_data_retain_one_image</a> (long img_num)</td></tr>
<tr class="memdesc:a6882144669b3c67abb55e76d4623a40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all sub-image records from the meta data except one.  <a href="class_bimage.html#a6882144669b3c67abb55e76d4623a40b">More...</a><br /></td></tr>
<tr class="separator:a6882144669b3c67abb55e76d4623a40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be9f3ca7d6cb23f7310f4152bb19362"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2be9f3ca7d6cb23f7310f4152bb19362">file_name</a> (string s)</td></tr>
<tr class="separator:a2be9f3ca7d6cb23f7310f4152bb19362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee3dc69a69e3588ae89d01e23e4b939"><td class="memItemLeft" align="right" valign="top">string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2ee3dc69a69e3588ae89d01e23e4b939">file_name</a> ()</td></tr>
<tr class="separator:a2ee3dc69a69e3588ae89d01e23e4b939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662b99c550dfa6842da821bb9e2fe59f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a662b99c550dfa6842da821bb9e2fe59f">find</a> (<a class="el" href="class_bstring.html">Bstring</a> fn)</td></tr>
<tr class="separator:a662b99c550dfa6842da821bb9e2fe59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe7685945a1b8b18efa7e8759fd8b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aafe7685945a1b8b18efa7e8759fd8b02">label</a> (string s)</td></tr>
<tr class="separator:aafe7685945a1b8b18efa7e8759fd8b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe834cee6404653d7cce3ba2dd3783a4"><td class="memItemLeft" align="right" valign="top">string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afe834cee6404653d7cce3ba2dd3783a4">label</a> ()</td></tr>
<tr class="separator:afe834cee6404653d7cce3ba2dd3783a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdc58228bbe84e0c029c347d0c61c9f"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8bdc58228bbe84e0c029c347d0c61c9f">get_time</a> ()</td></tr>
<tr class="separator:a8bdc58228bbe84e0c029c347d0c61c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840e19a120e4a6fad753a72498e318e9"><td class="memItemLeft" align="right" valign="top">tm *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a840e19a120e4a6fad753a72498e318e9">get_localtime</a> ()</td></tr>
<tr class="separator:a840e19a120e4a6fad753a72498e318e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9143f5bc96c3fb12dada8d1be1120332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9143f5bc96c3fb12dada8d1be1120332">set_time</a> (time_t t)</td></tr>
<tr class="separator:a9143f5bc96c3fb12dada8d1be1120332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906cdf211bd171c7af7088c3ac70423c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a906cdf211bd171c7af7088c3ac70423c">set_time</a> (tm *t)</td></tr>
<tr class="separator:a906cdf211bd171c7af7088c3ac70423c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab24545dd418ba976941ee9cc5aaad4"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adab24545dd418ba976941ee9cc5aaad4">alloc_size</a> () const</td></tr>
<tr class="separator:adab24545dd418ba976941ee9cc5aaad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d289504ed427397f78837e881dc6ca3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3d289504ed427397f78837e881dc6ca3">data_size</a> ()</td></tr>
<tr class="separator:a3d289504ed427397f78837e881dc6ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166ca3b55bdab6020603df0f06f53948"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a166ca3b55bdab6020603df0f06f53948">data_alloc</a> ()</td></tr>
<tr class="separator:a166ca3b55bdab6020603df0f06f53948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21fcbb3113b902a3027f9c7a8a77ac5"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af21fcbb3113b902a3027f9c7a8a77ac5">data_alloc_and_clear</a> ()</td></tr>
<tr class="separator:af21fcbb3113b902a3027f9c7a8a77ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ea567d0cdd61f54b15ada3663dfce1"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a58ea567d0cdd61f54b15ada3663dfce1">data_alloc</a> (long nbytes)</td></tr>
<tr class="memdesc:a58ea567d0cdd61f54b15ada3663dfce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate image data.  <a href="class_bimage.html#a58ea567d0cdd61f54b15ada3663dfce1">More...</a><br /></td></tr>
<tr class="separator:a58ea567d0cdd61f54b15ada3663dfce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557e656fd78fb72403170ef3da4f6391"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a557e656fd78fb72403170ef3da4f6391">data_alloc_and_clear</a> (long nbytes)</td></tr>
<tr class="separator:a557e656fd78fb72403170ef3da4f6391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6de434ebeb11ba2ade23d9d463270a"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6a6de434ebeb11ba2ade23d9d463270a">data_alloc</a> (<a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> type, <a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a> ctype, long nx, long ny, long nz, long nn)</td></tr>
<tr class="memdesc:a6a6de434ebeb11ba2ade23d9d463270a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate image data with size parameters.  <a href="class_bimage.html#a6a6de434ebeb11ba2ade23d9d463270a">More...</a><br /></td></tr>
<tr class="separator:a6a6de434ebeb11ba2ade23d9d463270a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80310f2ba9fc1adee9bc384daf0f546"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa80310f2ba9fc1adee9bc384daf0f546">data_alloc_and_clear</a> (<a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> type, <a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a> ctype, long nx, long ny, long nz, long nn)</td></tr>
<tr class="separator:aa80310f2ba9fc1adee9bc384daf0f546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997d17b3f9bbd3a5b13450b0379c1aa5"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a997d17b3f9bbd3a5b13450b0379c1aa5">data_assign</a> (unsigned char *nudata)</td></tr>
<tr class="memdesc:a997d17b3f9bbd3a5b13450b0379c1aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign image data.  <a href="class_bimage.html#a997d17b3f9bbd3a5b13450b0379c1aa5">More...</a><br /></td></tr>
<tr class="separator:a997d17b3f9bbd3a5b13450b0379c1aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8692aa9f36d2bf5d4a729740e342b039"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8692aa9f36d2bf5d4a729740e342b039">data_pointer</a> ()</td></tr>
<tr class="separator:a8692aa9f36d2bf5d4a729740e342b039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce227603aa919e5a72b14d7120ca1ce"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5ce227603aa919e5a72b14d7120ca1ce">data_pointer</a> (long offset)</td></tr>
<tr class="separator:a5ce227603aa919e5a72b14d7120ca1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4232f60f0d0582b7208845757a2c1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afb4232f60f0d0582b7208845757a2c1a">data_pointer</a> (unsigned char *ptr)</td></tr>
<tr class="separator:afb4232f60f0d0582b7208845757a2c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde298560de4552e4abda21507882d29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afde298560de4552e4abda21507882d29">data_delete</a> ()</td></tr>
<tr class="memdesc:afde298560de4552e4abda21507882d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates the image data.  <a href="class_bimage.html#afde298560de4552e4abda21507882d29">More...</a><br /></td></tr>
<tr class="separator:afde298560de4552e4abda21507882d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab570544ea8a468fc75005223bce4faf"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aab570544ea8a468fc75005223bce4faf">data_offset</a> ()</td></tr>
<tr class="separator:aab570544ea8a468fc75005223bce4faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d42f4d6f9070c0ec55e68b78eb3c9f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2d42f4d6f9070c0ec55e68b78eb3c9f0">data_offset</a> (long doff)</td></tr>
<tr class="separator:a2d42f4d6f9070c0ec55e68b78eb3c9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273fc6371ef29fae7e1150552334b262"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a273fc6371ef29fae7e1150552334b262">image_size</a> ()</td></tr>
<tr class="separator:a273fc6371ef29fae7e1150552334b262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b048e81f60b70ed447b2f320fd2a84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a04b048e81f60b70ed447b2f320fd2a84">operator=</a> (const <a class="el" href="class_bimage.html">Bimage</a> &amp;p)</td></tr>
<tr class="memdesc:a04b048e81f60b70ed447b2f320fd2a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an image.  <a href="class_bimage.html#a04b048e81f60b70ed447b2f320fd2a84">More...</a><br /></td></tr>
<tr class="separator:a04b048e81f60b70ed447b2f320fd2a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e22c15acc26a18a01f9ffe932dc7dd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae7e22c15acc26a18a01f9ffe932dc7dd">operator[]</a> (long j) const</td></tr>
<tr class="memdesc:ae7e22c15acc26a18a01f9ffe932dc7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data value at the given index.  <a href="class_bimage.html#ae7e22c15acc26a18a01f9ffe932dc7dd">More...</a><br /></td></tr>
<tr class="separator:ae7e22c15acc26a18a01f9ffe932dc7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fe0a2bedf7cd2fa732e4af2fbcb8fe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa3fe0a2bedf7cd2fa732e4af2fbcb8fe">get</a> (long nn, long xx, long yy, long zz, long cc=0)</td></tr>
<tr class="memdesc:aa3fe0a2bedf7cd2fa732e4af2fbcb8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data value at the given coordinates.  <a href="class_bimage.html#aa3fe0a2bedf7cd2fa732e4af2fbcb8fe">More...</a><br /></td></tr>
<tr class="separator:aa3fe0a2bedf7cd2fa732e4af2fbcb8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cbc0cc1004deca981a0b5b20850c20"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa9cbc0cc1004deca981a0b5b20850c20">get</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vox, long cc=0)</td></tr>
<tr class="memdesc:aa9cbc0cc1004deca981a0b5b20850c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data value at the given coordinates.  <a href="class_bimage.html#aa9cbc0cc1004deca981a0b5b20850c20">More...</a><br /></td></tr>
<tr class="separator:aa9cbc0cc1004deca981a0b5b20850c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0015cbfaf312d0e77f62ff5e413f5a14"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0015cbfaf312d0e77f62ff5e413f5a14">values</a> (long i)</td></tr>
<tr class="separator:a0015cbfaf312d0e77f62ff5e413f5a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5c2a2c6d2b645b5c076703c2ef35c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0c5c2a2c6d2b645b5c076703c2ef35c4">values</a> (long i, vector&lt; double &gt; val)</td></tr>
<tr class="separator:a0c5c2a2c6d2b645b5c076703c2ef35c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1bb8c97d8f6513ae63dc0f101f4f81"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aab1bb8c97d8f6513ae63dc0f101f4f81">values</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vox)</td></tr>
<tr class="memdesc:aab1bb8c97d8f6513ae63dc0f101f4f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array with all channel data at the given coordinates.  <a href="class_bimage.html#aab1bb8c97d8f6513ae63dc0f101f4f81">More...</a><br /></td></tr>
<tr class="separator:aab1bb8c97d8f6513ae63dc0f101f4f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7feb28efaaf52eddebd38d00066a1a2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_complex.html">Complex</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7feb28efaaf52eddebd38d00066a1a2e">complex</a> (long j)</td></tr>
<tr class="memdesc:a7feb28efaaf52eddebd38d00066a1a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a complex value at the given index.  <a href="class_bimage.html#a7feb28efaaf52eddebd38d00066a1a2e">More...</a><br /></td></tr>
<tr class="separator:a7feb28efaaf52eddebd38d00066a1a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47314981f2e8b29a34b0eeba3f25e541"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a47314981f2e8b29a34b0eeba3f25e541">vector3</a> (long j)</td></tr>
<tr class="memdesc:a47314981f2e8b29a34b0eeba3f25e541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 3-value vector at the given index.  <a href="class_bimage.html#a47314981f2e8b29a34b0eeba3f25e541">More...</a><br /></td></tr>
<tr class="separator:a47314981f2e8b29a34b0eeba3f25e541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d343109d74d589f4fc4ce873b4f9e03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_g_b.html">RGB</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2d343109d74d589f4fc4ce873b4f9e03">rgb</a> (long j)</td></tr>
<tr class="memdesc:a2d343109d74d589f4fc4ce873b4f9e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color value at the given index.  <a href="class_bimage.html#a2d343109d74d589f4fc4ce873b4f9e03">More...</a><br /></td></tr>
<tr class="separator:a2d343109d74d589f4fc4ce873b4f9e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bffddc51e0a60f24d2768534501f9d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_g_b_a.html">RGBA</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7bffddc51e0a60f24d2768534501f9d7">rgba</a> (long j)</td></tr>
<tr class="memdesc:a7bffddc51e0a60f24d2768534501f9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color value at the given index.  <a href="class_bimage.html#a7bffddc51e0a60f24d2768534501f9d7">More...</a><br /></td></tr>
<tr class="separator:a7bffddc51e0a60f24d2768534501f9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af778ba174284334f20ddef7fc191b249"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_m_y_k.html">CMYK</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af778ba174284334f20ddef7fc191b249">cmyk</a> (long j)</td></tr>
<tr class="memdesc:af778ba174284334f20ddef7fc191b249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a color value at the given index.  <a href="class_bimage.html#af778ba174284334f20ddef7fc191b249">More...</a><br /></td></tr>
<tr class="separator:af778ba174284334f20ddef7fc191b249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ae6d409fb5708f0393e8629699b8ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_type_pointer.html">TypePointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a17ae6d409fb5708f0393e8629699b8ec">fill_value</a> (double v)</td></tr>
<tr class="separator:a17ae6d409fb5708f0393e8629699b8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f091b084f0e714284d7c761dd4c0b15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7f091b084f0e714284d7c761dd4c0b15">set</a> (long j, double v)</td></tr>
<tr class="memdesc:a7f091b084f0e714284d7c761dd4c0b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a single value at the given index.  <a href="class_bimage.html#a7f091b084f0e714284d7c761dd4c0b15">More...</a><br /></td></tr>
<tr class="separator:a7f091b084f0e714284d7c761dd4c0b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a60b5de3fd18a6c8e0858af9cd65b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a44a60b5de3fd18a6c8e0858af9cd65b8">set</a> (long j, <a class="el" href="class_complex.html">Complex</a>&lt; double &gt; cv)</td></tr>
<tr class="memdesc:a44a60b5de3fd18a6c8e0858af9cd65b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a complex value at the given index.  <a href="class_bimage.html#a44a60b5de3fd18a6c8e0858af9cd65b8">More...</a><br /></td></tr>
<tr class="separator:a44a60b5de3fd18a6c8e0858af9cd65b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff9753006d934364d77b51c87b34fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abff9753006d934364d77b51c87b34fa4">set</a> (long j, <a class="el" href="class_r_g_b.html">RGB</a>&lt; double &gt; color)</td></tr>
<tr class="memdesc:abff9753006d934364d77b51c87b34fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a color value at the given index.  <a href="class_bimage.html#abff9753006d934364d77b51c87b34fa4">More...</a><br /></td></tr>
<tr class="separator:abff9753006d934364d77b51c87b34fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4265c10a266a3f930f0f773f4d1d45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0e4265c10a266a3f930f0f773f4d1d45">set</a> (long j, <a class="el" href="class_r_g_b_a.html">RGBA</a>&lt; double &gt; color)</td></tr>
<tr class="memdesc:a0e4265c10a266a3f930f0f773f4d1d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a color value at the given index.  <a href="class_bimage.html#a0e4265c10a266a3f930f0f773f4d1d45">More...</a><br /></td></tr>
<tr class="separator:a0e4265c10a266a3f930f0f773f4d1d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e615360c7c3c68ed3144acccf40f02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a08e615360c7c3c68ed3144acccf40f02">set</a> (long j, <a class="el" href="class_c_m_y_k.html">CMYK</a>&lt; double &gt; color)</td></tr>
<tr class="memdesc:a08e615360c7c3c68ed3144acccf40f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a color value at the given index.  <a href="class_bimage.html#a08e615360c7c3c68ed3144acccf40f02">More...</a><br /></td></tr>
<tr class="separator:a08e615360c7c3c68ed3144acccf40f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c53e826eac2717012b6c08e04c0d9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a53c53e826eac2717012b6c08e04c0d9a">set</a> (long j, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vec)</td></tr>
<tr class="memdesc:a53c53e826eac2717012b6c08e04c0d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a 3-value vector at the given index.  <a href="class_bimage.html#a53c53e826eac2717012b6c08e04c0d9a">More...</a><br /></td></tr>
<tr class="separator:a53c53e826eac2717012b6c08e04c0d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e0d8a5922143b1c8edba5c07aacb13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a30e0d8a5922143b1c8edba5c07aacb13">set</a> (long j, <a class="el" href="class_view.html">View</a> <a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>)</td></tr>
<tr class="memdesc:a30e0d8a5922143b1c8edba5c07aacb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a 3-value vector at the given index.  <a href="class_bimage.html#a30e0d8a5922143b1c8edba5c07aacb13">More...</a><br /></td></tr>
<tr class="separator:a30e0d8a5922143b1c8edba5c07aacb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77f64f607b94b80056a05befc2b686d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af77f64f607b94b80056a05befc2b686d">add</a> (long j, double v)</td></tr>
<tr class="separator:af77f64f607b94b80056a05befc2b686d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cec4b61e523881e5cc05f62c0058a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a04cec4b61e523881e5cc05f62c0058a8">add</a> (long j, <a class="el" href="class_complex.html">Complex</a>&lt; double &gt; cv)</td></tr>
<tr class="separator:a04cec4b61e523881e5cc05f62c0058a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5557cef39f005b06b6bd75993a75e54f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5557cef39f005b06b6bd75993a75e54f">add</a> (double xx, double yy, double zz, long nn, double v)</td></tr>
<tr class="memdesc:a5557cef39f005b06b6bd75993a75e54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a value at a given location to neigboring data elements.  <a href="class_bimage.html#a5557cef39f005b06b6bd75993a75e54f">More...</a><br /></td></tr>
<tr class="separator:a5557cef39f005b06b6bd75993a75e54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059a3df092b74a3b4f56ef2623a1a45d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a059a3df092b74a3b4f56ef2623a1a45d">set_max</a> (double xx, double yy, double zz, long nn, double v)</td></tr>
<tr class="memdesc:a059a3df092b74a3b4f56ef2623a1a45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value at a given location to neigboring data elements if it is larger.  <a href="class_bimage.html#a059a3df092b74a3b4f56ef2623a1a45d">More...</a><br /></td></tr>
<tr class="separator:a059a3df092b74a3b4f56ef2623a1a45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3852c4e4ecd306c5d6abc09f3d78f7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad3852c4e4ecd306c5d6abc09f3d78f7f">multiply</a> (long j, <a class="el" href="class_complex.html">Complex</a>&lt; double &gt; cv)</td></tr>
<tr class="separator:ad3852c4e4ecd306c5d6abc09f3d78f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536c5f24e8492683cc0c65678c524ed2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a536c5f24e8492683cc0c65678c524ed2">average2D</a> (long cc, double xf, double yf, double zf, long nn, double iscale)</td></tr>
<tr class="memdesc:a536c5f24e8492683cc0c65678c524ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Averages in the xy plane when scaling is less than 1.  <a href="class_bimage.html#a536c5f24e8492683cc0c65678c524ed2">More...</a><br /></td></tr>
<tr class="separator:a536c5f24e8492683cc0c65678c524ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7559f244271ee490d3746da9a02378"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8b7559f244271ee490d3746da9a02378">average</a> (long cc, double xf, double yf, double zf, long nn, double iscale)</td></tr>
<tr class="memdesc:a8b7559f244271ee490d3746da9a02378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Averages in 3D when scaling is less than 1.  <a href="class_bimage.html#a8b7559f244271ee490d3746da9a02378">More...</a><br /></td></tr>
<tr class="separator:a8b7559f244271ee490d3746da9a02378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ed6903b8c8e716f55c8bd7d884c9b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a42ed6903b8c8e716f55c8bd7d884c9b0">interpolate</a> (long cc, double xx, double yy=0, double zz=0, long nn=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0) const</td></tr>
<tr class="memdesc:a42ed6903b8c8e716f55c8bd7d884c9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates using a given location.  <a href="class_bimage.html#a42ed6903b8c8e716f55c8bd7d884c9b0">More...</a><br /></td></tr>
<tr class="separator:a42ed6903b8c8e716f55c8bd7d884c9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846421e8a35109bb1f20dbe772ccc677"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a846421e8a35109bb1f20dbe772ccc677">interpolate</a> (double xx, double yy=0, double zz=0, long nn=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0) const</td></tr>
<tr class="separator:a846421e8a35109bb1f20dbe772ccc677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb5f320d3082349fa4706966eb1af6c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3fb5f320d3082349fa4706966eb1af6c">interpolate</a> (long cc, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vec, long nn=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0) const</td></tr>
<tr class="separator:a3fb5f320d3082349fa4706966eb1af6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f7ba2720f2852ee89d471b885f03cb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa2f7ba2720f2852ee89d471b885f03cb">interpolate</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vec, long nn=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0) const</td></tr>
<tr class="separator:aa2f7ba2720f2852ee89d471b885f03cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdece81eeb52253229885c3911d4316"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5bdece81eeb52253229885c3911d4316">interpolate</a> (vector&lt; double &gt; vec, long nn=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0) const</td></tr>
<tr class="separator:a5bdece81eeb52253229885c3911d4316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23dc8034036c8ac619601259ead7444"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af23dc8034036c8ac619601259ead7444">interpolate_wrap</a> (long cc, double xx, double yy=0, double zz=0, long nn=0) const</td></tr>
<tr class="memdesc:af23dc8034036c8ac619601259ead7444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates using a given location with wrapping.  <a href="class_bimage.html#af23dc8034036c8ac619601259ead7444">More...</a><br /></td></tr>
<tr class="separator:af23dc8034036c8ac619601259ead7444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08401d5d8da91205f95925898575903b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a08401d5d8da91205f95925898575903b">interpolate_wrap</a> (double xx, double yy=0, double zz=0, long nn=0) const</td></tr>
<tr class="separator:a08401d5d8da91205f95925898575903b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbcd90dfa5c60b281ab2efb975f2d38"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#accbcd90dfa5c60b281ab2efb975f2d38">interpolate_wrap</a> (long cc, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vec, long nn=0) const</td></tr>
<tr class="separator:accbcd90dfa5c60b281ab2efb975f2d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa621195acbabd5c81c769d0ca17e9041"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa621195acbabd5c81c769d0ca17e9041">interpolate_wrap</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vec, long nn=0) const</td></tr>
<tr class="separator:aa621195acbabd5c81c769d0ca17e9041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8daaa394b40c3d3fec19e544125e5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3f8daaa394b40c3d3fec19e544125e5c">data_type</a> ()</td></tr>
<tr class="separator:a3f8daaa394b40c3d3fec19e544125e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682d0ecb697de9856110a4ad841fb70c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a682d0ecb697de9856110a4ad841fb70c">data_type</a> (<a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> dt)</td></tr>
<tr class="separator:a682d0ecb697de9856110a4ad841fb70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f685cb874a2593c8520b18962be360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a94f685cb874a2593c8520b18962be360">compound_type</a> ()</td></tr>
<tr class="separator:a94f685cb874a2593c8520b18962be360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ad0e179f96e2d7fa0bb02d9853c1b6"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa2ad0e179f96e2d7fa0bb02d9853c1b6">compound_type</a> (<a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a> ct)</td></tr>
<tr class="separator:aa2ad0e179f96e2d7fa0bb02d9853c1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b8a851da4087a959b592c4645c755b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab5b8a851da4087a959b592c4645c755b">data_type_bits</a> () const</td></tr>
<tr class="memdesc:ab5b8a851da4087a959b592c4645c755b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the datatype in bits.  <a href="class_bimage.html#ab5b8a851da4087a959b592c4645c755b">More...</a><br /></td></tr>
<tr class="separator:ab5b8a851da4087a959b592c4645c755b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d72f814a078c88879693bbf71b54cf5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7d72f814a078c88879693bbf71b54cf5">data_type_size</a> () const</td></tr>
<tr class="memdesc:a7d72f814a078c88879693bbf71b54cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the datatype in bytes.  <a href="class_bimage.html#a7d72f814a078c88879693bbf71b54cf5">More...</a><br /></td></tr>
<tr class="separator:a7d72f814a078c88879693bbf71b54cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba25aac6daf2be313372df9017583703"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aba25aac6daf2be313372df9017583703">compound_type_size</a> ()</td></tr>
<tr class="separator:aba25aac6daf2be313372df9017583703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96111e0fd5ff64a7e037dcba8235b823"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a96111e0fd5ff64a7e037dcba8235b823">data_type_min</a> ()</td></tr>
<tr class="memdesc:a96111e0fd5ff64a7e037dcba8235b823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum of a datatype.  <a href="class_bimage.html#a96111e0fd5ff64a7e037dcba8235b823">More...</a><br /></td></tr>
<tr class="separator:a96111e0fd5ff64a7e037dcba8235b823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b1bfcf9448a2a6ab4ae52ee7725a81"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac7b1bfcf9448a2a6ab4ae52ee7725a81">data_type_max</a> ()</td></tr>
<tr class="memdesc:ac7b1bfcf9448a2a6ab4ae52ee7725a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum of a datatype.  <a href="class_bimage.html#ac7b1bfcf9448a2a6ab4ae52ee7725a81">More...</a><br /></td></tr>
<tr class="separator:ac7b1bfcf9448a2a6ab4ae52ee7725a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ad6a3996ad556af36d215b4eb47904"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bstring.html">Bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a93ad6a3996ad556af36d215b4eb47904">data_type_string</a> ()</td></tr>
<tr class="memdesc:a93ad6a3996ad556af36d215b4eb47904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string representation of a datatype.  <a href="class_bimage.html#a93ad6a3996ad556af36d215b4eb47904">More...</a><br /></td></tr>
<tr class="separator:a93ad6a3996ad556af36d215b4eb47904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7eaa823a3e59fde34b41efa65bc64f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bstring.html">Bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6d7eaa823a3e59fde34b41efa65bc64f">compound_type_string</a> ()</td></tr>
<tr class="memdesc:a6d7eaa823a3e59fde34b41efa65bc64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string representation of a datatype.  <a href="class_bimage.html#a6d7eaa823a3e59fde34b41efa65bc64f">More...</a><br /></td></tr>
<tr class="separator:a6d7eaa823a3e59fde34b41efa65bc64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c08defb61a7aa665e94d222ea88d08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad5c08defb61a7aa665e94d222ea88d08">fix_type</a> ()</td></tr>
<tr class="memdesc:ad5c08defb61a7aa665e94d222ea88d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the replacement data type.  <a href="class_bimage.html#ad5c08defb61a7aa665e94d222ea88d08">More...</a><br /></td></tr>
<tr class="separator:ad5c08defb61a7aa665e94d222ea88d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2848239c21e111b23b87b4c2a95dd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aaf2848239c21e111b23b87b4c2a95dd5">change_type</a> (char letter)</td></tr>
<tr class="memdesc:aaf2848239c21e111b23b87b4c2a95dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data type indicated by a single letter code.  <a href="class_bimage.html#aaf2848239c21e111b23b87b4c2a95dd5">More...</a><br /></td></tr>
<tr class="separator:aaf2848239c21e111b23b87b4c2a95dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edb27a22dcc386452236472c6a1c916"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5edb27a22dcc386452236472c6a1c916">change_type</a> (char *string)</td></tr>
<tr class="memdesc:a5edb27a22dcc386452236472c6a1c916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data type from a string.  <a href="class_bimage.html#a5edb27a22dcc386452236472c6a1c916">More...</a><br /></td></tr>
<tr class="separator:a5edb27a22dcc386452236472c6a1c916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ed25186621c0611497ee8738e9d602"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a05ed25186621c0611497ee8738e9d602">change_type</a> (<a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> nutype)</td></tr>
<tr class="memdesc:a05ed25186621c0611497ee8738e9d602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the data to the new type.  <a href="class_bimage.html#a05ed25186621c0611497ee8738e9d602">More...</a><br /></td></tr>
<tr class="separator:a05ed25186621c0611497ee8738e9d602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33659b73113d0d84e2482517310311d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a33659b73113d0d84e2482517310311d5">split_channels</a> ()</td></tr>
<tr class="memdesc:a33659b73113d0d84e2482517310311d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the channels into individual images.  <a href="class_bimage.html#a33659b73113d0d84e2482517310311d5">More...</a><br /></td></tr>
<tr class="separator:a33659b73113d0d84e2482517310311d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad307b8fb1ce8c72a850c3ceb0fe89002"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad307b8fb1ce8c72a850c3ceb0fe89002">combine_channels</a> (long nc, <a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a> ct=<a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36ad83a0f556634bd31d3357be2a64aac4c">TSimple</a>)</td></tr>
<tr class="memdesc:ad307b8fb1ce8c72a850c3ceb0fe89002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines images as channels.  <a href="class_bimage.html#ad307b8fb1ce8c72a850c3ceb0fe89002">More...</a><br /></td></tr>
<tr class="separator:ad307b8fb1ce8c72a850c3ceb0fe89002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd16f09564f26841e4e0468ae3a232f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_bimage_8h.html#a01e0deba350901d769526633e868806f">FourierType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2fd16f09564f26841e4e0468ae3a232f">fourier_type</a> ()</td></tr>
<tr class="separator:a2fd16f09564f26841e4e0468ae3a232f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc472566e81a653bf7659c2f26fd0e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2bc472566e81a653bf7659c2f26fd0e9">fourier_type</a> (<a class="el" href="_bimage_8h.html#a01e0deba350901d769526633e868806f">FourierType</a> tf)</td></tr>
<tr class="separator:a2bc472566e81a653bf7659c2f26fd0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c09597809c7610566d5615cf9dbfca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7c09597809c7610566d5615cf9dbfca1">zero_fourier_origin</a> ()</td></tr>
<tr class="memdesc:a7c09597809c7610566d5615cf9dbfca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeroes the first voxel in each image.  <a href="class_bimage.html#a7c09597809c7610566d5615cf9dbfca1">More...</a><br /></td></tr>
<tr class="separator:a7c09597809c7610566d5615cf9dbfca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6430319a01ff1931cf0d88fb92abca6e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6430319a01ff1931cf0d88fb92abca6e">channels</a> ()</td></tr>
<tr class="separator:a6430319a01ff1931cf0d88fb92abca6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867c0564aeba2d80617b4f3b6be737da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a867c0564aeba2d80617b4f3b6be737da">channels</a> (long cc)</td></tr>
<tr class="separator:a867c0564aeba2d80617b4f3b6be737da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73f430809a61cffcf9313c60a417090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa73f430809a61cffcf9313c60a417090">size</a> () const</td></tr>
<tr class="separator:aa73f430809a61cffcf9313c60a417090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04248059b87991c9de87d916c3dacfe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a04248059b87991c9de87d916c3dacfe9">size</a> (long nx, long ny, long nz)</td></tr>
<tr class="separator:a04248059b87991c9de87d916c3dacfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92c7423ec3efeebff4da5fc880282bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad92c7423ec3efeebff4da5fc880282bb">size</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; vec)</td></tr>
<tr class="separator:ad92c7423ec3efeebff4da5fc880282bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a3862564a94ee0bef5c1d2b0a33180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a15a3862564a94ee0bef5c1d2b0a33180">size</a> (vector&lt; long &gt; vec)</td></tr>
<tr class="separator:a15a3862564a94ee0bef5c1d2b0a33180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7935b0778f079de4436a87e6007beb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8a7935b0778f079de4436a87e6007beb">sizeX</a> (long nx)</td></tr>
<tr class="separator:a8a7935b0778f079de4436a87e6007beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fff6fffe26b2cf9954c7086838deac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a24fff6fffe26b2cf9954c7086838deac">sizeY</a> (long ny)</td></tr>
<tr class="separator:a24fff6fffe26b2cf9954c7086838deac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0af0b19b20a1f3a29f6d46cf0a38964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa0af0b19b20a1f3a29f6d46cf0a38964">sizeZ</a> (long nz)</td></tr>
<tr class="separator:aa0af0b19b20a1f3a29f6d46cf0a38964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573098677821d6cb2a3f971a60600585"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a573098677821d6cb2a3f971a60600585">sizeX</a> () const</td></tr>
<tr class="separator:a573098677821d6cb2a3f971a60600585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950470752066c7c8c3a42df1dcbba815"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a950470752066c7c8c3a42df1dcbba815">sizeY</a> () const</td></tr>
<tr class="separator:a950470752066c7c8c3a42df1dcbba815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598f1a14a9194965bb93d57c0510536f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a598f1a14a9194965bb93d57c0510536f">sizeZ</a> () const</td></tr>
<tr class="separator:a598f1a14a9194965bb93d57c0510536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760143d3cb8fd5d6e1245ecd215821a2"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a760143d3cb8fd5d6e1245ecd215821a2">index</a> (long nx, long ny) const</td></tr>
<tr class="separator:a760143d3cb8fd5d6e1245ecd215821a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce1e553efbc68da56f446626a005142"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3ce1e553efbc68da56f446626a005142">index</a> (long nx, long ny, long nz) const</td></tr>
<tr class="separator:a3ce1e553efbc68da56f446626a005142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6114a3346ee83eed50e799fd887c1302"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6114a3346ee83eed50e799fd887c1302">index</a> (long nx, long ny, long nz, long nn) const</td></tr>
<tr class="separator:a6114a3346ee83eed50e799fd887c1302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40279a9386d8c571cf573ec7f2c328f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa40279a9386d8c571cf573ec7f2c328f">index</a> (long nc, long nx, long ny, long nz, long nn) const</td></tr>
<tr class="separator:aa40279a9386d8c571cf573ec7f2c328f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83754238aa74181ac04e7effd55b1e5f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a83754238aa74181ac04e7effd55b1e5f">index</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; vox, long nn) const</td></tr>
<tr class="separator:a83754238aa74181ac04e7effd55b1e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed40effbf49e57048e306d2df8f24177"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aed40effbf49e57048e306d2df8f24177">index</a> (vector&lt; long &gt; vox, long nn) const</td></tr>
<tr class="separator:aed40effbf49e57048e306d2df8f24177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd88814c41f2c26ecdfef9febc8c1b42"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abd88814c41f2c26ecdfef9febc8c1b42">index_wrap</a> (long nx, long ny, long nz) const</td></tr>
<tr class="separator:abd88814c41f2c26ecdfef9febc8c1b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44270f08caaa5aced16a390e07cc34d3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a44270f08caaa5aced16a390e07cc34d3">index_wrap</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; coor) const</td></tr>
<tr class="separator:a44270f08caaa5aced16a390e07cc34d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5df5f5d1d2702085b6f2cc958fb5e8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9b5df5f5d1d2702085b6f2cc958fb5e8">index_wrap</a> (vector&lt; long &gt; coor) const</td></tr>
<tr class="separator:a9b5df5f5d1d2702085b6f2cc958fb5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f822e981215b18e7ee27df213fce0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad1f822e981215b18e7ee27df213fce0e">coordinates</a> (long i, long &amp;nx, long &amp;ny, long &amp;nz)</td></tr>
<tr class="separator:ad1f822e981215b18e7ee27df213fce0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db6a06e7407d98678c38eb4787cc059"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8db6a06e7407d98678c38eb4787cc059">coordinates</a> (long i, long &amp;nx, long &amp;ny, long &amp;nz, long &amp;nn)</td></tr>
<tr class="separator:a8db6a06e7407d98678c38eb4787cc059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16063cd8e18671cad87e0fa63b5b3858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a16063cd8e18671cad87e0fa63b5b3858">coordinates</a> (long i, long &amp;nc, long &amp;nx, long &amp;ny, long &amp;nz, long &amp;nn)</td></tr>
<tr class="separator:a16063cd8e18671cad87e0fa63b5b3858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676633c5f0620a1a3e65fa427eb513f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a676633c5f0620a1a3e65fa427eb513f4">coordinates</a> (long i)</td></tr>
<tr class="separator:a676633c5f0620a1a3e65fa427eb513f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4430e9d49a8accb2a3063f358b634d64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4430e9d49a8accb2a3063f358b634d64">real_coordinates</a> (long i)</td></tr>
<tr class="separator:a4430e9d49a8accb2a3063f358b634d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5185f2ed4cc550d97a5520280de9b48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5185f2ed4cc550d97a5520280de9b48"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bimage.html#af5185f2ed4cc550d97a5520280de9b48">within_boundaries</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; T &gt; loc)</td></tr>
<tr class="separator:af5185f2ed4cc550d97a5520280de9b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e84daec20bb95e8212c96f06e308de5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3e84daec20bb95e8212c96f06e308de5">within_boundaries</a> (long xx, long yy, long zz)</td></tr>
<tr class="separator:a3e84daec20bb95e8212c96f06e308de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5f4b1aec37e466c44649fe8bd3c573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acc5f4b1aec37e466c44649fe8bd3c573">kernel_low</a> (long i, long k=1)</td></tr>
<tr class="separator:acc5f4b1aec37e466c44649fe8bd3c573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda84951be659557e7466205b3fc7083"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afda84951be659557e7466205b3fc7083">kernel_high</a> (long i, long k=1)</td></tr>
<tr class="separator:afda84951be659557e7466205b3fc7083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41728de6a18ce9515cd35d4b15093d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac41728de6a18ce9515cd35d4b15093d7">kernel_low</a> (long i, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; k)</td></tr>
<tr class="separator:ac41728de6a18ce9515cd35d4b15093d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5b6325e3f6000b183f0fd3e7ae45eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6a5b6325e3f6000b183f0fd3e7ae45eb">kernel_high</a> (long i, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; k)</td></tr>
<tr class="separator:a6a5b6325e3f6000b183f0fd3e7ae45eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b90b99ccc3c50f979020d2f8cf5fb97"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8b90b99ccc3c50f979020d2f8cf5fb97">kernel_min</a> (long idx, long ksize)</td></tr>
<tr class="memdesc:a8b90b99ccc3c50f979020d2f8cf5fb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the highest value in a kernel.  <a href="class_bimage.html#a8b90b99ccc3c50f979020d2f8cf5fb97">More...</a><br /></td></tr>
<tr class="separator:a8b90b99ccc3c50f979020d2f8cf5fb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f902f05afe1d97fd1e90a25aecc4532"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8f902f05afe1d97fd1e90a25aecc4532">kernel_max</a> (long idx, long ksize)</td></tr>
<tr class="memdesc:a8f902f05afe1d97fd1e90a25aecc4532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the highest value in a kernel.  <a href="class_bimage.html#a8f902f05afe1d97fd1e90a25aecc4532">More...</a><br /></td></tr>
<tr class="separator:a8f902f05afe1d97fd1e90a25aecc4532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32603276232d08670b1f5f119d2b2614"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a32603276232d08670b1f5f119d2b2614">kernel_average</a> (long idx, long ksize, double tmin, double tmax)</td></tr>
<tr class="memdesc:a32603276232d08670b1f5f119d2b2614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the highest value in a kernel.  <a href="class_bimage.html#a32603276232d08670b1f5f119d2b2614">More...</a><br /></td></tr>
<tr class="separator:a32603276232d08670b1f5f119d2b2614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07e31eaeb062dd119fd4cfbced83ad7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa07e31eaeb062dd119fd4cfbced83ad7">kernel_neighbor_average</a> (long idx, long ksize)</td></tr>
<tr class="memdesc:aa07e31eaeb062dd119fd4cfbced83ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the highest value in a kernel.  <a href="class_bimage.html#aa07e31eaeb062dd119fd4cfbced83ad7">More...</a><br /></td></tr>
<tr class="separator:aa07e31eaeb062dd119fd4cfbced83ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc44e2b417abe30a685105ab38662a77"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acc44e2b417abe30a685105ab38662a77">kernel_max_neigbor</a> (long idx, long ksize)</td></tr>
<tr class="memdesc:acc44e2b417abe30a685105ab38662a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the highest value in a kernel excluding the central voxel.  <a href="class_bimage.html#acc44e2b417abe30a685105ab38662a77">More...</a><br /></td></tr>
<tr class="separator:acc44e2b417abe30a685105ab38662a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2082eb0532625c9807b85c1052921c6"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae2082eb0532625c9807b85c1052921c6">kernel_max_wrap</a> (long idx, long ksize)</td></tr>
<tr class="memdesc:ae2082eb0532625c9807b85c1052921c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the highest value in a kernel with wrapping.  <a href="class_bimage.html#ae2082eb0532625c9807b85c1052921c6">More...</a><br /></td></tr>
<tr class="separator:ae2082eb0532625c9807b85c1052921c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca34b56eec25e8568c1264ec3c1b2234"><td class="memItemLeft" align="right" valign="top">multimap&lt; double, long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aca34b56eec25e8568c1264ec3c1b2234">kernel_order</a> (long idx, long ksize)</td></tr>
<tr class="memdesc:aca34b56eec25e8568c1264ec3c1b2234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orders the values in a kernel.  <a href="class_bimage.html#aca34b56eec25e8568c1264ec3c1b2234">More...</a><br /></td></tr>
<tr class="separator:aca34b56eec25e8568c1264ec3c1b2234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6517dc1d9d1234580ff7de7cba084325"><td class="memItemLeft" align="right" valign="top">multimap&lt; double, long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6517dc1d9d1234580ff7de7cba084325">kernel_order_neighbors</a> (long idx, long ksize)</td></tr>
<tr class="memdesc:a6517dc1d9d1234580ff7de7cba084325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orders the neigbor values in a kernel.  <a href="class_bimage.html#a6517dc1d9d1234580ff7de7cba084325">More...</a><br /></td></tr>
<tr class="separator:a6517dc1d9d1234580ff7de7cba084325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9875a6beebd6b73bb2c63bb6714b78db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9875a6beebd6b73bb2c63bb6714b78db">page_size</a> ()</td></tr>
<tr class="separator:a9875a6beebd6b73bb2c63bb6714b78db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2a0a9e54ad670ae18e36cf0c2ad397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6a2a0a9e54ad670ae18e36cf0c2ad397">page_size</a> (long nx, long ny, long nz)</td></tr>
<tr class="separator:a6a2a0a9e54ad670ae18e36cf0c2ad397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4598b33854f980fbc035ad2745380e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9f4598b33854f980fbc035ad2745380e">page_size</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; vec)</td></tr>
<tr class="separator:a9f4598b33854f980fbc035ad2745380e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde654e87de96fccb0b430c9ac1c7693"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acde654e87de96fccb0b430c9ac1c7693">page_size</a> (vector&lt; long &gt; vec)</td></tr>
<tr class="separator:acde654e87de96fccb0b430c9ac1c7693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af318fb13b1b1086f6019982d1bed9f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af318fb13b1b1086f6019982d1bed9f88">real_size</a> ()</td></tr>
<tr class="separator:af318fb13b1b1086f6019982d1bed9f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f3b612ae93528dca78ca1641e1f2b6"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac5f3b612ae93528dca78ca1641e1f2b6">images</a> ()</td></tr>
<tr class="separator:ac5f3b612ae93528dca78ca1641e1f2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb76d8399487a3d520985726e25ae3a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aeb76d8399487a3d520985726e25ae3a0">images</a> (long nn)</td></tr>
<tr class="separator:aeb76d8399487a3d520985726e25ae3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38e5d5dbc312e6ee7f56a7c962e62d5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af38e5d5dbc312e6ee7f56a7c962e62d5">voxel_size</a> ()</td></tr>
<tr class="separator:af38e5d5dbc312e6ee7f56a7c962e62d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6d4d42a222c4916583a05e196e0fd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aea6d4d42a222c4916583a05e196e0fd1">sampling</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; u)</td></tr>
<tr class="separator:aea6d4d42a222c4916583a05e196e0fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e1de0aa7f12bb2db5dba29f400cce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af1e1de0aa7f12bb2db5dba29f400cce7">sampling</a> (long nn, double ux, double uy, double uz)</td></tr>
<tr class="separator:af1e1de0aa7f12bb2db5dba29f400cce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcb407c60a020cea5a03823a958f26e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aadcb407c60a020cea5a03823a958f26e">sampling</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; u)</td></tr>
<tr class="separator:aadcb407c60a020cea5a03823a958f26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44553b4ff840993fa3911892949b46f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a44553b4ff840993fa3911892949b46f7">sampling</a> (double ux, double uy, double uz)</td></tr>
<tr class="separator:a44553b4ff840993fa3911892949b46f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af764e499f3c674fe665f78d73da60a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af764e499f3c674fe665f78d73da60a56">sampling</a> (long nn)</td></tr>
<tr class="separator:af764e499f3c674fe665f78d73da60a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbcebef8ab9eeb4069edacbebc8ef2e"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afbbcebef8ab9eeb4069edacbebc8ef2e">sampling</a> ()</td></tr>
<tr class="separator:afbbcebef8ab9eeb4069edacbebc8ef2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced5e9fd821016cc227138bc3dc31c06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aced5e9fd821016cc227138bc3dc31c06">sampling</a> (vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; &gt; sam)</td></tr>
<tr class="separator:aced5e9fd821016cc227138bc3dc31c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33db3f86c385dc4b3d8738d0ad0c59a3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a33db3f86c385dc4b3d8738d0ad0c59a3">minimum</a> ()</td></tr>
<tr class="separator:a33db3f86c385dc4b3d8738d0ad0c59a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56cad9380fe0b08593627bbc7f8d795"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad56cad9380fe0b08593627bbc7f8d795">maximum</a> ()</td></tr>
<tr class="separator:ad56cad9380fe0b08593627bbc7f8d795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de98170ee996fa85f1802250e646a87"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3de98170ee996fa85f1802250e646a87">average</a> ()</td></tr>
<tr class="separator:a3de98170ee996fa85f1802250e646a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad055b167896256474d3cf3cf6bb5c6a4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad055b167896256474d3cf3cf6bb5c6a4">standard_deviation</a> ()</td></tr>
<tr class="separator:ad055b167896256474d3cf3cf6bb5c6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf8a5dccfa06f31723598cfb9f08a22"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4bf8a5dccfa06f31723598cfb9f08a22">variance</a> ()</td></tr>
<tr class="separator:a4bf8a5dccfa06f31723598cfb9f08a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc7ace6085b582d96077515becacf8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9dc7ace6085b582d96077515becacf8f">minimum</a> (double d)</td></tr>
<tr class="separator:a9dc7ace6085b582d96077515becacf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e3f6e31813aa176f38b1a18e2d800c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a28e3f6e31813aa176f38b1a18e2d800c">maximum</a> (double d)</td></tr>
<tr class="separator:a28e3f6e31813aa176f38b1a18e2d800c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95753acb1cb55e4e013e0b4a486a5c01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a95753acb1cb55e4e013e0b4a486a5c01">average</a> (double d)</td></tr>
<tr class="separator:a95753acb1cb55e4e013e0b4a486a5c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70982cf915d12b0d32511c299dd2a003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a70982cf915d12b0d32511c299dd2a003">standard_deviation</a> (double d)</td></tr>
<tr class="separator:a70982cf915d12b0d32511c299dd2a003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfb6a4d3284e436475955bc786ac840"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adbfb6a4d3284e436475955bc786ac840">background</a> (long nn)</td></tr>
<tr class="separator:adbfb6a4d3284e436475955bc786ac840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa931beeddd098f0759308ef1e11c076c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa931beeddd098f0759308ef1e11c076c">background</a> (long nn, double bkg)</td></tr>
<tr class="separator:aa931beeddd098f0759308ef1e11c076c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f89659be398fec283e1c267f33c190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a69f89659be398fec283e1c267f33c190">background</a> (double bkg)</td></tr>
<tr class="separator:a69f89659be398fec283e1c267f33c190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2341b7e858a5c023cd4be98b1ab64773"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2341b7e858a5c023cd4be98b1ab64773">show_image</a> ()</td></tr>
<tr class="separator:a2341b7e858a5c023cd4be98b1ab64773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9391231710bedec11f8bddad05150770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9391231710bedec11f8bddad05150770">show_image</a> (long nn)</td></tr>
<tr class="separator:a9391231710bedec11f8bddad05150770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af903a9c1e50c06aafeb8464426d88a3b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af903a9c1e50c06aafeb8464426d88a3b">show_slice</a> ()</td></tr>
<tr class="separator:af903a9c1e50c06aafeb8464426d88a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29efa892a7c10ec5a88b3f686f97045d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a29efa892a7c10ec5a88b3f686f97045d">show_slice</a> (long nz)</td></tr>
<tr class="separator:a29efa892a7c10ec5a88b3f686f97045d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f10d298cff665dca49330d90e3b2f6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af9f10d298cff665dca49330d90e3b2f6">show_scale</a> ()</td></tr>
<tr class="separator:af9f10d298cff665dca49330d90e3b2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bf22fd62b24a81897e5a69bcd85784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a37bf22fd62b24a81897e5a69bcd85784">show_scale</a> (double scale)</td></tr>
<tr class="separator:a37bf22fd62b24a81897e5a69bcd85784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac845ec573ac4f2e8d2da9806a27423ed"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac845ec573ac4f2e8d2da9806a27423ed">show_minimum</a> ()</td></tr>
<tr class="separator:ac845ec573ac4f2e8d2da9806a27423ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c6ec8dead569920900c0abef394fa3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a15c6ec8dead569920900c0abef394fa3">show_maximum</a> ()</td></tr>
<tr class="separator:a15c6ec8dead569920900c0abef394fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5616baac679d6a1250d86db6ecba273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af5616baac679d6a1250d86db6ecba273">show_minimum</a> (double v)</td></tr>
<tr class="separator:af5616baac679d6a1250d86db6ecba273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db073fe28ad4546b95b2f8993cfc2de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3db073fe28ad4546b95b2f8993cfc2de">show_maximum</a> (double v)</td></tr>
<tr class="separator:a3db073fe28ad4546b95b2f8993cfc2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbc219bc9f6b027e29563617a756bbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a> (double ox, double oy, double oz)</td></tr>
<tr class="separator:abbbc219bc9f6b027e29563617a756bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b38a7622f63be6254386f29aee89d57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0b38a7622f63be6254386f29aee89d57">origin</a> (vector&lt; double &gt; vec)</td></tr>
<tr class="separator:a0b38a7622f63be6254386f29aee89d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1395858573fc8bc13d5d1ab966f09625"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1395858573fc8bc13d5d1ab966f09625">origin</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vec)</td></tr>
<tr class="separator:a1395858573fc8bc13d5d1ab966f09625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e0a30cc0f50a48a0cb5e6301a51ea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a98e0a30cc0f50a48a0cb5e6301a51ea0">origin</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vec)</td></tr>
<tr class="separator:a98e0a30cc0f50a48a0cb5e6301a51ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34a10d6c3278ff9f9aeafd0eef4e55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af34a10d6c3278ff9f9aeafd0eef4e55c">origin</a> (long nn, vector&lt; double &gt; ori)</td></tr>
<tr class="separator:af34a10d6c3278ff9f9aeafd0eef4e55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f0c689d93792813cd398f42b0eeabf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a26f0c689d93792813cd398f42b0eeabf">origin</a> (long nn, double ox, double oy, double oz)</td></tr>
<tr class="separator:a26f0c689d93792813cd398f42b0eeabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b15e01e03d16b34aae26619cf99c61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa2b15e01e03d16b34aae26619cf99c61">default_origin</a> ()</td></tr>
<tr class="separator:aa2b15e01e03d16b34aae26619cf99c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab474ad5f14737ab4931c0171a5d95579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a> (double vx, double vy, double vz, double va)</td></tr>
<tr class="separator:ab474ad5f14737ab4931c0171a5d95579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13be5e642f025a863a9ac1a50d75ab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab13be5e642f025a863a9ac1a50d75ab9">view</a> (<a class="el" href="class_view.html">View</a> vw)</td></tr>
<tr class="separator:ab13be5e642f025a863a9ac1a50d75ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06916652b8d41c5bad363331a0095862"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a06916652b8d41c5bad363331a0095862">space_group</a> ()</td></tr>
<tr class="separator:a06916652b8d41c5bad363331a0095862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad458840e2a3e8969140355c131443cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad458840e2a3e8969140355c131443cad">space_group</a> (unsigned int grp)</td></tr>
<tr class="separator:ad458840e2a3e8969140355c131443cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df5322cc9ecfbd3e5e025316a8995a8"><td class="memItemLeft" align="right" valign="top">string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0df5322cc9ecfbd3e5e025316a8995a8">symmetry</a> ()</td></tr>
<tr class="separator:a0df5322cc9ecfbd3e5e025316a8995a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356f24e44b64a98a02e7e3100e3349a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a356f24e44b64a98a02e7e3100e3349a9">symmetry</a> (string grp)</td></tr>
<tr class="separator:a356f24e44b64a98a02e7e3100e3349a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b435df6c3ad057b73957aad67172ea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3b435df6c3ad057b73957aad67172ea5">unit_cell</a> (<a class="el" href="class_unit_cell.html">UnitCell</a> uc)</td></tr>
<tr class="separator:a3b435df6c3ad057b73957aad67172ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e341bd1fde6068b484a265a546b39a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_cell.html">UnitCell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a58e341bd1fde6068b484a265a546b39a">unit_cell</a> ()</td></tr>
<tr class="separator:a58e341bd1fde6068b484a265a546b39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8043e568eb8132fa03ada899c4ac25fb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8043e568eb8132fa03ada899c4ac25fb">maximum_included_radius</a> ()</td></tr>
<tr class="memdesc:a8043e568eb8132fa03ada899c4ac25fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the radius of the enclosed sphere or circle.  <a href="class_bimage.html#a8043e568eb8132fa03ada899c4ac25fb">More...</a><br /></td></tr>
<tr class="separator:a8043e568eb8132fa03ada899c4ac25fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbdfdfe1d47935021b5868821eb4f89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aacbdfdfe1d47935021b5868821eb4f89">slices_to_images</a> ()</td></tr>
<tr class="memdesc:aacbdfdfe1d47935021b5868821eb4f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the slices in a 3D image into a set of 2D images.  <a href="class_bimage.html#aacbdfdfe1d47935021b5868821eb4f89">More...</a><br /></td></tr>
<tr class="separator:aacbdfdfe1d47935021b5868821eb4f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678987573053e7625c499abc35a7e817"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a678987573053e7625c499abc35a7e817">images_to_slices</a> ()</td></tr>
<tr class="memdesc:a678987573053e7625c499abc35a7e817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the 2D images to slices in a 3D image.  <a href="class_bimage.html#a678987573053e7625c499abc35a7e817">More...</a><br /></td></tr>
<tr class="separator:a678987573053e7625c499abc35a7e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d9c3a12d258a7344378aeb8e56eed6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a30d9c3a12d258a7344378aeb8e56eed6">channels_to_images</a> ()</td></tr>
<tr class="separator:a30d9c3a12d258a7344378aeb8e56eed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb066a1d47146efdaf38df32adb0574a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acb066a1d47146efdaf38df32adb0574a">images_to_channels</a> (long nc, <a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a> ct)</td></tr>
<tr class="separator:acb066a1d47146efdaf38df32adb0574a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff910cb0d91aa55d4ec824e2ecf2b58"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aeff910cb0d91aa55d4ec824e2ecf2b58">set_subset_selection</a> (<a class="el" href="class_bstring.html">Bstring</a> list)</td></tr>
<tr class="memdesc:aeff910cb0d91aa55d4ec824e2ecf2b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the sub-image selections based on a list.  <a href="class_bimage.html#aeff910cb0d91aa55d4ec824e2ecf2b58">More...</a><br /></td></tr>
<tr class="separator:aeff910cb0d91aa55d4ec824e2ecf2b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416e421f9c6a2043c34f223a9df49bef"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a416e421f9c6a2043c34f223a9df49bef">delete_images</a> (<a class="el" href="class_bstring.html">Bstring</a> list, int retain=0)</td></tr>
<tr class="memdesc:a416e421f9c6a2043c34f223a9df49bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retains or deletes sub-images from a multi-image structure.  <a href="class_bimage.html#a416e421f9c6a2043c34f223a9df49bef">More...</a><br /></td></tr>
<tr class="separator:a416e421f9c6a2043c34f223a9df49bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad890b6b933f3f467cf30b787b0d7bbc4"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad890b6b933f3f467cf30b787b0d7bbc4">select_images</a> (<a class="el" href="class_bstring.html">Bstring</a> list)</td></tr>
<tr class="separator:ad890b6b933f3f467cf30b787b0d7bbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa758e00d61b0cf27d877e46a8054d93c"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa758e00d61b0cf27d877e46a8054d93c">read_data</a> (ifstream *fimg, int img_select, int <a class="el" href="rw_d_m_8cpp.html#a7f7475c3cffaf702ef2766959df86817">sb</a>, int vax, long <a class="el" href="class_bimage.html#a130d1713a0034d563b93034b05680768">pad</a>)</td></tr>
<tr class="memdesc:aa758e00d61b0cf27d877e46a8054d93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read image data in a generalized style.  <a href="class_bimage.html#aa758e00d61b0cf27d877e46a8054d93c">More...</a><br /></td></tr>
<tr class="separator:aa758e00d61b0cf27d877e46a8054d93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acc3a092a8e100f263dbf6625863b72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3acc3a092a8e100f263dbf6625863b72">write</a> (<a class="el" href="class_bstring.html">Bstring</a> &amp;fn)</td></tr>
<tr class="separator:a3acc3a092a8e100f263dbf6625863b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d169bcc5a3105a3b258b3d62449618f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5d169bcc5a3105a3b258b3d62449618f">unpack_transform</a> (unsigned char *data, <a class="el" href="_bimage_8h.html#a01e0deba350901d769526633e868806f">FourierType</a> tf)</td></tr>
<tr class="separator:a5d169bcc5a3105a3b258b3d62449618f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac3ddeaa17b3475f3023da92ddbc786"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abac3ddeaa17b3475f3023da92ddbc786">unpack_transform</a> (int img_select, unsigned char *data, <a class="el" href="_bimage_8h.html#a01e0deba350901d769526633e868806f">FourierType</a> tf)</td></tr>
<tr class="separator:abac3ddeaa17b3475f3023da92ddbc786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0d22533e811d43ee246eae948bb5a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3d0d22533e811d43ee246eae948bb5a8">pack_transform</a> (unsigned char *data, <a class="el" href="_bimage_8h.html#a01e0deba350901d769526633e868806f">FourierType</a> tf)</td></tr>
<tr class="separator:a3d0d22533e811d43ee246eae948bb5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6a00076ac48cd4a17d3aa9504ba5ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aac6a00076ac48cd4a17d3aa9504ba5ed">pack_transform</a> (int img_select, unsigned char *data, <a class="el" href="_bimage_8h.html#a01e0deba350901d769526633e868806f">FourierType</a> tf)</td></tr>
<tr class="separator:aac6a00076ac48cd4a17d3aa9504ba5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164807e87f62d5e817344738f69b8c16"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a164807e87f62d5e817344738f69b8c16">statistics</a> ()</td></tr>
<tr class="memdesc:a164807e87f62d5e817344738f69b8c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the statistics for an image.  <a href="class_bimage.html#a164807e87f62d5e817344738f69b8c16">More...</a><br /></td></tr>
<tr class="separator:a164807e87f62d5e817344738f69b8c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d479463c3714a99b670129d62d3fe7a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1d479463c3714a99b670129d62d3fe7a">statistics</a> (long img_num)</td></tr>
<tr class="memdesc:a1d479463c3714a99b670129d62d3fe7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the statistics for a sub-image.  <a href="class_bimage.html#a1d479463c3714a99b670129d62d3fe7a">More...</a><br /></td></tr>
<tr class="separator:a1d479463c3714a99b670129d62d3fe7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4bd3138163814bd4f96e38d8f9d5fd"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0e4bd3138163814bd4f96e38d8f9d5fd">statistics</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, double &amp;regavg, double &amp;regstd)</td></tr>
<tr class="memdesc:a0e4bd3138163814bd4f96e38d8f9d5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the statistics for a region in an image.  <a href="class_bimage.html#a0e4bd3138163814bd4f96e38d8f9d5fd">More...</a><br /></td></tr>
<tr class="separator:a0e4bd3138163814bd4f96e38d8f9d5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870a8b94b0a187b9020eb97a01c98962"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a870a8b94b0a187b9020eb97a01c98962">poisson_statistics_check</a> ()</td></tr>
<tr class="memdesc:a870a8b94b0a187b9020eb97a01c98962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the statistics conform to a Poisson distribution.  <a href="class_bimage.html#a870a8b94b0a187b9020eb97a01c98962">More...</a><br /></td></tr>
<tr class="separator:a870a8b94b0a187b9020eb97a01c98962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce5020e4d29e2e0fc0b3ee369b68bc0"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acce5020e4d29e2e0fc0b3ee369b68bc0">stats_within_radii</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; loc, double rad_min, double rad_max, double &amp;vavg, double &amp;vstd)</td></tr>
<tr class="memdesc:acce5020e4d29e2e0fc0b3ee369b68bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the statistics for an image within given radii from a location.  <a href="class_bimage.html#acce5020e4d29e2e0fc0b3ee369b68bc0">More...</a><br /></td></tr>
<tr class="separator:acce5020e4d29e2e0fc0b3ee369b68bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67e899354c36a6d1a4abdb37136f079"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af67e899354c36a6d1a4abdb37136f079">stats_in_shape</a> (long nn, int type, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; start, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; end, double &amp;vavg, double &amp;vstd)</td></tr>
<tr class="memdesc:af67e899354c36a6d1a4abdb37136f079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the statistics for an image within the given box.  <a href="class_bimage.html#af67e899354c36a6d1a4abdb37136f079">More...</a><br /></td></tr>
<tr class="separator:af67e899354c36a6d1a4abdb37136f079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4524e0f31e3c2c83e3d579cb199aa03f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4524e0f31e3c2c83e3d579cb199aa03f">stats_in_poly</a> (long nn, int nvert, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; *poly, double &amp;vavg, double &amp;vstd)</td></tr>
<tr class="memdesc:a4524e0f31e3c2c83e3d579cb199aa03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the statistics for an image within the given polyhedron.  <a href="class_bimage.html#a4524e0f31e3c2c83e3d579cb199aa03f">More...</a><br /></td></tr>
<tr class="separator:a4524e0f31e3c2c83e3d579cb199aa03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e146a61ad251fc4e5562495f6021aa"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac6e146a61ad251fc4e5562495f6021aa">stats_in_mask</a> (long nn, <a class="el" href="class_bimage.html">Bimage</a> *pmask)</td></tr>
<tr class="memdesc:ac6e146a61ad251fc4e5562495f6021aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the statistics for an image for each level in a mask.  <a href="class_bimage.html#ac6e146a61ad251fc4e5562495f6021aa">More...</a><br /></td></tr>
<tr class="separator:ac6e146a61ad251fc4e5562495f6021aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dff1ffc38196ca423bf5f842fc3c1e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9dff1ffc38196ca423bf5f842fc3c1e6">variance</a> (long kernel_size, int flag=0)</td></tr>
<tr class="memdesc:a9dff1ffc38196ca423bf5f842fc3c1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the local variance within the given kernel.  <a href="class_bimage.html#a9dff1ffc38196ca423bf5f842fc3c1e6">More...</a><br /></td></tr>
<tr class="separator:a9dff1ffc38196ca423bf5f842fc3c1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1e1cdce8cdbf4f060da4c6bb22df70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3f1e1cdce8cdbf4f060da4c6bb22df70">variance</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; kernel_size, int flag=0)</td></tr>
<tr class="memdesc:a3f1e1cdce8cdbf4f060da4c6bb22df70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the local variance within the given kernel.  <a href="class_bimage.html#a3f1e1cdce8cdbf4f060da4c6bb22df70">More...</a><br /></td></tr>
<tr class="separator:a3f1e1cdce8cdbf4f060da4c6bb22df70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9022fbf57ed364f1c2f52b71f7af4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afc9022fbf57ed364f1c2f52b71f7af4d">variance</a> (<a class="el" href="class_bimage.html">Bimage</a> *pweight)</td></tr>
<tr class="memdesc:afc9022fbf57ed364f1c2f52b71f7af4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the local variance weighed with the given image.  <a href="class_bimage.html#afc9022fbf57ed364f1c2f52b71f7af4d">More...</a><br /></td></tr>
<tr class="separator:afc9022fbf57ed364f1c2f52b71f7af4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad034e4aef862674587ca3e5f83d50a06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad034e4aef862674587ca3e5f83d50a06">information</a> ()</td></tr>
<tr class="memdesc:ad034e4aef862674587ca3e5f83d50a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out header information for an image.  <a href="class_bimage.html#ad034e4aef862674587ca3e5f83d50a06">More...</a><br /></td></tr>
<tr class="separator:ad034e4aef862674587ca3e5f83d50a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63bc84ebfa0da20f4783d5406fb0ada"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac63bc84ebfa0da20f4783d5406fb0ada">subimage_information</a> ()</td></tr>
<tr class="memdesc:ac63bc84ebfa0da20f4783d5406fb0ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out header information for all sub-images.  <a href="class_bimage.html#ac63bc84ebfa0da20f4783d5406fb0ada">More...</a><br /></td></tr>
<tr class="separator:ac63bc84ebfa0da20f4783d5406fb0ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3d8867cba26161c0d95971a8714496"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4f3d8867cba26161c0d95971a8714496">moments</a> (long max_order)</td></tr>
<tr class="memdesc:a4f3d8867cba26161c0d95971a8714496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out moments for all sub-images.  <a href="class_bimage.html#a4f3d8867cba26161c0d95971a8714496">More...</a><br /></td></tr>
<tr class="separator:a4f3d8867cba26161c0d95971a8714496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fae7890cf81c93fa08a4234d426e72d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0fae7890cf81c93fa08a4234d426e72d">moments</a> (long max_order, long nn)</td></tr>
<tr class="memdesc:a0fae7890cf81c93fa08a4234d426e72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out moments for one sub-image.  <a href="class_bimage.html#a0fae7890cf81c93fa08a4234d426e72d">More...</a><br /></td></tr>
<tr class="separator:a0fae7890cf81c93fa08a4234d426e72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b30eb05be0db04eb94f479bbd7703b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a26b30eb05be0db04eb94f479bbd7703b">get</a> (<a class="el" href="class_bstring.html">Bstring</a> tag)</td></tr>
<tr class="memdesc:a26b30eb05be0db04eb94f479bbd7703b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out header information associated with a tag string.  <a href="class_bimage.html#a26b30eb05be0db04eb94f479bbd7703b">More...</a><br /></td></tr>
<tr class="separator:a26b30eb05be0db04eb94f479bbd7703b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d95c9ec5072c183f3a8f46856ad3c21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5d95c9ec5072c183f3a8f46856ad3c21">copy</a> ()</td></tr>
<tr class="memdesc:a5d95c9ec5072c183f3a8f46856ad3c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the header information and data of an image into a new image structure.  <a href="class_bimage.html#a5d95c9ec5072c183f3a8f46856ad3c21">More...</a><br /></td></tr>
<tr class="separator:a5d95c9ec5072c183f3a8f46856ad3c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae857443aef660818821614dbf350a334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae857443aef660818821614dbf350a334">copy</a> (long nu_nimg)</td></tr>
<tr class="memdesc:ae857443aef660818821614dbf350a334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the header information and data of an image into a new image structure.  <a href="class_bimage.html#ae857443aef660818821614dbf350a334">More...</a><br /></td></tr>
<tr class="separator:ae857443aef660818821614dbf350a334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19b4936a6ffeab24d4522a005e06400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae19b4936a6ffeab24d4522a005e06400">copy_header</a> ()</td></tr>
<tr class="separator:ae19b4936a6ffeab24d4522a005e06400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f33c5b1b205f62ce1bd85fd5f9fee3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6f33c5b1b205f62ce1bd85fd5f9fee3a">copy_header</a> (long nu_nimg)</td></tr>
<tr class="memdesc:a6f33c5b1b205f62ce1bd85fd5f9fee3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an image structure into a new one.  <a href="class_bimage.html#a6f33c5b1b205f62ce1bd85fd5f9fee3a">More...</a><br /></td></tr>
<tr class="separator:a6f33c5b1b205f62ce1bd85fd5f9fee3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad694d6b8be2285e48d93cf19933448bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad694d6b8be2285e48d93cf19933448bc">extract</a> (long nn)</td></tr>
<tr class="memdesc:ad694d6b8be2285e48d93cf19933448bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts one sub-image into new image structure.  <a href="class_bimage.html#ad694d6b8be2285e48d93cf19933448bc">More...</a><br /></td></tr>
<tr class="separator:ad694d6b8be2285e48d93cf19933448bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2703b464380e42f9a66433f04769da33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2703b464380e42f9a66433f04769da33">extract</a> (long n1, long n2)</td></tr>
<tr class="memdesc:a2703b464380e42f9a66433f04769da33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a set of sub-images into new image structure.  <a href="class_bimage.html#a2703b464380e42f9a66433f04769da33">More...</a><br /></td></tr>
<tr class="separator:a2703b464380e42f9a66433f04769da33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75becde8dfa02b97efe042a439ac4766"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a75becde8dfa02b97efe042a439ac4766">extract</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; coords, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; <a class="el" href="class_bimage.html#aa73f430809a61cffcf9313c60a417090">size</a>, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a75becde8dfa02b97efe042a439ac4766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a region of one sub-image into new image structure.  <a href="class_bimage.html#a75becde8dfa02b97efe042a439ac4766">More...</a><br /></td></tr>
<tr class="separator:a75becde8dfa02b97efe042a439ac4766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad202325a6b016bda9d3356c7a078fb7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad202325a6b016bda9d3356c7a078fb7f">extract</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; loc, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; <a class="el" href="class_bimage.html#aa73f430809a61cffcf9313c60a417090">size</a>, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>)</td></tr>
<tr class="separator:ad202325a6b016bda9d3356c7a078fb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1525f8c9e7b34b3c620f75ec01983bcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1525f8c9e7b34b3c620f75ec01983bcc">extract</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; loc, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; <a class="el" href="class_bimage.html#aa73f430809a61cffcf9313c60a417090">size</a>, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>, <a class="el" href="class_matrix3.html">Matrix3</a> mat)</td></tr>
<tr class="memdesc:a1525f8c9e7b34b3c620f75ec01983bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a region of one sub-image into new image structure.  <a href="class_bimage.html#a1525f8c9e7b34b3c620f75ec01983bcc">More...</a><br /></td></tr>
<tr class="separator:a1525f8c9e7b34b3c620f75ec01983bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3370c44752d159fc360769c37be851"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acb3370c44752d159fc360769c37be851">extract</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; loc, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; <a class="el" href="class_bimage.html#aa73f430809a61cffcf9313c60a417090">size</a>, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>, <a class="el" href="class_view.html">View</a> <a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>)</td></tr>
<tr class="separator:acb3370c44752d159fc360769c37be851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf79966f25b70ab6cf0d07445709c47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1bf79966f25b70ab6cf0d07445709c47">extract_wrap</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; loc, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; <a class="el" href="class_bimage.html#aa73f430809a61cffcf9313c60a417090">size</a>, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>, <a class="el" href="class_matrix3.html">Matrix3</a> mat)</td></tr>
<tr class="memdesc:a1bf79966f25b70ab6cf0d07445709c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a region of one sub-image into new image structure with wrapping.  <a href="class_bimage.html#a1bf79966f25b70ab6cf0d07445709c47">More...</a><br /></td></tr>
<tr class="separator:a1bf79966f25b70ab6cf0d07445709c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08d645ee9fca25c5968cf24383809b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af08d645ee9fca25c5968cf24383809b7">extract_wrap</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; <a class="el" href="class_bimage.html#aa73f430809a61cffcf9313c60a417090">size</a>, <a class="el" href="class_matrix3.html">Matrix3</a> mat)</td></tr>
<tr class="separator:af08d645ee9fca25c5968cf24383809b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a878694c06b1bd8f60792138f69ff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a25a878694c06b1bd8f60792138f69ff1">extract_shell</a> (long nn, double minrad, double maxrad)</td></tr>
<tr class="memdesc:a25a878694c06b1bd8f60792138f69ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a shell from an image into a new image.  <a href="class_bimage.html#a25a878694c06b1bd8f60792138f69ff1">More...</a><br /></td></tr>
<tr class="separator:a25a878694c06b1bd8f60792138f69ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ef4e4f4bf08e4282763b429c2ff060"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad8ef4e4f4bf08e4282763b429c2ff060">tile_coordinates</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &amp;start, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &amp;region, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &amp;tile_size, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &amp;step_size, int exceed)</td></tr>
<tr class="memdesc:ad8ef4e4f4bf08e4282763b429c2ff060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of tile coordinates for an image.  <a href="class_bimage.html#ad8ef4e4f4bf08e4282763b429c2ff060">More...</a><br /></td></tr>
<tr class="separator:ad8ef4e4f4bf08e4282763b429c2ff060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8ec73b38f79aca1d59c87ed1a7d27c"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6c8ec73b38f79aca1d59c87ed1a7d27c">tile_coordinates</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; tile_size, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &amp;step_size)</td></tr>
<tr class="memdesc:a6c8ec73b38f79aca1d59c87ed1a7d27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of tile coordinates to fit in the image dimensions.  <a href="class_bimage.html#a6c8ec73b38f79aca1d59c87ed1a7d27c">More...</a><br /></td></tr>
<tr class="separator:a6c8ec73b38f79aca1d59c87ed1a7d27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb5f538e628fb40542402e539b3d2c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7bb5f538e628fb40542402e539b3d2c0">extract_tiles</a> (long nn, vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &gt; &amp;coords, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; tile_size)</td></tr>
<tr class="memdesc:a7bb5f538e628fb40542402e539b3d2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a set of tiles at specified positions from an image into a new image.  <a href="class_bimage.html#a7bb5f538e628fb40542402e539b3d2c0">More...</a><br /></td></tr>
<tr class="separator:a7bb5f538e628fb40542402e539b3d2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b36947546650566f8889ca3e5eb0e46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3b36947546650566f8889ca3e5eb0e46">extract_tiles</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; start, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; region, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; tile_size, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; step_size, int exceed)</td></tr>
<tr class="memdesc:a3b36947546650566f8889ca3e5eb0e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a set of tiles from an image into a new image.  <a href="class_bimage.html#a3b36947546650566f8889ca3e5eb0e46">More...</a><br /></td></tr>
<tr class="separator:a3b36947546650566f8889ca3e5eb0e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74c7e919d334bed98157c96e68b5f72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af74c7e919d334bed98157c96e68b5f72">extract_tiles</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; tile_size, double fraction=0.2)</td></tr>
<tr class="memdesc:af74c7e919d334bed98157c96e68b5f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a set of tiles from an image into a new image.  <a href="class_bimage.html#af74c7e919d334bed98157c96e68b5f72">More...</a><br /></td></tr>
<tr class="separator:af74c7e919d334bed98157c96e68b5f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1764bd1bafd971269b576790b810767c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1764bd1bafd971269b576790b810767c">extract_tile_stack</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; coords, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; tile_size, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a1764bd1bafd971269b576790b810767c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a stack of tiles at a specified position from an image into a new image.  <a href="class_bimage.html#a1764bd1bafd971269b576790b810767c">More...</a><br /></td></tr>
<tr class="separator:a1764bd1bafd971269b576790b810767c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b708ae8cfb17999a439c1f5458dba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a97b708ae8cfb17999a439c1f5458dba9">extract_tile_stacks</a> (vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &gt; &amp;coords, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; tile_size)</td></tr>
<tr class="memdesc:a97b708ae8cfb17999a439c1f5458dba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts stacks of tiles at a specified positions from an image into an array of new images.  <a href="class_bimage.html#a97b708ae8cfb17999a439c1f5458dba9">More...</a><br /></td></tr>
<tr class="separator:a97b708ae8cfb17999a439c1f5458dba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892f52f8f20dc7804f1ad1b2c9680d36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a892f52f8f20dc7804f1ad1b2c9680d36">extract_line</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; start, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; end, long width)</td></tr>
<tr class="memdesc:a892f52f8f20dc7804f1ad1b2c9680d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a line from an image into a new image.  <a href="class_bimage.html#a892f52f8f20dc7804f1ad1b2c9680d36">More...</a><br /></td></tr>
<tr class="separator:a892f52f8f20dc7804f1ad1b2c9680d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d370c2c5b46f2e3efa77adf4ff50f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a83d370c2c5b46f2e3efa77adf4ff50f0">extract_tetrahedron</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; *tet, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a83d370c2c5b46f2e3efa77adf4ff50f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a tetrahedral part of the image.  <a href="class_bimage.html#a83d370c2c5b46f2e3efa77adf4ff50f0">More...</a><br /></td></tr>
<tr class="separator:a83d370c2c5b46f2e3efa77adf4ff50f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355e6600b5f741910cb5ddfbd3b561f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a355e6600b5f741910cb5ddfbd3b561f6">orthogonal_slices</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; voxel, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; ext_size)</td></tr>
<tr class="memdesc:a355e6600b5f741910cb5ddfbd3b561f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts orthogonal views around a voxel.  <a href="class_bimage.html#a355e6600b5f741910cb5ddfbd3b561f6">More...</a><br /></td></tr>
<tr class="separator:a355e6600b5f741910cb5ddfbd3b561f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a6e4158e822bc0580169327cd67b0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a80a6e4158e822bc0580169327cd67b0c">extract_show_chunk</a> (<a class="el" href="class_bimage.html">Bimage</a> *pshow, int aflag, long i, long len)</td></tr>
<tr class="separator:a80a6e4158e822bc0580169327cd67b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba5d23997bcbed499347362560988da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6ba5d23997bcbed499347362560988da">extract_show</a> (int aflag)</td></tr>
<tr class="memdesc:a6ba5d23997bcbed499347362560988da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a slice from an image to a 2D plane for display.  <a href="class_bimage.html#a6ba5d23997bcbed499347362560988da">More...</a><br /></td></tr>
<tr class="separator:a6ba5d23997bcbed499347362560988da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2528c48b7c82f19008a343ccfc42c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab2528c48b7c82f19008a343ccfc42c7d">extract_magnify</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; <a class="el" href="class_bimage.html#a5f9345465a753a4ace75a2b1d7c379ba">center</a>, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; ext_size, double scale)</td></tr>
<tr class="memdesc:ab2528c48b7c82f19008a343ccfc42c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a region from an image to magnify.  <a href="class_bimage.html#ab2528c48b7c82f19008a343ccfc42c7d">More...</a><br /></td></tr>
<tr class="separator:ab2528c48b7c82f19008a343ccfc42c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fb7c035e1a7dab3a3b1aa92ee821f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a89fb7c035e1a7dab3a3b1aa92ee821f8">extract_slice</a> (long nz)</td></tr>
<tr class="memdesc:a89fb7c035e1a7dab3a3b1aa92ee821f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a given slice or slices from an image.  <a href="class_bimage.html#a89fb7c035e1a7dab3a3b1aa92ee821f8">More...</a><br /></td></tr>
<tr class="separator:a89fb7c035e1a7dab3a3b1aa92ee821f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954793f4d58397221196ccb9c2ef1a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a954793f4d58397221196ccb9c2ef1a67">extract_filament</a> (long img_num, double width, int axis, long nspline, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; *spline)</td></tr>
<tr class="memdesc:a954793f4d58397221196ccb9c2ef1a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a filament defined by a series of coordinates.  <a href="class_bimage.html#a954793f4d58397221196ccb9c2ef1a67">More...</a><br /></td></tr>
<tr class="separator:a954793f4d58397221196ccb9c2ef1a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e690ba847608adfe186083d63e0a8f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3e690ba847608adfe186083d63e0a8f8">replace</a> (<a class="el" href="class_bimage.html">Bimage</a> *img)</td></tr>
<tr class="memdesc:a3e690ba847608adfe186083d63e0a8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the data with that from the given image.  <a href="class_bimage.html#a3e690ba847608adfe186083d63e0a8f8">More...</a><br /></td></tr>
<tr class="separator:a3e690ba847608adfe186083d63e0a8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42023ed856fd661419b1d2ac9d4f7508"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a42023ed856fd661419b1d2ac9d4f7508">replace</a> (long nn, <a class="el" href="class_bimage.html">Bimage</a> *img, long nr=0)</td></tr>
<tr class="memdesc:a42023ed856fd661419b1d2ac9d4f7508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces one sub-image in an image structure.  <a href="class_bimage.html#a42023ed856fd661419b1d2ac9d4f7508">More...</a><br /></td></tr>
<tr class="separator:a42023ed856fd661419b1d2ac9d4f7508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9898fd3b514d2f774ddd72c2673450a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9898fd3b514d2f774ddd72c2673450a0">replace</a> (long nn, <a class="el" href="class_bimage.html">Bimage</a> *img, long nr, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>)</td></tr>
<tr class="memdesc:a9898fd3b514d2f774ddd72c2673450a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces one sub-image in an image structure.  <a href="class_bimage.html#a9898fd3b514d2f774ddd72c2673450a0">More...</a><br /></td></tr>
<tr class="separator:a9898fd3b514d2f774ddd72c2673450a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8db25e2cb2d3057af80e8469cd3cb77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab8db25e2cb2d3057af80e8469cd3cb77">clear</a> ()</td></tr>
<tr class="separator:ab8db25e2cb2d3057af80e8469cd3cb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c23502ddd87cbb33e533a97282effb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a> (double v)</td></tr>
<tr class="separator:a31c23502ddd87cbb33e533a97282effb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df18d85c91d522f3f3c2d8ea56b1850"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0df18d85c91d522f3f3c2d8ea56b1850">density</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; coord, double radius, double &amp;sigma)</td></tr>
<tr class="memdesc:a0df18d85c91d522f3f3c2d8ea56b1850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the density in a sphere around a coordinate in an image.  <a href="class_bimage.html#a0df18d85c91d522f3f3c2d8ea56b1850">More...</a><br /></td></tr>
<tr class="separator:a0df18d85c91d522f3f3c2d8ea56b1850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab423ab772f8f5370378c3ca39d89ffaf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab423ab772f8f5370378c3ca39d89ffaf">density</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; coord, double radius)</td></tr>
<tr class="separator:ab423ab772f8f5370378c3ca39d89ffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c0e1a29c59f66cea84af7fbc18fd14"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a53c0e1a29c59f66cea84af7fbc18fd14">relative_density</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask)</td></tr>
<tr class="memdesc:a53c0e1a29c59f66cea84af7fbc18fd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the relative density in a region defined by a mask.  <a href="class_bimage.html#a53c0e1a29c59f66cea84af7fbc18fd14">More...</a><br /></td></tr>
<tr class="separator:a53c0e1a29c59f66cea84af7fbc18fd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59438cff519b5ec327b7ef909e761984"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a59438cff519b5ec327b7ef909e761984">invert</a> ()</td></tr>
<tr class="memdesc:a59438cff519b5ec327b7ef909e761984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the data in the image.  <a href="class_bimage.html#a59438cff519b5ec327b7ef909e761984">More...</a><br /></td></tr>
<tr class="separator:a59438cff519b5ec327b7ef909e761984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46db3bd25b8e4a6477a4ef686604ceab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a46db3bd25b8e4a6477a4ef686604ceab">reslice</a> (const char *order)</td></tr>
<tr class="separator:a46db3bd25b8e4a6477a4ef686604ceab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ed5dc6affb2312432591d328c6d27b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad5ed5dc6affb2312432591d328c6d27b">reslice</a> (<a class="el" href="class_bstring.html">Bstring</a> order)</td></tr>
<tr class="memdesc:ad5ed5dc6affb2312432591d328c6d27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches axes of an image.  <a href="class_bimage.html#ad5ed5dc6affb2312432591d328c6d27b">More...</a><br /></td></tr>
<tr class="separator:ad5ed5dc6affb2312432591d328c6d27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6829f765ef3e6b7cfd9b2e542e96e68f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6829f765ef3e6b7cfd9b2e542e96e68f">absolute</a> ()</td></tr>
<tr class="memdesc:a6829f765ef3e6b7cfd9b2e542e96e68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts to absolute values.  <a href="class_bimage.html#a6829f765ef3e6b7cfd9b2e542e96e68f">More...</a><br /></td></tr>
<tr class="separator:a6829f765ef3e6b7cfd9b2e542e96e68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba22e1bb37a9565161d49c7908f2fce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aba22e1bb37a9565161d49c7908f2fce7">add</a> (double v)</td></tr>
<tr class="memdesc:aba22e1bb37a9565161d49c7908f2fce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant value to an image.  <a href="class_bimage.html#aba22e1bb37a9565161d49c7908f2fce7">More...</a><br /></td></tr>
<tr class="separator:aba22e1bb37a9565161d49c7908f2fce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f53c71f2d4540295de067659d4d3e26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8f53c71f2d4540295de067659d4d3e26">multiply</a> (double v)</td></tr>
<tr class="memdesc:a8f53c71f2d4540295de067659d4d3e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies an image with a constant value.  <a href="class_bimage.html#a8f53c71f2d4540295de067659d4d3e26">More...</a><br /></td></tr>
<tr class="separator:a8f53c71f2d4540295de067659d4d3e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8ca57c4383b415ab312f8be4fcf309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aba8ca57c4383b415ab312f8be4fcf309">multiply</a> (long nn, double v)</td></tr>
<tr class="memdesc:aba8ca57c4383b415ab312f8be4fcf309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a sub-image with a constant value.  <a href="class_bimage.html#aba8ca57c4383b415ab312f8be4fcf309">More...</a><br /></td></tr>
<tr class="separator:aba8ca57c4383b415ab312f8be4fcf309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8d4e28cfbfe3c22d340b7e1d20fb77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afe8d4e28cfbfe3c22d340b7e1d20fb77">power</a> (double v)</td></tr>
<tr class="memdesc:afe8d4e28cfbfe3c22d340b7e1d20fb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the power of an image.  <a href="class_bimage.html#afe8d4e28cfbfe3c22d340b7e1d20fb77">More...</a><br /></td></tr>
<tr class="separator:afe8d4e28cfbfe3c22d340b7e1d20fb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca83b7f355394a839d387473c46cb804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aca83b7f355394a839d387473c46cb804">sum_images</a> ()</td></tr>
<tr class="memdesc:aca83b7f355394a839d387473c46cb804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all sub-images.  <a href="class_bimage.html#aca83b7f355394a839d387473c46cb804">More...</a><br /></td></tr>
<tr class="separator:aca83b7f355394a839d387473c46cb804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a758b80d8b664281665fd2a22183024"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7a758b80d8b664281665fd2a22183024">average_images</a> ()</td></tr>
<tr class="separator:a7a758b80d8b664281665fd2a22183024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e86e673f3794fc9f2ec5c04540c2a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a34e86e673f3794fc9f2ec5c04540c2a4">average_images</a> (bool sd)</td></tr>
<tr class="memdesc:a34e86e673f3794fc9f2ec5c04540c2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Averages all sub-images and optionally calculates standard deviation image.  <a href="class_bimage.html#a34e86e673f3794fc9f2ec5c04540c2a4">More...</a><br /></td></tr>
<tr class="separator:a34e86e673f3794fc9f2ec5c04540c2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3633f91294bf9cd72154da5aa885b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abc3633f91294bf9cd72154da5aa885b4">moving_sum</a> (long window, long step=1, int flag=0)</td></tr>
<tr class="memdesc:abc3633f91294bf9cd72154da5aa885b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a moving sum of the sub-images.  <a href="class_bimage.html#abc3633f91294bf9cd72154da5aa885b4">More...</a><br /></td></tr>
<tr class="separator:abc3633f91294bf9cd72154da5aa885b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9881cc5ba252117b04982537fcade7ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9881cc5ba252117b04982537fcade7ec">progressive_sum</a> ()</td></tr>
<tr class="memdesc:a9881cc5ba252117b04982537fcade7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Progressive sum of the sub-images.  <a href="class_bimage.html#a9881cc5ba252117b04982537fcade7ec">More...</a><br /></td></tr>
<tr class="separator:a9881cc5ba252117b04982537fcade7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caf0fd81251dd1d57aa3fb336000591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3caf0fd81251dd1d57aa3fb336000591">add</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:a3caf0fd81251dd1d57aa3fb336000591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds another image to an image.  <a href="class_bimage.html#a3caf0fd81251dd1d57aa3fb336000591">More...</a><br /></td></tr>
<tr class="separator:a3caf0fd81251dd1d57aa3fb336000591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172ef81a15fd705cd86f2479d4ab307c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a172ef81a15fd705cd86f2479d4ab307c">add</a> (long nn, <a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:a172ef81a15fd705cd86f2479d4ab307c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds another image to a sub-image.  <a href="class_bimage.html#a172ef81a15fd705cd86f2479d4ab307c">More...</a><br /></td></tr>
<tr class="separator:a172ef81a15fd705cd86f2479d4ab307c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7349e99d1a9375c118ca86b69d387f0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7349e99d1a9375c118ca86b69d387f0f">subtract</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:a7349e99d1a9375c118ca86b69d387f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts another image from an image.  <a href="class_bimage.html#a7349e99d1a9375c118ca86b69d387f0f">More...</a><br /></td></tr>
<tr class="separator:a7349e99d1a9375c118ca86b69d387f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d255c2a8212c0d798c04135f95d8ab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1d255c2a8212c0d798c04135f95d8ab7">add</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double scale, double <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>)</td></tr>
<tr class="memdesc:a1d255c2a8212c0d798c04135f95d8ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds another image to an image.  <a href="class_bimage.html#a1d255c2a8212c0d798c04135f95d8ab7">More...</a><br /></td></tr>
<tr class="separator:a1d255c2a8212c0d798c04135f95d8ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7eff4366c6603d8c6f95960e4883cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4f7eff4366c6603d8c6f95960e4883cf">add</a> (long nn, <a class="el" href="class_bimage.html">Bimage</a> *p, double scale, double <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>)</td></tr>
<tr class="memdesc:a4f7eff4366c6603d8c6f95960e4883cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds another image to an image.  <a href="class_bimage.html#a4f7eff4366c6603d8c6f95960e4883cf">More...</a><br /></td></tr>
<tr class="separator:a4f7eff4366c6603d8c6f95960e4883cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06577441795cc23f8f149d453167f4f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a06577441795cc23f8f149d453167f4f4">multiply</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double scale, double <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>=0)</td></tr>
<tr class="memdesc:a06577441795cc23f8f149d453167f4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies an image with another image.  <a href="class_bimage.html#a06577441795cc23f8f149d453167f4f4">More...</a><br /></td></tr>
<tr class="separator:a06577441795cc23f8f149d453167f4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62301788f8dd6bb54f498908100c6144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a62301788f8dd6bb54f498908100c6144">multiply</a> (long nn, <a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:a62301788f8dd6bb54f498908100c6144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a sub-image with another image.  <a href="class_bimage.html#a62301788f8dd6bb54f498908100c6144">More...</a><br /></td></tr>
<tr class="separator:a62301788f8dd6bb54f498908100c6144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546a12884111b3559dd39393b33344e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a546a12884111b3559dd39393b33344e7">multiply</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:a546a12884111b3559dd39393b33344e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all sub-images with the first sub-image of the other image.  <a href="class_bimage.html#a546a12884111b3559dd39393b33344e7">More...</a><br /></td></tr>
<tr class="separator:a546a12884111b3559dd39393b33344e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fcf4e33e69ef544b67855d7a64b8ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a34fcf4e33e69ef544b67855d7a64b8ea">divide</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double scale=1, double <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>=0)</td></tr>
<tr class="memdesc:a34fcf4e33e69ef544b67855d7a64b8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the first image by the second.  <a href="class_bimage.html#a34fcf4e33e69ef544b67855d7a64b8ea">More...</a><br /></td></tr>
<tr class="separator:a34fcf4e33e69ef544b67855d7a64b8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc8a26a38fe1b41c707793d44bb37de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afcc8a26a38fe1b41c707793d44bb37de">divide_one</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double scale=1, double <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>=0)</td></tr>
<tr class="memdesc:afcc8a26a38fe1b41c707793d44bb37de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the first image by the first sub-image of the second.  <a href="class_bimage.html#afcc8a26a38fe1b41c707793d44bb37de">More...</a><br /></td></tr>
<tr class="separator:afcc8a26a38fe1b41c707793d44bb37de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e17a1198d60941bc2a64a563d99622"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a75e17a1198d60941bc2a64a563d99622">inverse</a> (double minval=0)</td></tr>
<tr class="memdesc:a75e17a1198d60941bc2a64a563d99622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of the image.  <a href="class_bimage.html#a75e17a1198d60941bc2a64a563d99622">More...</a><br /></td></tr>
<tr class="separator:a75e17a1198d60941bc2a64a563d99622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6dd952940fd6084b5e8a4674e708b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aee6dd952940fd6084b5e8a4674e708b2">largest</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:aee6dd952940fd6084b5e8a4674e708b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the largest of each pixel from two images.  <a href="class_bimage.html#aee6dd952940fd6084b5e8a4674e708b2">More...</a><br /></td></tr>
<tr class="separator:aee6dd952940fd6084b5e8a4674e708b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fd506ba5395c911834305a76c3fe66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa7fd506ba5395c911834305a76c3fe66">smallest</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:aa7fd506ba5395c911834305a76c3fe66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the smallest of each pixel from two images.  <a href="class_bimage.html#aa7fd506ba5395c911834305a76c3fe66">More...</a><br /></td></tr>
<tr class="separator:aa7fd506ba5395c911834305a76c3fe66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad018ca33d662271a36e48fbf559240d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aad018ca33d662271a36e48fbf559240d">operator+</a> (<a class="el" href="class_bimage.html">Bimage</a> &amp;p)</td></tr>
<tr class="memdesc:aad018ca33d662271a36e48fbf559240d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two images together, adjusting for size difference.  <a href="class_bimage.html#aad018ca33d662271a36e48fbf559240d">More...</a><br /></td></tr>
<tr class="separator:aad018ca33d662271a36e48fbf559240d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43916985ee29b7482e3d0bbcd97b68b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a43916985ee29b7482e3d0bbcd97b68b7">plot</a> ()</td></tr>
<tr class="memdesc:a43916985ee29b7482e3d0bbcd97b68b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a one-dimensional image into a plot.  <a href="class_bimage.html#a43916985ee29b7482e3d0bbcd97b68b7">More...</a><br /></td></tr>
<tr class="separator:a43916985ee29b7482e3d0bbcd97b68b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c2b8af69df7f99b805f0e0a226e59d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa3c2b8af69df7f99b805f0e0a226e59d">vector_to_simple</a> ()</td></tr>
<tr class="memdesc:aa3c2b8af69df7f99b805f0e0a226e59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector image is converted to a simple image.  <a href="class_bimage.html#aa3c2b8af69df7f99b805f0e0a226e59d">More...</a><br /></td></tr>
<tr class="separator:aa3c2b8af69df7f99b805f0e0a226e59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48263b31ee57d8c986bb1256413b71bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a48263b31ee57d8c986bb1256413b71bd">sum</a> (long m, <a class="el" href="class_bimage.html">Bimage</a> **p)</td></tr>
<tr class="memdesc:a48263b31ee57d8c986bb1256413b71bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums an array of images with their FOM blocks.  <a href="class_bimage.html#a48263b31ee57d8c986bb1256413b71bd">More...</a><br /></td></tr>
<tr class="separator:a48263b31ee57d8c986bb1256413b71bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8555d13111d99d6736cafc5e9d36232"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac8555d13111d99d6736cafc5e9d36232">catenate</a> (long m, <a class="el" href="class_bimage.html">Bimage</a> **p)</td></tr>
<tr class="memdesc:ac8555d13111d99d6736cafc5e9d36232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Catenates an array of images of the same size into a multi-image structure.  <a href="class_bimage.html#ac8555d13111d99d6736cafc5e9d36232">More...</a><br /></td></tr>
<tr class="separator:ac8555d13111d99d6736cafc5e9d36232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460f2d1622dafdaeb8fc1d61dd0ec462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a460f2d1622dafdaeb8fc1d61dd0ec462">blend</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, long number)</td></tr>
<tr class="memdesc:a460f2d1622dafdaeb8fc1d61dd0ec462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blends the two images, creating a new set of sub-images.  <a href="class_bimage.html#a460f2d1622dafdaeb8fc1d61dd0ec462">More...</a><br /></td></tr>
<tr class="separator:a460f2d1622dafdaeb8fc1d61dd0ec462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d647152e38cede66380147e1bcf1ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af1d647152e38cede66380147e1bcf1ca">place</a> (long nn, <a class="el" href="class_bimage.html">Bimage</a> *p, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; loc, double radius=0, double scale=1, double <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>=0, int operation=0)</td></tr>
<tr class="memdesc:af1d647152e38cede66380147e1bcf1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a small image into a large image.  <a href="class_bimage.html#af1d647152e38cede66380147e1bcf1ca">More...</a><br /></td></tr>
<tr class="separator:af1d647152e38cede66380147e1bcf1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9011e8d831cdcc0327736162163abd17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9011e8d831cdcc0327736162163abd17">place_with_addition</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, long nn)</td></tr>
<tr class="memdesc:a9011e8d831cdcc0327736162163abd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs a tile into a new composite image with addition within overlap.  <a href="class_bimage.html#a9011e8d831cdcc0327736162163abd17">More...</a><br /></td></tr>
<tr class="separator:a9011e8d831cdcc0327736162163abd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421ea2ee53d684fb3a5c54f46a0e8b2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a421ea2ee53d684fb3a5c54f46a0e8b2a">place_with_overlap</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, long nn)</td></tr>
<tr class="memdesc:a421ea2ee53d684fb3a5c54f46a0e8b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs a tile into a new composite image with weighted overlap.  <a href="class_bimage.html#a421ea2ee53d684fb3a5c54f46a0e8b2a">More...</a><br /></td></tr>
<tr class="separator:a421ea2ee53d684fb3a5c54f46a0e8b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1435a37676ede35fc90a5414851a0c41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1435a37676ede35fc90a5414851a0c41">place_central_part</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, long nn)</td></tr>
<tr class="memdesc:a1435a37676ede35fc90a5414851a0c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs a tile into a new composite image, retaining only the central part.  <a href="class_bimage.html#a1435a37676ede35fc90a5414851a0c41">More...</a><br /></td></tr>
<tr class="separator:a1435a37676ede35fc90a5414851a0c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1bceb367182c8e7f159fec64b95982"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adb1bceb367182c8e7f159fec64b95982">assemble_tiles</a> (<a class="el" href="class_bimage.html">Bimage</a> *pt, int flag=0)</td></tr>
<tr class="memdesc:adb1bceb367182c8e7f159fec64b95982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembles overlapping tiles into this image.  <a href="class_bimage.html#adb1bceb367182c8e7f159fec64b95982">More...</a><br /></td></tr>
<tr class="separator:adb1bceb367182c8e7f159fec64b95982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd968fadff01e5b7cb98bc61c5bb16c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3cd968fadff01e5b7cb98bc61c5bb16c">linear_fit</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double max_exclude)</td></tr>
<tr class="memdesc:a3cd968fadff01e5b7cb98bc61c5bb16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear least squares fit of two images.  <a href="class_bimage.html#a3cd968fadff01e5b7cb98bc61c5bb16c">More...</a><br /></td></tr>
<tr class="separator:a3cd968fadff01e5b7cb98bc61c5bb16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5b897839510f5387f40489d9465941"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6a5b897839510f5387f40489d9465941">histomatch</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, long bins)</td></tr>
<tr class="memdesc:a6a5b897839510f5387f40489d9465941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fits two images by matching the histogram of the second to the first.  <a href="class_bimage.html#a6a5b897839510f5387f40489d9465941">More...</a><br /></td></tr>
<tr class="separator:a6a5b897839510f5387f40489d9465941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44123b34d0f20e1835482d0a0fe8f86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae44123b34d0f20e1835482d0a0fe8f86">kernel_gaussian</a> (double sigma, double max)</td></tr>
<tr class="memdesc:ae44123b34d0f20e1835482d0a0fe8f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a gaussian kernel image.  <a href="class_bimage.html#ae44123b34d0f20e1835482d0a0fe8f86">More...</a><br /></td></tr>
<tr class="separator:ae44123b34d0f20e1835482d0a0fe8f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d4551d4e5fca005dffca66707ac232"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a90d4551d4e5fca005dffca66707ac232">kernel_laplacian_of_gaussian</a> (double sigma, double max)</td></tr>
<tr class="memdesc:a90d4551d4e5fca005dffca66707ac232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a laplacian-of-gaussian kernel.  <a href="class_bimage.html#a90d4551d4e5fca005dffca66707ac232">More...</a><br /></td></tr>
<tr class="separator:a90d4551d4e5fca005dffca66707ac232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5538ec2cf75dc526f2598f983b2823b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa5538ec2cf75dc526f2598f983b2823b">filter_average</a> (long kernel_size)</td></tr>
<tr class="memdesc:aa5538ec2cf75dc526f2598f983b2823b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an averaging filter to an image.  <a href="class_bimage.html#aa5538ec2cf75dc526f2598f983b2823b">More...</a><br /></td></tr>
<tr class="separator:aa5538ec2cf75dc526f2598f983b2823b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2921e0ee63f54e4254118a8ba407721"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab2921e0ee63f54e4254118a8ba407721">filter_average</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; k)</td></tr>
<tr class="separator:ab2921e0ee63f54e4254118a8ba407721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ca5f2052e28406522cd592d4a311e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a54ca5f2052e28406522cd592d4a311e6">gradient</a> ()</td></tr>
<tr class="memdesc:a54ca5f2052e28406522cd592d4a311e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the central difference gradient image.  <a href="class_bimage.html#a54ca5f2052e28406522cd592d4a311e6">More...</a><br /></td></tr>
<tr class="separator:a54ca5f2052e28406522cd592d4a311e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fe6231d0f7ea94af7f610a02827580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a68fe6231d0f7ea94af7f610a02827580">gradient3x3</a> ()</td></tr>
<tr class="memdesc:a68fe6231d0f7ea94af7f610a02827580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the difference gradient image in a 3x3 kernel.  <a href="class_bimage.html#a68fe6231d0f7ea94af7f610a02827580">More...</a><br /></td></tr>
<tr class="separator:a68fe6231d0f7ea94af7f610a02827580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7a4ada245ecf07688a166af32e1b02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9e7a4ada245ecf07688a166af32e1b02">filter_gaussian</a> (long kernel_size, double sigma=0)</td></tr>
<tr class="memdesc:a9e7a4ada245ecf07688a166af32e1b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a gaussian filter to an image.  <a href="class_bimage.html#a9e7a4ada245ecf07688a166af32e1b02">More...</a><br /></td></tr>
<tr class="separator:a9e7a4ada245ecf07688a166af32e1b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4227a87d62a6c08de8a41b8040b86a34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4227a87d62a6c08de8a41b8040b86a34">filter_sinc</a> ()</td></tr>
<tr class="memdesc:a4227a87d62a6c08de8a41b8040b86a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs an image with a sinc function.  <a href="class_bimage.html#a4227a87d62a6c08de8a41b8040b86a34">More...</a><br /></td></tr>
<tr class="separator:a4227a87d62a6c08de8a41b8040b86a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7a8b3e3bb82e5b64e47780ad3b41a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adc7a8b3e3bb82e5b64e47780ad3b41a0">convolve_chunk</a> (<a class="el" href="class_bimage.html">Bimage</a> *pkernel, float *nudata, long i, long len)</td></tr>
<tr class="separator:adc7a8b3e3bb82e5b64e47780ad3b41a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256555f8b2178b4a267fb0be752656ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a256555f8b2178b4a267fb0be752656ad">convolve</a> (<a class="el" href="class_bimage.html">Bimage</a> *pkernel)</td></tr>
<tr class="memdesc:a256555f8b2178b4a267fb0be752656ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolves an image with an arbitrary size convolution filter.  <a href="class_bimage.html#a256555f8b2178b4a267fb0be752656ad">More...</a><br /></td></tr>
<tr class="separator:a256555f8b2178b4a267fb0be752656ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0961f0dd6376ab4cf6428e408e500cf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0961f0dd6376ab4cf6428e408e500cf2">filter_ortho</a> (int type)</td></tr>
<tr class="memdesc:a0961f0dd6376ab4cf6428e408e500cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolves the image with an orthogonal kernel with wrapping.  <a href="class_bimage.html#a0961f0dd6376ab4cf6428e408e500cf2">More...</a><br /></td></tr>
<tr class="separator:a0961f0dd6376ab4cf6428e408e500cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b62e2269f9c7993c77349d583e9f300"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7b62e2269f9c7993c77349d583e9f300">filter_dog</a> (double sigma1, double sigma2)</td></tr>
<tr class="memdesc:a7b62e2269f9c7993c77349d583e9f300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolves the image with a difference of gausians kernel.  <a href="class_bimage.html#a7b62e2269f9c7993c77349d583e9f300">More...</a><br /></td></tr>
<tr class="separator:a7b62e2269f9c7993c77349d583e9f300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c716602230bd440ec0f6afb129ed6ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5c716602230bd440ec0f6afb129ed6ea">filter_bilateral_chunk</a> (<a class="el" href="class_bimage.html">Bimage</a> *pkernel, double sigma2, int kernel_type, float *nudata, long i, long len, int first)</td></tr>
<tr class="separator:a5c716602230bd440ec0f6afb129ed6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59222f093c517b163aeac959b3696fd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a59222f093c517b163aeac959b3696fd3">filter_bilateral</a> (double sigma1, double sigma2, int kernel_type, long kernel_radius)</td></tr>
<tr class="memdesc:a59222f093c517b163aeac959b3696fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denoise an image with combined gaussian distance and density difference kernel.  <a href="class_bimage.html#a59222f093c517b163aeac959b3696fd3">More...</a><br /></td></tr>
<tr class="separator:a59222f093c517b163aeac959b3696fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d4dbb6a5fd01ccb65c5ac871f210f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac4d4dbb6a5fd01ccb65c5ac871f210f7">filter_rolling_ball</a> (long radius, double scale)</td></tr>
<tr class="memdesc:ac4d4dbb6a5fd01ccb65c5ac871f210f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rolling ball filter.  <a href="class_bimage.html#ac4d4dbb6a5fd01ccb65c5ac871f210f7">More...</a><br /></td></tr>
<tr class="separator:ac4d4dbb6a5fd01ccb65c5ac871f210f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ca7c220c8b8a14d8501694ca2c70ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a54ca7c220c8b8a14d8501694ca2c70ee">filter_rank_chunk</a> (long kernel_size, double rank, float *nudata, long i, long len)</td></tr>
<tr class="separator:a54ca7c220c8b8a14d8501694ca2c70ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207f8d8d30304d422524b843c7175bf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a207f8d8d30304d422524b843c7175bf3">filter_rank</a> (long kernel_size, double rank)</td></tr>
<tr class="memdesc:a207f8d8d30304d422524b843c7175bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a median filter to an image.  <a href="class_bimage.html#a207f8d8d30304d422524b843c7175bf3">More...</a><br /></td></tr>
<tr class="separator:a207f8d8d30304d422524b843c7175bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bc11d57ce0c518f1945af4ee64d9eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab9bc11d57ce0c518f1945af4ee64d9eb">filter_peak</a> (long kernel_size)</td></tr>
<tr class="memdesc:ab9bc11d57ce0c518f1945af4ee64d9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the peaks in an image.  <a href="class_bimage.html#ab9bc11d57ce0c518f1945af4ee64d9eb">More...</a><br /></td></tr>
<tr class="separator:ab9bc11d57ce0c518f1945af4ee64d9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af3c37bff79cfdec5c4ab443d00a3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3af3c37bff79cfdec5c4ab443d00a3b7">periodic_averaging</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; period)</td></tr>
<tr class="memdesc:a3af3c37bff79cfdec5c4ab443d00a3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an average within a periodic frame.  <a href="class_bimage.html#a3af3c37bff79cfdec5c4ab443d00a3b7">More...</a><br /></td></tr>
<tr class="separator:a3af3c37bff79cfdec5c4ab443d00a3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd7c5588e083504f2bcdb551682dd57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adfd7c5588e083504f2bcdb551682dd57">aniso_average</a> (long ksize, double w)</td></tr>
<tr class="memdesc:adfd7c5588e083504f2bcdb551682dd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an anisotropic average within a kernel based on the local gradient.  <a href="class_bimage.html#adfd7c5588e083504f2bcdb551682dd57">More...</a><br /></td></tr>
<tr class="separator:adfd7c5588e083504f2bcdb551682dd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3dfa467026ffd2b1d6b5229756a028"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acc3dfa467026ffd2b1d6b5229756a028">filter_by_difference</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:acc3dfa467026ffd2b1d6b5229756a028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an anisotropic average within a kernel based on the local gradient.  <a href="class_bimage.html#acc3dfa467026ffd2b1d6b5229756a028">More...</a><br /></td></tr>
<tr class="separator:acc3dfa467026ffd2b1d6b5229756a028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec6da2aebaf06f411b5a98f2ecedae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2ec6da2aebaf06f411b5a98f2ecedae9">nad_2D</a> (double ht, double lambda, double C, double alpha)</td></tr>
<tr class="memdesc:a2ec6da2aebaf06f411b5a98f2ecedae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denoises a 2D image by non-linear anisotropic diffusion.  <a href="class_bimage.html#a2ec6da2aebaf06f411b5a98f2ecedae9">More...</a><br /></td></tr>
<tr class="separator:a2ec6da2aebaf06f411b5a98f2ecedae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5451bc9105d457fb967a025bd0c0cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aec5451bc9105d457fb967a025bd0c0cd">nad</a> (double ht, long zw, double lambda, double C, double alpha)</td></tr>
<tr class="memdesc:aec5451bc9105d457fb967a025bd0c0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denoises a 3D density map by non-linear anisotropic diffusion.  <a href="class_bimage.html#aec5451bc9105d457fb967a025bd0c0cd">More...</a><br /></td></tr>
<tr class="separator:aec5451bc9105d457fb967a025bd0c0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140b990f45d37151903ebc5d7541cddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a140b990f45d37151903ebc5d7541cddd">simple_to_complex</a> ()</td></tr>
<tr class="memdesc:a140b990f45d37151903ebc5d7541cddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple image is converted to a complex image.  <a href="class_bimage.html#a140b990f45d37151903ebc5d7541cddd">More...</a><br /></td></tr>
<tr class="separator:a140b990f45d37151903ebc5d7541cddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4694a4f5f907752135c39d67fb02eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7f4694a4f5f907752135c39d67fb02eb">multi_channel_to_complex</a> ()</td></tr>
<tr class="memdesc:a7f4694a4f5f907752135c39d67fb02eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-channel image is converted to a set of complex images.  <a href="class_bimage.html#a7f4694a4f5f907752135c39d67fb02eb">More...</a><br /></td></tr>
<tr class="separator:a7f4694a4f5f907752135c39d67fb02eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d1522e62412070a4694482067f3532"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad9d1522e62412070a4694482067f3532">complex_to_real</a> ()</td></tr>
<tr class="memdesc:ad9d1522e62412070a4694482067f3532"><td class="mdescLeft">&#160;</td><td class="mdescRight">The real part of a complex image is written to a simple image.  <a href="class_bimage.html#ad9d1522e62412070a4694482067f3532">More...</a><br /></td></tr>
<tr class="separator:ad9d1522e62412070a4694482067f3532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3902e92c0036d0d8f812a271f932a0c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3902e92c0036d0d8f812a271f932a0c8">complex_to_imaginary</a> ()</td></tr>
<tr class="memdesc:a3902e92c0036d0d8f812a271f932a0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The imaginary part of a complex image is written to a simple image.  <a href="class_bimage.html#a3902e92c0036d0d8f812a271f932a0c8">More...</a><br /></td></tr>
<tr class="separator:a3902e92c0036d0d8f812a271f932a0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a5fe205d012073c5bc2a902ca3e95a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab9a5fe205d012073c5bc2a902ca3e95a">complex_to_intensities</a> ()</td></tr>
<tr class="memdesc:ab9a5fe205d012073c5bc2a902ca3e95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intensities from a complex image is written to a simple image.  <a href="class_bimage.html#ab9a5fe205d012073c5bc2a902ca3e95a">More...</a><br /></td></tr>
<tr class="separator:ab9a5fe205d012073c5bc2a902ca3e95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484243844b17ec9265365545c5087044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a484243844b17ec9265365545c5087044">complex_to_amplitudes</a> ()</td></tr>
<tr class="memdesc:a484243844b17ec9265365545c5087044"><td class="mdescLeft">&#160;</td><td class="mdescRight">The amplitudes from a complex image is written to a simple image.  <a href="class_bimage.html#a484243844b17ec9265365545c5087044">More...</a><br /></td></tr>
<tr class="separator:a484243844b17ec9265365545c5087044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2e55ed269cd9f3bd954ce2f9d18ed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7d2e55ed269cd9f3bd954ce2f9d18ed0">complex_to_signed_amplitudes</a> ()</td></tr>
<tr class="memdesc:a7d2e55ed269cd9f3bd954ce2f9d18ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signed amplitudes from a complex image is written to a simple image.  <a href="class_bimage.html#a7d2e55ed269cd9f3bd954ce2f9d18ed0">More...</a><br /></td></tr>
<tr class="separator:a7d2e55ed269cd9f3bd954ce2f9d18ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcb9c3eab00573289c72f6ee24ed20c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acfcb9c3eab00573289c72f6ee24ed20c">complex_to_phases</a> ()</td></tr>
<tr class="memdesc:acfcb9c3eab00573289c72f6ee24ed20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The phases from a complex image is written to a simple image.  <a href="class_bimage.html#acfcb9c3eab00573289c72f6ee24ed20c">More...</a><br /></td></tr>
<tr class="separator:acfcb9c3eab00573289c72f6ee24ed20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c83144b13c3a4c25a7ef4ec9fcf6685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6c83144b13c3a4c25a7ef4ec9fcf6685">complex_conjugate</a> ()</td></tr>
<tr class="memdesc:a6c83144b13c3a4c25a7ef4ec9fcf6685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the complex conjugate image.  <a href="class_bimage.html#a6c83144b13c3a4c25a7ef4ec9fcf6685">More...</a><br /></td></tr>
<tr class="separator:a6c83144b13c3a4c25a7ef4ec9fcf6685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0390feeaaed888509327745aad01f27"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af0390feeaaed888509327745aad01f27">complex_power</a> ()</td></tr>
<tr class="memdesc:af0390feeaaed888509327745aad01f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the power in a complex image.  <a href="class_bimage.html#af0390feeaaed888509327745aad01f27">More...</a><br /></td></tr>
<tr class="separator:af0390feeaaed888509327745aad01f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52f5efd5dad2c089de6c1acbb47bb37"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad52f5efd5dad2c089de6c1acbb47bb37">complex_normalize</a> ()</td></tr>
<tr class="memdesc:ad52f5efd5dad2c089de6c1acbb47bb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the power in a complex image.  <a href="class_bimage.html#ad52f5efd5dad2c089de6c1acbb47bb37">More...</a><br /></td></tr>
<tr class="separator:ad52f5efd5dad2c089de6c1acbb47bb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1e6fe27d9a3cabcf908748000ede94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3d1e6fe27d9a3cabcf908748000ede94">phase_shift</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>)</td></tr>
<tr class="memdesc:a3d1e6fe27d9a3cabcf908748000ede94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase shifts a complex image.  <a href="class_bimage.html#a3d1e6fe27d9a3cabcf908748000ede94">More...</a><br /></td></tr>
<tr class="separator:a3d1e6fe27d9a3cabcf908748000ede94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634b527816eb889e18c2b945cbee91f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a634b527816eb889e18c2b945cbee91f9">phase_shift</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>)</td></tr>
<tr class="memdesc:a634b527816eb889e18c2b945cbee91f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase shifts a complex sub-image.  <a href="class_bimage.html#a634b527816eb889e18c2b945cbee91f9">More...</a><br /></td></tr>
<tr class="separator:a634b527816eb889e18c2b945cbee91f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19989b5365083532862811255c06b538"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a19989b5365083532862811255c06b538">phase_shift_to_origin</a> ()</td></tr>
<tr class="memdesc:a19989b5365083532862811255c06b538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase shifts a set of reflections to the image origin.  <a href="class_bimage.html#a19989b5365083532862811255c06b538">More...</a><br /></td></tr>
<tr class="separator:a19989b5365083532862811255c06b538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdc9509fb8666efb3b60141d95aa36d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aacdc9509fb8666efb3b60141d95aa36d">phase_shift_to_center</a> ()</td></tr>
<tr class="memdesc:aacdc9509fb8666efb3b60141d95aa36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase shifts a set of reflections to the nominal center of the image origin.  <a href="class_bimage.html#aacdc9509fb8666efb3b60141d95aa36d">More...</a><br /></td></tr>
<tr class="separator:aacdc9509fb8666efb3b60141d95aa36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dd2401fc3d59bde6d222d8979d12af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af9dd2401fc3d59bde6d222d8979d12af">complex_multiply</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:af9dd2401fc3d59bde6d222d8979d12af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the product of a complex image with a simple image.  <a href="class_bimage.html#af9dd2401fc3d59bde6d222d8979d12af">More...</a><br /></td></tr>
<tr class="separator:af9dd2401fc3d59bde6d222d8979d12af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7177b199823a9ccbf78fc65f1042038"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac7177b199823a9ccbf78fc65f1042038">complex_product</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:ac7177b199823a9ccbf78fc65f1042038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the complex product of two complex images.  <a href="class_bimage.html#ac7177b199823a9ccbf78fc65f1042038">More...</a><br /></td></tr>
<tr class="separator:ac7177b199823a9ccbf78fc65f1042038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2869ea078baf18fbde181f9831c9bc6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2869ea078baf18fbde181f9831c9bc6f">complex_conjugate_product</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, int norm=0)</td></tr>
<tr class="memdesc:a2869ea078baf18fbde181f9831c9bc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the product of a complex image with the conjugate of a second.  <a href="class_bimage.html#a2869ea078baf18fbde181f9831c9bc6f">More...</a><br /></td></tr>
<tr class="separator:a2869ea078baf18fbde181f9831c9bc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23fee98976ac23c37ce16d7feac9ee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af23fee98976ac23c37ce16d7feac9ee0">complex_conjugate_product_one2many</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:af23fee98976ac23c37ce16d7feac9ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the product of a complex image with the conjugate of a second.  <a href="class_bimage.html#af23fee98976ac23c37ce16d7feac9ee0">More...</a><br /></td></tr>
<tr class="separator:af23fee98976ac23c37ce16d7feac9ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900f7f590e1626c8f521e731cb4a9043"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a900f7f590e1626c8f521e731cb4a9043">complex_apply_mask</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask)</td></tr>
<tr class="memdesc:a900f7f590e1626c8f521e731cb4a9043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a mask to a complex image.  <a href="class_bimage.html#a900f7f590e1626c8f521e731cb4a9043">More...</a><br /></td></tr>
<tr class="separator:a900f7f590e1626c8f521e731cb4a9043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46eac20f607c7922eef77c90a40a832"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab46eac20f607c7922eef77c90a40a832">complex_apply_negative_mask</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask)</td></tr>
<tr class="memdesc:ab46eac20f607c7922eef77c90a40a832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a negative mask to a complex image.  <a href="class_bimage.html#ab46eac20f607c7922eef77c90a40a832">More...</a><br /></td></tr>
<tr class="separator:ab46eac20f607c7922eef77c90a40a832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409f4fa58ef28c6cd7f591a8a89d574c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a409f4fa58ef28c6cd7f591a8a89d574c">complex_apply_dual_mask</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask)</td></tr>
<tr class="memdesc:a409f4fa58ef28c6cd7f591a8a89d574c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a dual mask to a complex image.  <a href="class_bimage.html#a409f4fa58ef28c6cd7f591a8a89d574c">More...</a><br /></td></tr>
<tr class="separator:a409f4fa58ef28c6cd7f591a8a89d574c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcacc4e756f549b1bb2a60b13ae93a00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adcacc4e756f549b1bb2a60b13ae93a00">complex_bandpass</a> (double hires, double lores)</td></tr>
<tr class="memdesc:adcacc4e756f549b1bb2a60b13ae93a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bandpasses a Fourier transform.  <a href="class_bimage.html#adcacc4e756f549b1bb2a60b13ae93a00">More...</a><br /></td></tr>
<tr class="separator:adcacc4e756f549b1bb2a60b13ae93a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdf88c178b8f32dafefe99468a543c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4fdf88c178b8f32dafefe99468a543c6">pack_two_in_complex</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:a4fdf88c178b8f32dafefe99468a543c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs two real images into one complex image.  <a href="class_bimage.html#a4fdf88c178b8f32dafefe99468a543c6">More...</a><br /></td></tr>
<tr class="separator:a4fdf88c178b8f32dafefe99468a543c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab581cd7985b8d57b0fce1d70a1651f1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab581cd7985b8d57b0fce1d70a1651f1a">unpack_combined_transform</a> ()</td></tr>
<tr class="memdesc:ab581cd7985b8d57b0fce1d70a1651f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks a complex transform obtained from two real images.  <a href="class_bimage.html#ab581cd7985b8d57b0fce1d70a1651f1a">More...</a><br /></td></tr>
<tr class="separator:ab581cd7985b8d57b0fce1d70a1651f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71edead8db40d0773892175a7b5b7a2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a71edead8db40d0773892175a7b5b7a2a">combined_complex_product</a> ()</td></tr>
<tr class="memdesc:a71edead8db40d0773892175a7b5b7a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images.  <a href="class_bimage.html#a71edead8db40d0773892175a7b5b7a2a">More...</a><br /></td></tr>
<tr class="separator:a71edead8db40d0773892175a7b5b7a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f205cb70f7ea0a38369ae7c6f2b5222"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8f205cb70f7ea0a38369ae7c6f2b5222">combined_complex_product</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask)</td></tr>
<tr class="memdesc:a8f205cb70f7ea0a38369ae7c6f2b5222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images.  <a href="class_bimage.html#a8f205cb70f7ea0a38369ae7c6f2b5222">More...</a><br /></td></tr>
<tr class="separator:a8f205cb70f7ea0a38369ae7c6f2b5222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ff4d6148499e24377c45428ec8c73a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a31ff4d6148499e24377c45428ec8c73a">combined_complex_product</a> (double hires, double lores)</td></tr>
<tr class="memdesc:a31ff4d6148499e24377c45428ec8c73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images.  <a href="class_bimage.html#a31ff4d6148499e24377c45428ec8c73a">More...</a><br /></td></tr>
<tr class="separator:a31ff4d6148499e24377c45428ec8c73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03855b78911b0811e1208885cffc98e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa03855b78911b0811e1208885cffc98e">combined_complex_product</a> (double hires, double lores, <a class="el" href="class_bimage.html">Bimage</a> *pmask)</td></tr>
<tr class="memdesc:aa03855b78911b0811e1208885cffc98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images.  <a href="class_bimage.html#aa03855b78911b0811e1208885cffc98e">More...</a><br /></td></tr>
<tr class="separator:aa03855b78911b0811e1208885cffc98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415d393255e21b878bfdc574146a40e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a415d393255e21b878bfdc574146a40e8">combined_complex_product_implicit_mask</a> (double hires, double lores)</td></tr>
<tr class="memdesc:a415d393255e21b878bfdc574146a40e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images.  <a href="class_bimage.html#a415d393255e21b878bfdc574146a40e8">More...</a><br /></td></tr>
<tr class="separator:a415d393255e21b878bfdc574146a40e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a84149ddcfe364e0687f485939274e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a03a84149ddcfe364e0687f485939274e">merge_amplitudes_and_phases</a> (<a class="el" href="class_bimage.html">Bimage</a> *pamp)</td></tr>
<tr class="memdesc:a03a84149ddcfe364e0687f485939274e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the amplitudes from one map with the phases of another.  <a href="class_bimage.html#a03a84149ddcfe364e0687f485939274e">More...</a><br /></td></tr>
<tr class="separator:a03a84149ddcfe364e0687f485939274e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ac2e1677fe947f84234716aba5e50"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0c0ac2e1677fe947f84234716aba5e50">merge_amplitudes_and_phases</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, double res_hi, double res_lo)</td></tr>
<tr class="memdesc:a0c0ac2e1677fe947f84234716aba5e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps selected phases and replaces amplitudes and other phases from a reference transform.  <a href="class_bimage.html#a0c0ac2e1677fe947f84234716aba5e50">More...</a><br /></td></tr>
<tr class="separator:a0c0ac2e1677fe947f84234716aba5e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b16ff07227b448151d6b73c572451a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa7b16ff07227b448151d6b73c572451a">intensities_phase_colored</a> (double scale)</td></tr>
<tr class="memdesc:aa7b16ff07227b448151d6b73c572451a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a power spectrum with phases colored according to a color wheel.  <a href="class_bimage.html#aa7b16ff07227b448151d6b73c572451a">More...</a><br /></td></tr>
<tr class="separator:aa7b16ff07227b448151d6b73c572451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f15772a51c0eb1d502fe03d423fba69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3f15772a51c0eb1d502fe03d423fba69">phase_colour_wheel</a> ()</td></tr>
<tr class="memdesc:a3f15772a51c0eb1d502fe03d423fba69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a phase color wheel.  <a href="class_bimage.html#a3f15772a51c0eb1d502fe03d423fba69">More...</a><br /></td></tr>
<tr class="separator:a3f15772a51c0eb1d502fe03d423fba69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7eea09fdb8cca40c6778cd4aa4c49e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3d7eea09fdb8cca40c6778cd4aa4c49e">fft_setup</a> (<a class="el" href="fft_8h.html#a61cf819a81d9f5c3c4d82f5907e3fe67">fft_direction</a> dir, int opt=0)</td></tr>
<tr class="memdesc:a3d7eea09fdb8cca40c6778cd4aa4c49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a plan for fast Fourier transforms.  <a href="class_bimage.html#a3d7eea09fdb8cca40c6778cd4aa4c49e">More...</a><br /></td></tr>
<tr class="separator:a3d7eea09fdb8cca40c6778cd4aa4c49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40b2b2d919d6d3a3e3eda301d4e0fba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac40b2b2d919d6d3a3e3eda301d4e0fba">fft</a> ()</td></tr>
<tr class="separator:ac40b2b2d919d6d3a3e3eda301d4e0fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83202ab557c3a6acc6f635d217146a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad83202ab557c3a6acc6f635d217146a6">fft_back</a> ()</td></tr>
<tr class="separator:ad83202ab557c3a6acc6f635d217146a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242a0713955bce07cc7b0f5904ff394f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a242a0713955bce07cc7b0f5904ff394f">fft</a> (<a class="el" href="fft_8h.html#a61cf819a81d9f5c3c4d82f5907e3fe67">fft_direction</a> dir)</td></tr>
<tr class="memdesc:a242a0713955bce07cc7b0f5904ff394f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Fourier transforms an image.  <a href="class_bimage.html#a242a0713955bce07cc7b0f5904ff394f">More...</a><br /></td></tr>
<tr class="separator:a242a0713955bce07cc7b0f5904ff394f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79448ddf4fd8e74bbfd846d7bb9b19e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a79448ddf4fd8e74bbfd846d7bb9b19e7">fft_back</a> (<a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> plan, bool norm_flag=1)</td></tr>
<tr class="separator:a79448ddf4fd8e74bbfd846d7bb9b19e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109041ab7adcf1134630008c736cd0a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a109041ab7adcf1134630008c736cd0a1">fft</a> (<a class="el" href="fft_8h.html#a61cf819a81d9f5c3c4d82f5907e3fe67">fft_direction</a> dir, bool norm_flag)</td></tr>
<tr class="memdesc:a109041ab7adcf1134630008c736cd0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Fourier transforms an image.  <a href="class_bimage.html#a109041ab7adcf1134630008c736cd0a1">More...</a><br /></td></tr>
<tr class="separator:a109041ab7adcf1134630008c736cd0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdc6f06bec66f631c393b87ac2a742f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adcdc6f06bec66f631c393b87ac2a742f">fft</a> (<a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> plan, bool norm_flag=1)</td></tr>
<tr class="memdesc:adcdc6f06bec66f631c393b87ac2a742f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Fourier transforms an image.  <a href="class_bimage.html#adcdc6f06bec66f631c393b87ac2a742f">More...</a><br /></td></tr>
<tr class="separator:adcdc6f06bec66f631c393b87ac2a742f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74e7014bad39ad70cf631c4470d6a3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae74e7014bad39ad70cf631c4470d6a3c">change_transform_size</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize)</td></tr>
<tr class="memdesc:ae74e7014bad39ad70cf631c4470d6a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes a "standard" transform.  <a href="class_bimage.html#ae74e7014bad39ad70cf631c4470d6a3c">More...</a><br /></td></tr>
<tr class="separator:ae74e7014bad39ad70cf631c4470d6a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073293aef6831dbcd752ec0b6335e55e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a073293aef6831dbcd752ec0b6335e55e">power_spectrum</a> (int flags=0)</td></tr>
<tr class="memdesc:a073293aef6831dbcd752ec0b6335e55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a power spectrum.  <a href="class_bimage.html#a073293aef6831dbcd752ec0b6335e55e">More...</a><br /></td></tr>
<tr class="separator:a073293aef6831dbcd752ec0b6335e55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62da7cb39c8509a277d4b60a0ad2eac7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a62da7cb39c8509a277d4b60a0ad2eac7">powerspectrum_tiled</a> (long img_num, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; tile_size, int flags=0)</td></tr>
<tr class="memdesc:a62da7cb39c8509a277d4b60a0ad2eac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares a tiled power spectrum from an image for determining CTF parameters.  <a href="class_bimage.html#a62da7cb39c8509a277d4b60a0ad2eac7">More...</a><br /></td></tr>
<tr class="separator:a62da7cb39c8509a277d4b60a0ad2eac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ae17085d0e29552f960c53090b19fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a71ae17085d0e29552f960c53090b19fe">powerspectrum_tilt_axis</a> (long img_num, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; tile_size, double tilt_axis, double tilt_offset, int flags=0)</td></tr>
<tr class="memdesc:a71ae17085d0e29552f960c53090b19fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares a tiled powerspectrum from a tilted image for determining CTF parameters.  <a href="class_bimage.html#a71ae17085d0e29552f960c53090b19fe">More...</a><br /></td></tr>
<tr class="separator:a71ae17085d0e29552f960c53090b19fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e13cf2551e48c8d98c5bad3c3690f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a86e13cf2551e48c8d98c5bad3c3690f9">defocus_scale</a> (long nn, double df, double df2, double iCL2, int fill_type)</td></tr>
<tr class="separator:a86e13cf2551e48c8d98c5bad3c3690f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c0fe6b37b552146256828cb6f17624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae4c0fe6b37b552146256828cb6f17624">powerspectrum_tilted</a> (long img_num, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; tile_size, double tilt_axis, double tilt_angle, double defocus, double iCL2, int flags=0)</td></tr>
<tr class="memdesc:ae4c0fe6b37b552146256828cb6f17624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares a tiled powerspectrum from a tilted image for determining CTF parameters.  <a href="class_bimage.html#ae4c0fe6b37b552146256828cb6f17624">More...</a><br /></td></tr>
<tr class="separator:ae4c0fe6b37b552146256828cb6f17624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dd5e4008605164e43d404e3d82e02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad0dd5e4008605164e43d404e3d82e02e">powerspectrum_tiled_and_tilted</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; tile_size, double tilt_axis, double tilt_angle, double tilt_offset, double defocus, double iCL2, int flags=0)</td></tr>
<tr class="memdesc:ad0dd5e4008605164e43d404e3d82e02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares a tiled powerspectrum from a tilted image for determining CTF parameters.  <a href="class_bimage.html#ad0dd5e4008605164e43d404e3d82e02e">More...</a><br /></td></tr>
<tr class="separator:ad0dd5e4008605164e43d404e3d82e02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3d62db989c0a47443622038e615fb4"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3f3d62db989c0a47443622038e615fb4">powerspectrum_isotropy</a> (long n, double &amp;lores, double &amp;hires)</td></tr>
<tr class="memdesc:a3f3d62db989c0a47443622038e615fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a measure of anisotropy in a poer spectrum.  <a href="class_bimage.html#a3f3d62db989c0a47443622038e615fb4">More...</a><br /></td></tr>
<tr class="separator:a3f3d62db989c0a47443622038e615fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2949fc9aeff65845b1c0e64f3cae467"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af2949fc9aeff65845b1c0e64f3cae467">fspace_maximum_radius</a> (double resolution, double sampling_ratio=1)</td></tr>
<tr class="memdesc:af2949fc9aeff65845b1c0e64f3cae467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the maximum radius in frequency space from a given resolution.  <a href="class_bimage.html#af2949fc9aeff65845b1c0e64f3cae467">More...</a><br /></td></tr>
<tr class="separator:af2949fc9aeff65845b1c0e64f3cae467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4570a384d1683cfcc8e2b1c18c0bda8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad4570a384d1683cfcc8e2b1c18c0bda8">fspace_background</a> ()</td></tr>
<tr class="memdesc:ad4570a384d1683cfcc8e2b1c18c0bda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the background for a Fourier transform.  <a href="class_bimage.html#ad4570a384d1683cfcc8e2b1c18c0bda8">More...</a><br /></td></tr>
<tr class="separator:ad4570a384d1683cfcc8e2b1c18c0bda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc08eed53836fe562577d3a19f24a50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_complex.html">Complex</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7cc08eed53836fe562577d3a19f24a50">fspace_interpolate</a> (long img_num, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; m, <a class="el" href="class_f_s_i___kernel.html">FSI_Kernel</a> *<a class="el" href="structkernel.html">kernel</a>)</td></tr>
<tr class="memdesc:a7cc08eed53836fe562577d3a19f24a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the complex value at an image location by kernel-based interpolation.  <a href="class_bimage.html#a7cc08eed53836fe562577d3a19f24a50">More...</a><br /></td></tr>
<tr class="separator:a7cc08eed53836fe562577d3a19f24a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75d027b66e4adb4ef2f31ebb14da778"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa75d027b66e4adb4ef2f31ebb14da778">fspace_2D_interpolate</a> (<a class="el" href="class_complex.html">Complex</a>&lt; float &gt; cv, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; m, double part_weight, int interp_type)</td></tr>
<tr class="memdesc:aa75d027b66e4adb4ef2f31ebb14da778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates a 2D image for packing ito a 3D reciprocal space volume. <br  />
  <a href="class_bimage.html#aa75d027b66e4adb4ef2f31ebb14da778">More...</a><br /></td></tr>
<tr class="separator:aa75d027b66e4adb4ef2f31ebb14da778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fa0fdcb205c13fd845e64285504be8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac1fa0fdcb205c13fd845e64285504be8">fspace_pack_2D</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, <a class="el" href="class_matrix3.html">Matrix3</a> mat, double hi_res, double lo_res, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; scale, double part_weight=1, int interp_type=0)</td></tr>
<tr class="memdesc:ac1fa0fdcb205c13fd845e64285504be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs a 2D Fourier transform into a 3D reciprocal space volume. <br  />
  <a href="class_bimage.html#ac1fa0fdcb205c13fd845e64285504be8">More...</a><br /></td></tr>
<tr class="separator:ac1fa0fdcb205c13fd845e64285504be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10fa82f152bee515c19971d2e8a1994"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab10fa82f152bee515c19971d2e8a1994">fspace_pack_2D</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, <a class="el" href="class_view.html">View</a> asu_view, <a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym, double hi_res, double lo_res, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; scale, double part_weight=1, int interp_type=0)</td></tr>
<tr class="memdesc:ab10fa82f152bee515c19971d2e8a1994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs a 2D Fourier transform into a 3D reciprocal space volume. <br  />
  <a href="class_bimage.html#ab10fa82f152bee515c19971d2e8a1994">More...</a><br /></td></tr>
<tr class="separator:ab10fa82f152bee515c19971d2e8a1994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b940c547ffc63a3295545992833de9"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a71b940c547ffc63a3295545992833de9">fspace_pack_2D_into_central_section</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, long ft_size, double scale, double hi_res, double lo_res, <a class="el" href="class_matrix3.html">Matrix3</a> matr, <a class="el" href="class_matrix3.html">Matrix3</a> mat)</td></tr>
<tr class="memdesc:a71b940c547ffc63a3295545992833de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs a 2D Fourier transform into a central section of a 3D reciprocal space volume. <br  />
  <a href="class_bimage.html#a71b940c547ffc63a3295545992833de9">More...</a><br /></td></tr>
<tr class="separator:a71b940c547ffc63a3295545992833de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4adb193f4e57c5a3395cfe5da8a3682"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab4adb193f4e57c5a3395cfe5da8a3682">fspace_pack_3D</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double hi_res=0, double threshold=0)</td></tr>
<tr class="memdesc:ab4adb193f4e57c5a3395cfe5da8a3682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs a 3D Fourier transform into a 3D reciprocal space volume.  <a href="class_bimage.html#ab4adb193f4e57c5a3395cfe5da8a3682">More...</a><br /></td></tr>
<tr class="separator:ab4adb193f4e57c5a3395cfe5da8a3682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80930fd138c661a8728b3a8cb39b72d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac80930fd138c661a8728b3a8cb39b72d">fspace_reconstruction_add</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:ac80930fd138c661a8728b3a8cb39b72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all components to a reconstruction.  <a href="class_bimage.html#ac80930fd138c661a8728b3a8cb39b72d">More...</a><br /></td></tr>
<tr class="separator:ac80930fd138c661a8728b3a8cb39b72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d5c9685021e104bea5e61dd1b87f60"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a37d5c9685021e104bea5e61dd1b87f60">fspace_reconstruction_weigh</a> ()</td></tr>
<tr class="memdesc:a37d5c9685021e104bea5e61dd1b87f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs a reconstruction.  <a href="class_bimage.html#a37d5c9685021e104bea5e61dd1b87f60">More...</a><br /></td></tr>
<tr class="separator:a37d5c9685021e104bea5e61dd1b87f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203259c67bbe3d31b46d9b9f3c923153"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a203259c67bbe3d31b46d9b9f3c923153">fspace_reconstruction_stats</a> (double resolution, double sampling_ratio=1)</td></tr>
<tr class="memdesc:a203259c67bbe3d31b46d9b9f3c923153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates Fourier shell statistics.  <a href="class_bimage.html#a203259c67bbe3d31b46d9b9f3c923153">More...</a><br /></td></tr>
<tr class="separator:a203259c67bbe3d31b46d9b9f3c923153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f975f6f05c471150640a20add0acd86"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4f975f6f05c471150640a20add0acd86">fspace_reconstruction_snr</a> ()</td></tr>
<tr class="memdesc:a4f975f6f05c471150640a20add0acd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the SNR map.  <a href="class_bimage.html#a4f975f6f05c471150640a20add0acd86">More...</a><br /></td></tr>
<tr class="separator:a4f975f6f05c471150640a20add0acd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbfd40bd975c34e1ed4235e58af8dc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8bbfd40bd975c34e1ed4235e58af8dc1">fspace_translate</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>)</td></tr>
<tr class="memdesc:a8bbfd40bd975c34e1ed4235e58af8dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates an image in frequency space to avoid interpolation.  <a href="class_bimage.html#a8bbfd40bd975c34e1ed4235e58af8dc1">More...</a><br /></td></tr>
<tr class="separator:a8bbfd40bd975c34e1ed4235e58af8dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4c3dbc2ad222e9ff66a5a0c6e4f562"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adf4c3dbc2ad222e9ff66a5a0c6e4f562">fspace_translate</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>)</td></tr>
<tr class="memdesc:adf4c3dbc2ad222e9ff66a5a0c6e4f562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates an image in frequency space to avoid interpolation.  <a href="class_bimage.html#adf4c3dbc2ad222e9ff66a5a0c6e4f562">More...</a><br /></td></tr>
<tr class="separator:adf4c3dbc2ad222e9ff66a5a0c6e4f562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfe151a39d17ada82c7ca0ed64fd589"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7bfe151a39d17ada82c7ca0ed64fd589">fspace_resize</a> (double scale, double res_hi, double res_lo)</td></tr>
<tr class="memdesc:a7bfe151a39d17ada82c7ca0ed64fd589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes an image in frequency space to avoid interpolation.  <a href="class_bimage.html#a7bfe151a39d17ada82c7ca0ed64fd589">More...</a><br /></td></tr>
<tr class="separator:a7bfe151a39d17ada82c7ca0ed64fd589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f425f44f6e885acd68fd329d07edd63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0f425f44f6e885acd68fd329d07edd63">fspace_resize</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref)</td></tr>
<tr class="memdesc:a0f425f44f6e885acd68fd329d07edd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes an image in frequency space to avoid interpolation.  <a href="class_bimage.html#a0f425f44f6e885acd68fd329d07edd63">More...</a><br /></td></tr>
<tr class="separator:a0f425f44f6e885acd68fd329d07edd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f70203482c3025452fb5e9a097bde6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af4f70203482c3025452fb5e9a097bde6">fspace_amp_one</a> ()</td></tr>
<tr class="memdesc:af4f70203482c3025452fb5e9a097bde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all amplitudes to one.  <a href="class_bimage.html#af4f70203482c3025452fb5e9a097bde6">More...</a><br /></td></tr>
<tr class="separator:af4f70203482c3025452fb5e9a097bde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f66579e3b1e53aec78ae09985ce824b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2f66579e3b1e53aec78ae09985ce824b">fspace_amp_threshold</a> (double threshold)</td></tr>
<tr class="memdesc:a2f66579e3b1e53aec78ae09985ce824b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the amplitudes of the Fourier transform of an image.  <a href="class_bimage.html#a2f66579e3b1e53aec78ae09985ce824b">More...</a><br /></td></tr>
<tr class="separator:a2f66579e3b1e53aec78ae09985ce824b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da47417a7d1fea0cd6a02cbab87c702"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7da47417a7d1fea0cd6a02cbab87c702">fspace_sqrt_amp</a> ()</td></tr>
<tr class="memdesc:a7da47417a7d1fea0cd6a02cbab87c702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the amlitudes to their square roots.  <a href="class_bimage.html#a7da47417a7d1fea0cd6a02cbab87c702">More...</a><br /></td></tr>
<tr class="separator:a7da47417a7d1fea0cd6a02cbab87c702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63076c1fcbd277ad435729c33b5be82f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a63076c1fcbd277ad435729c33b5be82f">fspace_square_amp</a> ()</td></tr>
<tr class="memdesc:a63076c1fcbd277ad435729c33b5be82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the amlitudes to their squares.  <a href="class_bimage.html#a63076c1fcbd277ad435729c33b5be82f">More...</a><br /></td></tr>
<tr class="separator:a63076c1fcbd277ad435729c33b5be82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fc3ee68565a1a039b34145446295a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a64fc3ee68565a1a039b34145446295a2">fspace_bandpass</a> (double res_hi, double res_lo=0, double width=0)</td></tr>
<tr class="memdesc:a64fc3ee68565a1a039b34145446295a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a bandpass filter to an image.  <a href="class_bimage.html#a64fc3ee68565a1a039b34145446295a2">More...</a><br /></td></tr>
<tr class="separator:a64fc3ee68565a1a039b34145446295a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a004d126c6b9441256e145226416293"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3a004d126c6b9441256e145226416293">fspace_bandpass</a> (double res_hi, double res_lo, double width, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="memdesc:a3a004d126c6b9441256e145226416293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a bandpass filter to an image.  <a href="class_bimage.html#a3a004d126c6b9441256e145226416293">More...</a><br /></td></tr>
<tr class="separator:a3a004d126c6b9441256e145226416293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39127eceed3818eb3a0e1e59f0d329f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a39127eceed3818eb3a0e1e59f0d329f3">fspace_frequency_filter</a> (double freq, double sigma)</td></tr>
<tr class="memdesc:a39127eceed3818eb3a0e1e59f0d329f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a frequency filter to an image.  <a href="class_bimage.html#a39127eceed3818eb3a0e1e59f0d329f3">More...</a><br /></td></tr>
<tr class="separator:a39127eceed3818eb3a0e1e59f0d329f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e20382b67e69755e6db457043a0d396"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6e20382b67e69755e6db457043a0d396">fspace_frequency_filter</a> (double freq, double sigma, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="memdesc:a6e20382b67e69755e6db457043a0d396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a frequency filter to an image.  <a href="class_bimage.html#a6e20382b67e69755e6db457043a0d396">More...</a><br /></td></tr>
<tr class="separator:a6e20382b67e69755e6db457043a0d396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdd3fb2790fb3c739546f4c95462440"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3cdd3fb2790fb3c739546f4c95462440">fspace_gabor_filter</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; freq, double fsigma, double psigma)</td></tr>
<tr class="memdesc:a3cdd3fb2790fb3c739546f4c95462440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a Gabor filter to an image.  <a href="class_bimage.html#a3cdd3fb2790fb3c739546f4c95462440">More...</a><br /></td></tr>
<tr class="separator:a3cdd3fb2790fb3c739546f4c95462440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece2172a647021b71693e1335a52ad4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aece2172a647021b71693e1335a52ad4e">fspace_gabor_filter</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; freq, double fsigma, double psigma, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="memdesc:aece2172a647021b71693e1335a52ad4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a Gabor filter to an image.  <a href="class_bimage.html#aece2172a647021b71693e1335a52ad4e">More...</a><br /></td></tr>
<tr class="separator:aece2172a647021b71693e1335a52ad4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73ec86061ff431511f6c635c1695b87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae73ec86061ff431511f6c635c1695b87">fspace_radial_power</a> (double resolution, double sampling_ratio=1)</td></tr>
<tr class="memdesc:ae73ec86061ff431511f6c635c1695b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the radial power spectrum from a Fourier transform.  <a href="class_bimage.html#ae73ec86061ff431511f6c635c1695b87">More...</a><br /></td></tr>
<tr class="separator:ae73ec86061ff431511f6c635c1695b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7365e14f761ca13be325fda8991d3ff"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac7365e14f761ca13be325fda8991d3ff">fspace_radial</a> (long nn, long maxrad, int flag=0)</td></tr>
<tr class="memdesc:ac7365e14f761ca13be325fda8991d3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the radial power spectrum from a Fourier transform.  <a href="class_bimage.html#ac7365e14f761ca13be325fda8991d3ff">More...</a><br /></td></tr>
<tr class="separator:ac7365e14f761ca13be325fda8991d3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f7fe843ce8b5018344741d0023a29e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a06f7fe843ce8b5018344741d0023a29e">fspace_weigh</a> (vector&lt; double &gt; &amp;curve, int flag=0)</td></tr>
<tr class="separator:a06f7fe843ce8b5018344741d0023a29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5d55edda2562384bd08fbb5935a0d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4b5d55edda2562384bd08fbb5935a0d8">fspace_scale</a> (vector&lt; double &gt; &amp;scale, <a class="el" href="class_bimage.html">Bimage</a> *pmask=NULL)</td></tr>
<tr class="separator:a4b5d55edda2562384bd08fbb5935a0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c92e49362a8548a332108661bd83530"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2c92e49362a8548a332108661bd83530">fspace_scale</a> (long nn, vector&lt; double &gt; &amp;scale, <a class="el" href="class_bimage.html">Bimage</a> *pmask=NULL)</td></tr>
<tr class="separator:a2c92e49362a8548a332108661bd83530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ea5aed3caede8ae6e6e223adf35093"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af9ea5aed3caede8ae6e6e223adf35093">fspace_fit_B_factor</a> (double res_hi=0)</td></tr>
<tr class="memdesc:af9ea5aed3caede8ae6e6e223adf35093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the overall B-factor of an image.  <a href="class_bimage.html#af9ea5aed3caede8ae6e6e223adf35093">More...</a><br /></td></tr>
<tr class="separator:af9ea5aed3caede8ae6e6e223adf35093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac65275f18cb7d8ffa4e11acdc15e10d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aac65275f18cb7d8ffa4e11acdc15e10d">fspace_weigh_ramp</a> (double resolution, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="memdesc:aac65275f18cb7d8ffa4e11acdc15e10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs a transform with a ramp.  <a href="class_bimage.html#aac65275f18cb7d8ffa4e11acdc15e10d">More...</a><br /></td></tr>
<tr class="separator:aac65275f18cb7d8ffa4e11acdc15e10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c972326ebd2d236ec0fcdbc4b0cc5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a73c972326ebd2d236ec0fcdbc4b0cc5a">fspace_weigh_ramp</a> (double resolution, double axis, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="memdesc:a73c972326ebd2d236ec0fcdbc4b0cc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs a transform with a ramp.  <a href="class_bimage.html#a73c972326ebd2d236ec0fcdbc4b0cc5a">More...</a><br /></td></tr>
<tr class="separator:a73c972326ebd2d236ec0fcdbc4b0cc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f04e97a5999c7e83e130768c25d583"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a12f04e97a5999c7e83e130768c25d583">fspace_weigh_B_factor</a> (double B, double resolution=0)</td></tr>
<tr class="memdesc:a12f04e97a5999c7e83e130768c25d583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs an image's amplitudes with B-factor (gaussian) curve.  <a href="class_bimage.html#a12f04e97a5999c7e83e130768c25d583">More...</a><br /></td></tr>
<tr class="separator:a12f04e97a5999c7e83e130768c25d583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242ffe8b2a4bcc216ae00afb86daca1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a242ffe8b2a4bcc216ae00afb86daca1d">fspace_weigh_C_curve</a> (double resolution=0)</td></tr>
<tr class="memdesc:a242ffe8b2a4bcc216ae00afb86daca1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs an image's amplitudes with the carbon scattering curve.  <a href="class_bimage.html#a242ffe8b2a4bcc216ae00afb86daca1d">More...</a><br /></td></tr>
<tr class="separator:a242ffe8b2a4bcc216ae00afb86daca1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda57b400f1708167f2c7e64a60eb78b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afda57b400f1708167f2c7e64a60eb78b">fspace_weigh_LoG</a> (double resolution, double sigma)</td></tr>
<tr class="memdesc:afda57b400f1708167f2c7e64a60eb78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs an image's amplitudes with a Laplacian-of-Gaussian function.  <a href="class_bimage.html#afda57b400f1708167f2c7e64a60eb78b">More...</a><br /></td></tr>
<tr class="separator:afda57b400f1708167f2c7e64a60eb78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7decddf1751331d158e46c8eaefef00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac7decddf1751331d158e46c8eaefef00">fspace_weigh_RPS_curve</a> (<a class="el" href="class_bplot.html">Bplot</a> *<a class="el" href="class_bimage.html#a43916985ee29b7482e3d0bbcd97b68b7">plot</a>, double resolution=0)</td></tr>
<tr class="memdesc:ac7decddf1751331d158e46c8eaefef00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs an image's amplitudes with a given RPS curve.  <a href="class_bimage.html#ac7decddf1751331d158e46c8eaefef00">More...</a><br /></td></tr>
<tr class="separator:ac7decddf1751331d158e46c8eaefef00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3729092a9a3df3b1c98ebe7ef91fdfa3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3729092a9a3df3b1c98ebe7ef91fdfa3">fspace_weigh_FSC_curve</a> (<a class="el" href="class_bplot.html">Bplot</a> *<a class="el" href="class_bimage.html#a43916985ee29b7482e3d0bbcd97b68b7">plot</a>, double resolution=0)</td></tr>
<tr class="memdesc:a3729092a9a3df3b1c98ebe7ef91fdfa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs an image's amplitudes with a given FSC curve.  <a href="class_bimage.html#a3729092a9a3df3b1c98ebe7ef91fdfa3">More...</a><br /></td></tr>
<tr class="separator:a3729092a9a3df3b1c98ebe7ef91fdfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2204b62b851a229a9c2cb3489052ae88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2204b62b851a229a9c2cb3489052ae88">fspace_weigh_gaussian</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; sigma, int dir=0)</td></tr>
<tr class="memdesc:a2204b62b851a229a9c2cb3489052ae88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs an image's amplitudes with an anisotropic Gaussian function.  <a href="class_bimage.html#a2204b62b851a229a9c2cb3489052ae88">More...</a><br /></td></tr>
<tr class="separator:a2204b62b851a229a9c2cb3489052ae88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4009dab9defb1ef39feb77371124422f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4009dab9defb1ef39feb77371124422f">fspace_gradient</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; sigma)</td></tr>
<tr class="memdesc:a4009dab9defb1ef39feb77371124422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a image with orthogonal gradients encded in 3-value vectors.  <a href="class_bimage.html#a4009dab9defb1ef39feb77371124422f">More...</a><br /></td></tr>
<tr class="separator:a4009dab9defb1ef39feb77371124422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56288e974c1a25f146ccd97eb44df38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac56288e974c1a25f146ccd97eb44df38">fspace_weigh</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double resolution=0)</td></tr>
<tr class="memdesc:ac56288e974c1a25f146ccd97eb44df38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs an image's amplitudes with the radial power spectrum of another.  <a href="class_bimage.html#ac56288e974c1a25f146ccd97eb44df38">More...</a><br /></td></tr>
<tr class="separator:ac56288e974c1a25f146ccd97eb44df38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede6de7cbd6febba8dcfde126a052c40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aede6de7cbd6febba8dcfde126a052c40">fspace_weigh_dose</a> (long nn, double dose_per_frame, vector&lt; double &gt; critdose)</td></tr>
<tr class="separator:aede6de7cbd6febba8dcfde126a052c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5148c88a8ffafddb8fef3f10f29b2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2a5148c88a8ffafddb8fef3f10f29b2d">fspace_weigh_dose</a> (double dose_per_frame, int flag=0)</td></tr>
<tr class="memdesc:a2a5148c88a8ffafddb8fef3f10f29b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs an image's amplitudes with the accumulated dose.  <a href="class_bimage.html#a2a5148c88a8ffafddb8fef3f10f29b2d">More...</a><br /></td></tr>
<tr class="separator:a2a5148c88a8ffafddb8fef3f10f29b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf9851313f15f0e59a4b5c14ed4fc99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2bf9851313f15f0e59a4b5c14ed4fc99">fspace_weigh_accumulated_dose</a> (vector&lt; double &gt; dose)</td></tr>
<tr class="memdesc:a2bf9851313f15f0e59a4b5c14ed4fc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighs an image's amplitudes with the accumulated dose.  <a href="class_bimage.html#a2bf9851313f15f0e59a4b5c14ed4fc99">More...</a><br /></td></tr>
<tr class="separator:a2bf9851313f15f0e59a4b5c14ed4fc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06dc3d6c69b51aea7926b530e8f963ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a06dc3d6c69b51aea7926b530e8f963ec">fspace_normalize</a> ()</td></tr>
<tr class="memdesc:a06dc3d6c69b51aea7926b530e8f963ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes an image's amplitudes.  <a href="class_bimage.html#a06dc3d6c69b51aea7926b530e8f963ec">More...</a><br /></td></tr>
<tr class="separator:a06dc3d6c69b51aea7926b530e8f963ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71a5271e9a56028d01378519f152970"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad71a5271e9a56028d01378519f152970">fspace_normalize_radial</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, double resolution=0, int flag=0)</td></tr>
<tr class="memdesc:ad71a5271e9a56028d01378519f152970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes an image's amplitudes.  <a href="class_bimage.html#ad71a5271e9a56028d01378519f152970">More...</a><br /></td></tr>
<tr class="separator:ad71a5271e9a56028d01378519f152970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e641a765529eca00a388d3ccda2c5e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3e641a765529eca00a388d3ccda2c5e9">fspace_positive</a> ()</td></tr>
<tr class="memdesc:a3e641a765529eca00a388d3ccda2c5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the image to positive definite.  <a href="class_bimage.html#a3e641a765529eca00a388d3ccda2c5e9">More...</a><br /></td></tr>
<tr class="separator:a3e641a765529eca00a388d3ccda2c5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e43e43ac9ae08e0a28564decbf278d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad6e43e43ac9ae08e0a28564decbf278d">friedel_check</a> ()</td></tr>
<tr class="memdesc:ad6e43e43ac9ae08e0a28564decbf278d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks Friedel symmetry.  <a href="class_bimage.html#ad6e43e43ac9ae08e0a28564decbf278d">More...</a><br /></td></tr>
<tr class="separator:ad6e43e43ac9ae08e0a28564decbf278d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6c1ccff23519853d4e246d60e7c5c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6b6c1ccff23519853d4e246d60e7c5c2">friedel_apply</a> ()</td></tr>
<tr class="memdesc:a6b6c1ccff23519853d4e246d60e7c5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies Friedel symmetry.  <a href="class_bimage.html#a6b6c1ccff23519853d4e246d60e7c5c2">More...</a><br /></td></tr>
<tr class="separator:a6b6c1ccff23519853d4e246d60e7c5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afcc68b536924539893afa7797d9ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4afcc68b536924539893afa7797d9ff0">project</a> (char axis, int flags=1)</td></tr>
<tr class="memdesc:a4afcc68b536924539893afa7797d9ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects a 3D image to a 2D image down one of the three major axes.  <a href="class_bimage.html#a4afcc68b536924539893afa7797d9ff0">More...</a><br /></td></tr>
<tr class="separator:a4afcc68b536924539893afa7797d9ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dea162b89d48d12f9f29f757a299e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa6dea162b89d48d12f9f29f757a299e3">rotate_project</a> (<a class="el" href="class_matrix3.html">Matrix3</a> mat, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; translate, double radial_cutoff, int norm_flag=1)</td></tr>
<tr class="memdesc:aa6dea162b89d48d12f9f29f757a299e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates a 3D map and projects it along the z-axis.  <a href="class_bimage.html#aa6dea162b89d48d12f9f29f757a299e3">More...</a><br /></td></tr>
<tr class="separator:aa6dea162b89d48d12f9f29f757a299e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27d43f0379945a6d3fc67f8bfd7d895"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab27d43f0379945a6d3fc67f8bfd7d895">project</a> (<a class="el" href="class_view.html">View</a> *<a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>, int norm_flag=1)</td></tr>
<tr class="memdesc:ab27d43f0379945a6d3fc67f8bfd7d895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a set of projections from a 3D density map.  <a href="class_bimage.html#ab27d43f0379945a6d3fc67f8bfd7d895">More...</a><br /></td></tr>
<tr class="separator:ab27d43f0379945a6d3fc67f8bfd7d895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f48665392f5a455d8afa04f14c1c98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af6f48665392f5a455d8afa04f14c1c98">central_section</a> (<a class="el" href="class_matrix3.html">Matrix3</a> mat, double resolution, <a class="el" href="class_f_s_i___kernel.html">FSI_Kernel</a> *<a class="el" href="structkernel.html">kernel</a>, double wavelength=0)</td></tr>
<tr class="memdesc:af6f48665392f5a455d8afa04f14c1c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a central section of a 3D fourier transform.  <a href="class_bimage.html#af6f48665392f5a455d8afa04f14c1c98">More...</a><br /></td></tr>
<tr class="separator:af6f48665392f5a455d8afa04f14c1c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bf9144645aff8e54e84a345e5170bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a32bf9144645aff8e54e84a345e5170bf">project</a> (<a class="el" href="class_view.html">View</a> *<a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>, double resolution, <a class="el" href="class_f_s_i___kernel.html">FSI_Kernel</a> *<a class="el" href="structkernel.html">kernel</a>, double wavelength=0)</td></tr>
<tr class="memdesc:a32bf9144645aff8e54e84a345e5170bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a set of projections as central sections from a 3D fourier transform.  <a href="class_bimage.html#a32bf9144645aff8e54e84a345e5170bf">More...</a><br /></td></tr>
<tr class="separator:a32bf9144645aff8e54e84a345e5170bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa6013e0f403993b7dde45889a0e0ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aaaa6013e0f403993b7dde45889a0e0ef">back_project</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double resolution, double axis, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="separator:aaaa6013e0f403993b7dde45889a0e0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d625d181159abc9d151369048f20733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2d625d181159abc9d151369048f20733">resolution_prepare</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="separator:a2d625d181159abc9d151369048f20733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebfb1d152e36bd7aaf0b7549ba7bc6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aeebfb1d152e36bd7aaf0b7549ba7bc6e">resolution_prepare</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> plan)</td></tr>
<tr class="separator:aeebfb1d152e36bd7aaf0b7549ba7bc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53929c5258e3e6d2301375781bf3704b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a53929c5258e3e6d2301375781bf3704b">fsc_dpr</a> (double hi_res, double sampling_ratio=1, int flag=0)</td></tr>
<tr class="memdesc:a53929c5258e3e6d2301375781bf3704b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an FSC and DPR curves from two images.  <a href="class_bimage.html#a53929c5258e3e6d2301375781bf3704b">More...</a><br /></td></tr>
<tr class="separator:a53929c5258e3e6d2301375781bf3704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e604cb03f66a11a174eff259bb6f54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa2e604cb03f66a11a174eff259bb6f54">fsc</a> (double hi_res, double sampling_ratio=1)</td></tr>
<tr class="separator:aa2e604cb03f66a11a174eff259bb6f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae84c0a38fd631080656901ef9468f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aae84c0a38fd631080656901ef9468f8d">fsc</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double hi_res, double sampling_ratio=1)</td></tr>
<tr class="separator:aae84c0a38fd631080656901ef9468f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e64a59b52e430a10cee5540c0024940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8e64a59b52e430a10cee5540c0024940">fsc_shell</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double hi_res, double *cutoff, int <a class="el" href="class_bimage.html#a960a7f0cde5092bb23f788c359c5388a">thickness</a>, int step, int minrad, int maxrad, int <a class="el" href="class_bimage.html#a130d1713a0034d563b93034b05680768">pad</a>=1, int smooth=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a8e64a59b52e430a10cee5540c0024940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the resolution for each concentric shell in a map.  <a href="class_bimage.html#a8e64a59b52e430a10cee5540c0024940">More...</a><br /></td></tr>
<tr class="separator:a8e64a59b52e430a10cee5540c0024940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dad3f53957a2ae41c2665080274cbd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5dad3f53957a2ae41c2665080274cbd7">fsc_local</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double resolution, double *cutoff, int mask_level, int <a class="el" href="class_bimage.html#aa73f430809a61cffcf9313c60a417090">size</a>, int <a class="el" href="class_bimage.html#a130d1713a0034d563b93034b05680768">pad</a>, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; vedge, int step=1, int taper=1, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a5dad3f53957a2ae41c2665080274cbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the local resolution at each masked voxel in a map.  <a href="class_bimage.html#a5dad3f53957a2ae41c2665080274cbd7">More...</a><br /></td></tr>
<tr class="separator:a5dad3f53957a2ae41c2665080274cbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9fe1dc8d2129d9407528f6f65eeb02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5a9fe1dc8d2129d9407528f6f65eeb02">local_filter</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, int mask_level, <a class="el" href="class_bimage.html">Bimage</a> *resmap, int <a class="el" href="class_bimage.html#aa73f430809a61cffcf9313c60a417090">size</a>, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; vedge)</td></tr>
<tr class="memdesc:a5a9fe1dc8d2129d9407528f6f65eeb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a local resolution filter to a map.  <a href="class_bimage.html#a5a9fe1dc8d2129d9407528f6f65eeb02">More...</a><br /></td></tr>
<tr class="separator:a5a9fe1dc8d2129d9407528f6f65eeb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe39f90afbe00c91da38a7536dc6fb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acfe39f90afbe00c91da38a7536dc6fb8">phase_difference</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, int type=0, double res_hi=0, double res_lo=0)</td></tr>
<tr class="memdesc:acfe39f90afbe00c91da38a7536dc6fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cosine of the phase difference between two images.  <a href="class_bimage.html#acfe39f90afbe00c91da38a7536dc6fb8">More...</a><br /></td></tr>
<tr class="separator:acfe39f90afbe00c91da38a7536dc6fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d72986433c77abdb1bbfef125df3cf7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0d72986433c77abdb1bbfef125df3cf7">average_phase_difference</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double res_hi, double res_lo, int weighting=1)</td></tr>
<tr class="memdesc:a0d72986433c77abdb1bbfef125df3cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the average of the absolute phase difference between two images within given resolution shells.  <a href="class_bimage.html#a0d72986433c77abdb1bbfef125df3cf7">More...</a><br /></td></tr>
<tr class="separator:a0d72986433c77abdb1bbfef125df3cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afda6e89e9c754d281e416fd0a64a1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5afda6e89e9c754d281e416fd0a64a1e">phase_flip</a> (<a class="el" href="class_bimage.html">Bimage</a> *pd)</td></tr>
<tr class="memdesc:a5afda6e89e9c754d281e416fd0a64a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the phases of an image based on a phase difference map.  <a href="class_bimage.html#a5afda6e89e9c754d281e416fd0a64a1e">More...</a><br /></td></tr>
<tr class="separator:a5afda6e89e9c754d281e416fd0a64a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4f644bac0ee94020a3143500301f73"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aed4f644bac0ee94020a3143500301f73">correlate</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:aed4f644bac0ee94020a3143500301f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates correlation coefficient between two images.  <a href="class_bimage.html#aed4f644bac0ee94020a3143500301f73">More...</a><br /></td></tr>
<tr class="separator:aed4f644bac0ee94020a3143500301f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a24a64c2a46d4e7605f46ae21c6518"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a89a24a64c2a46d4e7605f46ae21c6518">correlate</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double rmin, double rmax, <a class="el" href="class_bimage.html">Bimage</a> *pmask=NULL, int flag=0)</td></tr>
<tr class="memdesc:a89a24a64c2a46d4e7605f46ae21c6518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a correlation coefficient between two images.  <a href="class_bimage.html#a89a24a64c2a46d4e7605f46ae21c6518">More...</a><br /></td></tr>
<tr class="separator:a89a24a64c2a46d4e7605f46ae21c6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e7e96e701d68bc872693a78aa74c8f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa0e7e96e701d68bc872693a78aa74c8f">rotate_correlate</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; axis, double <a class="el" href="_vector3_8h.html#ae39c57d147eeec4507b1687fed37f53e">angle</a>)</td></tr>
<tr class="memdesc:aa0e7e96e701d68bc872693a78aa74c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates a copy of an image and correlates it with the original.  <a href="class_bimage.html#aa0e7e96e701d68bc872693a78aa74c8f">More...</a><br /></td></tr>
<tr class="separator:aa0e7e96e701d68bc872693a78aa74c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52206f5ade01f913c6c89ca6827abfec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a52206f5ade01f913c6c89ca6827abfec">R_factor</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:a52206f5ade01f913c6c89ca6827abfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an R factor between two images.  <a href="class_bimage.html#a52206f5ade01f913c6c89ca6827abfec">More...</a><br /></td></tr>
<tr class="separator:a52206f5ade01f913c6c89ca6827abfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58df899bf2137ec1046c1432d4ea0014"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a58df899bf2137ec1046c1432d4ea0014">auto_correlate</a> (double hires, double lores)</td></tr>
<tr class="memdesc:a58df899bf2137ec1046c1432d4ea0014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an autocorrelation map by Fast Fourier transformation.  <a href="class_bimage.html#a58df899bf2137ec1046c1432d4ea0014">More...</a><br /></td></tr>
<tr class="separator:a58df899bf2137ec1046c1432d4ea0014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3980b2fbc7486c0b2e5d1f0f23a527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aee3980b2fbc7486c0b2e5d1f0f23a527">cross_correlate</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double hires, double lores, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="memdesc:aee3980b2fbc7486c0b2e5d1f0f23a527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a cross-correlation map by Fast Fourier transformation.  <a href="class_bimage.html#aee3980b2fbc7486c0b2e5d1f0f23a527">More...</a><br /></td></tr>
<tr class="separator:aee3980b2fbc7486c0b2e5d1f0f23a527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f481c1c9810e140e206aae8cb243901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0f481c1c9810e140e206aae8cb243901">cross_correlate</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, <a class="el" href="class_bimage.html">Bimage</a> *pmask=NULL)</td></tr>
<tr class="separator:a0f481c1c9810e140e206aae8cb243901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733932c8d5fe80fb2d9677e1052f53e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a733932c8d5fe80fb2d9677e1052f53e7">cross_correlate</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double hires, double lores, <a class="el" href="class_bimage.html">Bimage</a> *pmask=NULL)</td></tr>
<tr class="memdesc:a733932c8d5fe80fb2d9677e1052f53e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a cross-correlation map by Fast Fourier transformation.  <a href="class_bimage.html#a733932c8d5fe80fb2d9677e1052f53e7">More...</a><br /></td></tr>
<tr class="separator:a733932c8d5fe80fb2d9677e1052f53e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4398066bdddc4ac4723c27a3e57ce30"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab4398066bdddc4ac4723c27a3e57ce30">correlation_coefficient</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>)</td></tr>
<tr class="memdesc:ab4398066bdddc4ac4723c27a3e57ce30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a coefficient from a Fourier correlation transform given a shift.  <a href="class_bimage.html#ab4398066bdddc4ac4723c27a3e57ce30">More...</a><br /></td></tr>
<tr class="separator:ab4398066bdddc4ac4723c27a3e57ce30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f896443c7d6dcfe0674232c5fa89684"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6f896443c7d6dcfe0674232c5fa89684">find_shift_in_transform</a> (double shift_limit)</td></tr>
<tr class="memdesc:a6f896443c7d6dcfe0674232c5fa89684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the shift by brute force backtransformation for selected shifts.  <a href="class_bimage.html#a6f896443c7d6dcfe0674232c5fa89684">More...</a><br /></td></tr>
<tr class="separator:a6f896443c7d6dcfe0674232c5fa89684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c6007300a2ac6ee727bce03547aadb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a94c6007300a2ac6ee727bce03547aadb">cross_correlate_fspace</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double hires, double lores, double shift_limit)</td></tr>
<tr class="memdesc:a94c6007300a2ac6ee727bce03547aadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a cross-correlation map by Fast Fourier transformation.  <a href="class_bimage.html#a94c6007300a2ac6ee727bce03547aadb">More...</a><br /></td></tr>
<tr class="separator:a94c6007300a2ac6ee727bce03547aadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dd9d3e57b245ffbb8c6aaf071b48b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a66dd9d3e57b245ffbb8c6aaf071b48b2">cross_correlate</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double hires, double lores, <a class="el" href="class_bimage.html">Bimage</a> *pmask, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="separator:a66dd9d3e57b245ffbb8c6aaf071b48b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0623b75a864ebcc25ee4cb13cd3249"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7e0623b75a864ebcc25ee4cb13cd3249">cross_correlate_two_way</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double hires, double lores, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="memdesc:a7e0623b75a864ebcc25ee4cb13cd3249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a cross-correlation map by Fast Fourier transformation.  <a href="class_bimage.html#a7e0623b75a864ebcc25ee4cb13cd3249">More...</a><br /></td></tr>
<tr class="separator:a7e0623b75a864ebcc25ee4cb13cd3249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae039957d4ef654accb7a9d6533e207"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0ae039957d4ef654accb7a9d6533e207">cross_correlate_validate</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, <a class="el" href="class_bimage.html">Bimage</a> *pmask)</td></tr>
<tr class="memdesc:a0ae039957d4ef654accb7a9d6533e207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a masked cross-correlation map by Fast Fourier transformation.  <a href="class_bimage.html#a0ae039957d4ef654accb7a9d6533e207">More...</a><br /></td></tr>
<tr class="separator:a0ae039957d4ef654accb7a9d6533e207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7169f09ebd58457a19368b08bf994833"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7169f09ebd58457a19368b08bf994833">rotate_cross_correlate</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, <a class="el" href="class_view.html">View</a> <a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>, double hires, double lores, double search_radius, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double &amp;cc, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="separator:a7169f09ebd58457a19368b08bf994833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5f4a66f61f68ea7af007429c246baa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7f5f4a66f61f68ea7af007429c246baa">rotate_cross_correlate_two_way</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, double <a class="el" href="_vector3_8h.html#ae39c57d147eeec4507b1687fed37f53e">angle</a>, double res_hi, double res_lo, double shift_limit, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="separator:a7f5f4a66f61f68ea7af007429c246baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b98ed9bd3b989b31defd06c1eb027a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a73b98ed9bd3b989b31defd06c1eb027a">find_shift</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double hires, double lores, double radius, double sigma, int refine_flag)</td></tr>
<tr class="memdesc:a73b98ed9bd3b989b31defd06c1eb027a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a cross-correlation map to find the shift for the pair of images.  <a href="class_bimage.html#a73b98ed9bd3b989b31defd06c1eb027a">More...</a><br /></td></tr>
<tr class="separator:a73b98ed9bd3b989b31defd06c1eb027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47921af3160535f94f3060a87524ad6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a47921af3160535f94f3060a87524ad6a">find_shift</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double hires, double lores, double radius, double sigma, int refine_flag, double &amp;cc)</td></tr>
<tr class="separator:a47921af3160535f94f3060a87524ad6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574db68f6ca4c87c9854e1e4355c36ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a574db68f6ca4c87c9854e1e4355c36ce">find_shift</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, double hires, double lores, double radius, double sigma, int refine_flag, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="memdesc:a574db68f6ca4c87c9854e1e4355c36ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a cross-correlation map to find the shift for the pair of images.  <a href="class_bimage.html#a574db68f6ca4c87c9854e1e4355c36ce">More...</a><br /></td></tr>
<tr class="separator:a574db68f6ca4c87c9854e1e4355c36ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c36d9cb08f5525ff89f3c27ef1b763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae0c36d9cb08f5525ff89f3c27ef1b763">find_shift</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double hires, double lores, double radius, double sigma, int refine_flag, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>, double &amp;cc)</td></tr>
<tr class="memdesc:ae0c36d9cb08f5525ff89f3c27ef1b763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a cross-correlation map to find the shift for the pair of images.  <a href="class_bimage.html#ae0c36d9cb08f5525ff89f3c27ef1b763">More...</a><br /></td></tr>
<tr class="separator:ae0c36d9cb08f5525ff89f3c27ef1b763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c9aed8bf9257e2d04101cc548d20ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af9c9aed8bf9257e2d04101cc548d20ca">find_shift</a> (long nn, <a class="el" href="class_bimage.html">Bimage</a> *pref, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double hi_res, double lo_res, double shift_limit, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="memdesc:af9c9aed8bf9257e2d04101cc548d20ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a cross-correlation map to find the shift for the pair of images.  <a href="class_bimage.html#af9c9aed8bf9257e2d04101cc548d20ca">More...</a><br /></td></tr>
<tr class="separator:af9c9aed8bf9257e2d04101cc548d20ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cdf739a9bc772b13b7a7ca95753dbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a78cdf739a9bc772b13b7a7ca95753dbd">find_template</a> (<a class="el" href="class_bimage.html">Bimage</a> *ptemp, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double hires, double lores, int bin, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="memdesc:a78cdf739a9bc772b13b7a7ca95753dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds one or more matches to a template.  <a href="class_bimage.html#a78cdf739a9bc772b13b7a7ca95753dbd">More...</a><br /></td></tr>
<tr class="separator:a78cdf739a9bc772b13b7a7ca95753dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7447cd808d862a6f5cedf597ebc4bdbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7447cd808d862a6f5cedf597ebc4bdbf">find_center</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, double hires, double lores, double radius, double sigma, int refine_flag)</td></tr>
<tr class="memdesc:a7447cd808d862a6f5cedf597ebc4bdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the center of mass of an image by cross-correlation with its inverse.  <a href="class_bimage.html#a7447cd808d862a6f5cedf597ebc4bdbf">More...</a><br /></td></tr>
<tr class="separator:a7447cd808d862a6f5cedf597ebc4bdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e061b02110ae259864ad686a234038"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae5e061b02110ae259864ad686a234038">rotate_find_shift</a> (<a class="el" href="class_matrix3.html">Matrix3</a> mat, double hires, double lores, double radius, double sigma, int refine_flag, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>, double &amp;cc)</td></tr>
<tr class="memdesc:ae5e061b02110ae259864ad686a234038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates and find shift by cross-correlation.  <a href="class_bimage.html#ae5e061b02110ae259864ad686a234038">More...</a><br /></td></tr>
<tr class="separator:ae5e061b02110ae259864ad686a234038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daa0d26e64c9e49ddb2a0cc14e8c2d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2daa0d26e64c9e49ddb2a0cc14e8c2d0">find_peak</a> (double radius=1e30, double sigma=0)</td></tr>
<tr class="memdesc:a2daa0d26e64c9e49ddb2a0cc14e8c2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the peak in an image to the nearest voxel.  <a href="class_bimage.html#a2daa0d26e64c9e49ddb2a0cc14e8c2d0">More...</a><br /></td></tr>
<tr class="separator:a2daa0d26e64c9e49ddb2a0cc14e8c2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be0b064eefaf517f0158b05a0d61bd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8be0b064eefaf517f0158b05a0d61bd1">fit_peak</a> ()</td></tr>
<tr class="memdesc:a8be0b064eefaf517f0158b05a0d61bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fits an elliptic parabole to locate the position of the peak to sub-voxel resolution.  <a href="class_bimage.html#a8be0b064eefaf517f0158b05a0d61bd1">More...</a><br /></td></tr>
<tr class="separator:a8be0b064eefaf517f0158b05a0d61bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8655ec31cdfa4008f2cd15e5810300b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae8655ec31cdfa4008f2cd15e5810300b">refine_peak_new</a> ()</td></tr>
<tr class="memdesc:ae8655ec31cdfa4008f2cd15e5810300b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines the position of a peak to sub-voxel resolution.  <a href="class_bimage.html#ae8655ec31cdfa4008f2cd15e5810300b">More...</a><br /></td></tr>
<tr class="separator:ae8655ec31cdfa4008f2cd15e5810300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fab637fb5be036d3821df66f90559ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0fab637fb5be036d3821df66f90559ba">refine_peak</a> ()</td></tr>
<tr class="memdesc:a0fab637fb5be036d3821df66f90559ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines the position of a peak to sub-voxel resolution.  <a href="class_bimage.html#a0fab637fb5be036d3821df66f90559ba">More...</a><br /></td></tr>
<tr class="separator:a0fab637fb5be036d3821df66f90559ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d7ab7027984b63c96e3f9f6ba4ee7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a29d7ab7027984b63c96e3f9f6ba4ee7a">find_peaks</a> (long kernelsize)</td></tr>
<tr class="memdesc:a29d7ab7027984b63c96e3f9f6ba4ee7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds peaks in a map with periodic boundaries.  <a href="class_bimage.html#a29d7ab7027984b63c96e3f9f6ba4ee7a">More...</a><br /></td></tr>
<tr class="separator:a29d7ab7027984b63c96e3f9f6ba4ee7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b849fa786ec2cf1d144ca94bf46f7f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4b849fa786ec2cf1d144ca94bf46f7f3">find_peaks</a> (double excl_dist, long &amp;ncoor, double &amp;threshold_min, double &amp;threshold_max, double pix_min=2, double pix_max=10)</td></tr>
<tr class="memdesc:a4b849fa786ec2cf1d144ca94bf46f7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the peaks in a cross-correlation map to find template matches.  <a href="class_bimage.html#a4b849fa786ec2cf1d144ca94bf46f7f3">More...</a><br /></td></tr>
<tr class="separator:a4b849fa786ec2cf1d144ca94bf46f7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8c89d040e7a16ababdcb654433ef39"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abe8c89d040e7a16ababdcb654433ef39">ccmap_confidence</a> (long nn)</td></tr>
<tr class="memdesc:abe8c89d040e7a16ababdcb654433ef39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a confidence level to associate with a cross-correlation peak.  <a href="class_bimage.html#abe8c89d040e7a16ababdcb654433ef39">More...</a><br /></td></tr>
<tr class="separator:abe8c89d040e7a16ababdcb654433ef39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200da2cfe749e4702e39b95e3128355f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a200da2cfe749e4702e39b95e3128355f">peak_sigma</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; coor, long kernel_size)</td></tr>
<tr class="memdesc:a200da2cfe749e4702e39b95e3128355f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a sigma value for a cross-correlation peak.  <a href="class_bimage.html#a200da2cfe749e4702e39b95e3128355f">More...</a><br /></td></tr>
<tr class="separator:a200da2cfe749e4702e39b95e3128355f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6eeb216ad95114a41546c5f948661e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1d6eeb216ad95114a41546c5f948661e">search_views</a> (<a class="el" href="class_bimage.html">Bimage</a> *ptemp, <a class="el" href="class_view.html">View</a> *<a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>, double hires, double lores, double search_radius, <a class="el" href="class_bimage.html">Bimage</a> *pmask, <a class="el" href="class_view.html">View</a> &amp;currview, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; &amp;currshift)</td></tr>
<tr class="memdesc:a1d6eeb216ad95114a41546c5f948661e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a 2D/3D density map for a template.  <a href="class_bimage.html#a1d6eeb216ad95114a41546c5f948661e">More...</a><br /></td></tr>
<tr class="separator:a1d6eeb216ad95114a41546c5f948661e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac6c12ee2b9faa6521107716e981814"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5ac6c12ee2b9faa6521107716e981814">search_volume_view</a> (<a class="el" href="class_bimage.html">Bimage</a> *ptemp, <a class="el" href="class_view.html">View</a> <a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>, double hires, double lores, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double threshold, <a class="el" href="class_bimage.html">Bimage</a> *pfit)</td></tr>
<tr class="memdesc:a5ac6c12ee2b9faa6521107716e981814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a 2D/3D density map for a template using a specific view.  <a href="class_bimage.html#a5ac6c12ee2b9faa6521107716e981814">More...</a><br /></td></tr>
<tr class="separator:a5ac6c12ee2b9faa6521107716e981814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce30d7a0b92b8e8886a19be03e23eff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7ce30d7a0b92b8e8886a19be03e23eff">search_volume</a> (<a class="el" href="class_bimage.html">Bimage</a> *ptemp, <a class="el" href="class_view.html">View</a> *<a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>, double alpha, double alpha_step, double hires, double lores, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double threshold)</td></tr>
<tr class="memdesc:a7ce30d7a0b92b8e8886a19be03e23eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a 2D/3D density map for a template.  <a href="class_bimage.html#a7ce30d7a0b92b8e8886a19be03e23eff">More...</a><br /></td></tr>
<tr class="separator:a7ce30d7a0b92b8e8886a19be03e23eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3de86725584217217b4ab919ef3dcdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad3de86725584217217b4ab919ef3dcdb">find_shift_in_transform</a> (long nn, <a class="el" href="class_bimage.html">Bimage</a> *pref, double shift_limit)</td></tr>
<tr class="separator:ad3de86725584217217b4ab919ef3dcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79aa0e953c56c5ce8e1a1498f386751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa79aa0e953c56c5ce8e1a1498f386751">align_progressive_fast</a> (long nref, double shift_limit)</td></tr>
<tr class="memdesc:aa79aa0e953c56c5ce8e1a1498f386751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns and sums a set of sub-images using a progressive algorithm.  <a href="class_bimage.html#aa79aa0e953c56c5ce8e1a1498f386751">More...</a><br /></td></tr>
<tr class="separator:aa79aa0e953c56c5ce8e1a1498f386751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91803c287ab037bc7a3c403291acc2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa91803c287ab037bc7a3c403291acc2f">align_progressive</a> (long nref, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double hi_res, double lo_res, double shift_limit, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="memdesc:aa91803c287ab037bc7a3c403291acc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns and sums a set of sub-images using a progressive algorithm.  <a href="class_bimage.html#aa91803c287ab037bc7a3c403291acc2f">More...</a><br /></td></tr>
<tr class="separator:aa91803c287ab037bc7a3c403291acc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc989995479711dd10761d2f7385a3e"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4fc989995479711dd10761d2f7385a3e">align</a> (long ref_num, long window, long step, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double hi_res, double lo_res, double shift_limit, double edge_width, double gauss_width, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; bin)</td></tr>
<tr class="memdesc:a4fc989995479711dd10761d2f7385a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns and sums a set of sub-images, first progressively and then iteratively.  <a href="class_bimage.html#a4fc989995479711dd10761d2f7385a3e">More...</a><br /></td></tr>
<tr class="separator:a4fc989995479711dd10761d2f7385a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91286dc4862354d4dd617144e6fa8e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_j_svalue.html">JSvalue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac91286dc4862354d4dd617144e6fa8e1">align_fast</a> (long ref_num, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double hi_res, double lo_res, double shift_limit, double edge_width, double gauss_width)</td></tr>
<tr class="memdesc:ac91286dc4862354d4dd617144e6fa8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns and sums a set of sub-images, first progressively and then iteratively.  <a href="class_bimage.html#ac91286dc4862354d4dd617144e6fa8e1">More...</a><br /></td></tr>
<tr class="separator:ac91286dc4862354d4dd617144e6fa8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cb4ca59bac82d6f9bc9986d82a889c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa7cb4ca59bac82d6f9bc9986d82a889c">fspace_sum</a> (int <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>=0)</td></tr>
<tr class="separator:aa7cb4ca59bac82d6f9bc9986d82a889c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280a87db787ad7c6827de67227a6117c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a280a87db787ad7c6827de67227a6117c">fspace_shift_sum</a> ()</td></tr>
<tr class="separator:a280a87db787ad7c6827de67227a6117c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbe36e9969106b1a0761da10681f30b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1dbe36e9969106b1a0761da10681f30b">fspace_subset_sums</a> (int subset, int flag=0)</td></tr>
<tr class="separator:a1dbe36e9969106b1a0761da10681f30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08afff70db68ac0b93636087899d6992"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a08afff70db68ac0b93636087899d6992">fspace_ssnr</a> (long nimg, double res_hi, double sampling_ratio)</td></tr>
<tr class="separator:a08afff70db68ac0b93636087899d6992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cd9416f78181f8d911f70be238ba6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa7cd9416f78181f8d911f70be238ba6c">fspace_subset_ssnr</a> (int subset, double res_hi, double sampling_ratio, int flag=0)</td></tr>
<tr class="separator:aa7cd9416f78181f8d911f70be238ba6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116466a5ea13f35a581948624a4697ce"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a116466a5ea13f35a581948624a4697ce">correlate_annuli</a> (<a class="el" href="class_bimage.html">Bimage</a> *polref, int ann_min, int ann_max, double ang_min, double ang_max, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>, double &amp;cc_max)</td></tr>
<tr class="memdesc:a116466a5ea13f35a581948624a4697ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlate annuli of a polar image.  <a href="class_bimage.html#a116466a5ea13f35a581948624a4697ce">More...</a><br /></td></tr>
<tr class="separator:a116466a5ea13f35a581948624a4697ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed27819fb8388ae6954898e8c5aeea9"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abed27819fb8388ae6954898e8c5aeea9">pps_angular_correlation</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, double res_hi, double res_lo, long nang, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>)</td></tr>
<tr class="separator:abed27819fb8388ae6954898e8c5aeea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7765f966cffac40807eb001959fa28"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afd7765f966cffac40807eb001959fa28">align2D_pps</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, double res_hi, double res_lo, double shift_limit, double angle_limit, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>)</td></tr>
<tr class="memdesc:afd7765f966cffac40807eb001959fa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best in-plane alignment for two 2D images using polar power spectra.  <a href="class_bimage.html#afd7765f966cffac40807eb001959fa28">More...</a><br /></td></tr>
<tr class="separator:afd7765f966cffac40807eb001959fa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceb1c51aa8f8a520fea19befa25b313"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7ceb1c51aa8f8a520fea19befa25b313">align2D</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, double res_polar, int ann_min, int ann_max, <a class="el" href="class_bimage.html">Bimage</a> *prs_mask, double shift_limit, double angle_limit, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> planf_1D, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> planb_1D, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> planf_2D, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> planb_2D)</td></tr>
<tr class="memdesc:a7ceb1c51aa8f8a520fea19befa25b313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best in-plane alignment for two 2D images using polar power spectra.  <a href="class_bimage.html#a7ceb1c51aa8f8a520fea19befa25b313">More...</a><br /></td></tr>
<tr class="separator:a7ceb1c51aa8f8a520fea19befa25b313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4243b9407c5220fabf6f7c23b16d999"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab4243b9407c5220fabf6f7c23b16d999">align2D</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, int ann_min, int ann_max, double res_lo, double res_hi, double shift_limit, double angle_limit)</td></tr>
<tr class="memdesc:ab4243b9407c5220fabf6f7c23b16d999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best in-plane alignment for two 2D images using polar power spectra.  <a href="class_bimage.html#ab4243b9407c5220fabf6f7c23b16d999">More...</a><br /></td></tr>
<tr class="separator:ab4243b9407c5220fabf6f7c23b16d999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc8731d276675569a09899fe294cb52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aafc8731d276675569a09899fe294cb52">simple_to_rgb</a> ()</td></tr>
<tr class="memdesc:aafc8731d276675569a09899fe294cb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple image is converted to a color image.  <a href="class_bimage.html#aafc8731d276675569a09899fe294cb52">More...</a><br /></td></tr>
<tr class="separator:aafc8731d276675569a09899fe294cb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288b49e2101c603a259453e74f8fb9ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a288b49e2101c603a259453e74f8fb9ee">simple_to_rgba</a> ()</td></tr>
<tr class="memdesc:a288b49e2101c603a259453e74f8fb9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple image is converted to a color image.  <a href="class_bimage.html#a288b49e2101c603a259453e74f8fb9ee">More...</a><br /></td></tr>
<tr class="separator:a288b49e2101c603a259453e74f8fb9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7280ee72a088440e3d190ed9203afe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab7280ee72a088440e3d190ed9203afe8">color_to_simple</a> ()</td></tr>
<tr class="memdesc:ab7280ee72a088440e3d190ed9203afe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A color image is converted to a simple image.  <a href="class_bimage.html#ab7280ee72a088440e3d190ed9203afe8">More...</a><br /></td></tr>
<tr class="separator:ab7280ee72a088440e3d190ed9203afe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7ab28a033eb07c2c62b38044affdfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0c7ab28a033eb07c2c62b38044affdfa">rgb_to_rgba</a> ()</td></tr>
<tr class="memdesc:a0c7ab28a033eb07c2c62b38044affdfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alpha channel is added to a <a class="el" href="class_r_g_b.html">RGB</a> color image.  <a href="class_bimage.html#a0c7ab28a033eb07c2c62b38044affdfa">More...</a><br /></td></tr>
<tr class="separator:a0c7ab28a033eb07c2c62b38044affdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a75c617a560025a571c7635b7f015a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a99a75c617a560025a571c7635b7f015a">rgba_to_rgb</a> ()</td></tr>
<tr class="memdesc:a99a75c617a560025a571c7635b7f015a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alpha channel is delete from an <a class="el" href="class_r_g_b_a.html">RGBA</a> color image.  <a href="class_bimage.html#a99a75c617a560025a571c7635b7f015a">More...</a><br /></td></tr>
<tr class="separator:a99a75c617a560025a571c7635b7f015a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66b4728fbd4a4338eb41ab606915fb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae66b4728fbd4a4338eb41ab606915fb4">rgb_to_cmyk</a> ()</td></tr>
<tr class="memdesc:ae66b4728fbd4a4338eb41ab606915fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="class_r_g_b.html">RGB</a> color image to <a class="el" href="class_c_m_y_k.html">CMYK</a>.  <a href="class_bimage.html#ae66b4728fbd4a4338eb41ab606915fb4">More...</a><br /></td></tr>
<tr class="separator:ae66b4728fbd4a4338eb41ab606915fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0de82e5c0833c271bbda9847f8cbe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9e0de82e5c0833c271bbda9847f8cbe2">cmyk_to_rgb</a> ()</td></tr>
<tr class="memdesc:a9e0de82e5c0833c271bbda9847f8cbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="class_c_m_y_k.html">CMYK</a> color image to <a class="el" href="class_r_g_b.html">RGB</a>.  <a href="class_bimage.html#a9e0de82e5c0833c271bbda9847f8cbe2">More...</a><br /></td></tr>
<tr class="separator:a9e0de82e5c0833c271bbda9847f8cbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80baea1fc2db2bac3aa5837f7396c0d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a80baea1fc2db2bac3aa5837f7396c0d4">one_color</a> (int color, double cmin, double cmax, int flag=0)</td></tr>
<tr class="memdesc:a80baea1fc2db2bac3aa5837f7396c0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a gray-scale image to a single color.  <a href="class_bimage.html#a80baea1fc2db2bac3aa5837f7396c0d4">More...</a><br /></td></tr>
<tr class="separator:a80baea1fc2db2bac3aa5837f7396c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb6e880fab0904b9702007876322ab6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abfb6e880fab0904b9702007876322ab6">color_red</a> (double cmin, double cmax, int flag=0)</td></tr>
<tr class="memdesc:abfb6e880fab0904b9702007876322ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a gray-scale image to red.  <a href="class_bimage.html#abfb6e880fab0904b9702007876322ab6">More...</a><br /></td></tr>
<tr class="separator:abfb6e880fab0904b9702007876322ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644d535bf1c94569270c32f4d0c0ef40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a644d535bf1c94569270c32f4d0c0ef40">color_green</a> (double cmin, double cmax, int flag=0)</td></tr>
<tr class="memdesc:a644d535bf1c94569270c32f4d0c0ef40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a gray-scale image to green.  <a href="class_bimage.html#a644d535bf1c94569270c32f4d0c0ef40">More...</a><br /></td></tr>
<tr class="separator:a644d535bf1c94569270c32f4d0c0ef40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2898f1eaaf5f0236e239fe49494849d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa2898f1eaaf5f0236e239fe49494849d">color_blue</a> (double cmin, double cmax, int flag=0)</td></tr>
<tr class="memdesc:aa2898f1eaaf5f0236e239fe49494849d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a gray-scale image to blue.  <a href="class_bimage.html#aa2898f1eaaf5f0236e239fe49494849d">More...</a><br /></td></tr>
<tr class="separator:aa2898f1eaaf5f0236e239fe49494849d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c60d383d623215c7803246f91a37c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a82c60d383d623215c7803246f91a37c3">pure_color</a> ()</td></tr>
<tr class="memdesc:a82c60d383d623215c7803246f91a37c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a pure color image without intensity.  <a href="class_bimage.html#a82c60d383d623215c7803246f91a37c3">More...</a><br /></td></tr>
<tr class="separator:a82c60d383d623215c7803246f91a37c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab143e87ca8f289a3ea65566a4c77fbb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab143e87ca8f289a3ea65566a4c77fbb0">color_combine</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:ab143e87ca8f289a3ea65566a4c77fbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two colored images.  <a href="class_bimage.html#ab143e87ca8f289a3ea65566a4c77fbb0">More...</a><br /></td></tr>
<tr class="separator:ab143e87ca8f289a3ea65566a4c77fbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cb2a5aa2fc05dc884221e6cc3e7c28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac8cb2a5aa2fc05dc884221e6cc3e7c28">color_spectrum</a> (double cmin, double cmax)</td></tr>
<tr class="memdesc:ac8cb2a5aa2fc05dc884221e6cc3e7c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colorizes an image to a spectrum.  <a href="class_bimage.html#ac8cb2a5aa2fc05dc884221e6cc3e7c28">More...</a><br /></td></tr>
<tr class="separator:ac8cb2a5aa2fc05dc884221e6cc3e7c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b36e3e577be485764fd630ed6cd4134"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5b36e3e577be485764fd630ed6cd4134">red_white_blue</a> (double red_min, double white_min, double white_max, double blue_max)</td></tr>
<tr class="memdesc:a5b36e3e577be485764fd630ed6cd4134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colorizes an image with blue positive and red negative.  <a href="class_bimage.html#a5b36e3e577be485764fd630ed6cd4134">More...</a><br /></td></tr>
<tr class="separator:a5b36e3e577be485764fd630ed6cd4134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7833cb5588bdc30b2a46f45eaf3224"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9b7833cb5588bdc30b2a46f45eaf3224">rescale</a> (double scale, double <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>)</td></tr>
<tr class="memdesc:a9b7833cb5588bdc30b2a46f45eaf3224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the image data with a given multiplier and offset.  <a href="class_bimage.html#a9b7833cb5588bdc30b2a46f45eaf3224">More...</a><br /></td></tr>
<tr class="separator:a9b7833cb5588bdc30b2a46f45eaf3224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a76e101fc59bdcabd5f3bb4299955e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac4a76e101fc59bdcabd5f3bb4299955e">rescale</a> (long nn, double scale, double <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>)</td></tr>
<tr class="memdesc:ac4a76e101fc59bdcabd5f3bb4299955e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the image data with a given multiplier and offset.  <a href="class_bimage.html#ac4a76e101fc59bdcabd5f3bb4299955e">More...</a><br /></td></tr>
<tr class="separator:ac4a76e101fc59bdcabd5f3bb4299955e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5bdce631807ed399818c368aa246f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6a5bdce631807ed399818c368aa246f4">rescale_to_min_max</a> (double numin, double numax)</td></tr>
<tr class="memdesc:a6a5bdce631807ed399818c368aa246f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the image data to a given minimum and maximum.  <a href="class_bimage.html#a6a5bdce631807ed399818c368aa246f4">More...</a><br /></td></tr>
<tr class="separator:a6a5bdce631807ed399818c368aa246f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86c101a63bbebc20a1a83b359e4c898"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae86c101a63bbebc20a1a83b359e4c898">rescale_to_min_max</a> (long nn, double numin, double numax)</td></tr>
<tr class="memdesc:ae86c101a63bbebc20a1a83b359e4c898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the image data to a given minimum and maximum.  <a href="class_bimage.html#ae86c101a63bbebc20a1a83b359e4c898">More...</a><br /></td></tr>
<tr class="separator:ae86c101a63bbebc20a1a83b359e4c898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa480cb0fa61541df90440f2e929142ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa480cb0fa61541df90440f2e929142ce">rescale_to_avg_std</a> (double nuavg, double nustd)</td></tr>
<tr class="memdesc:aa480cb0fa61541df90440f2e929142ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the image data to a given average and standard deviation.  <a href="class_bimage.html#aa480cb0fa61541df90440f2e929142ce">More...</a><br /></td></tr>
<tr class="separator:aa480cb0fa61541df90440f2e929142ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda4a7e4de4efa8b83f0a1ef6445da09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abda4a7e4de4efa8b83f0a1ef6445da09">rescale_to_avg_std</a> (long nn, double nuavg, double nustd)</td></tr>
<tr class="memdesc:abda4a7e4de4efa8b83f0a1ef6445da09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the image data to a given average and standard deviation.  <a href="class_bimage.html#abda4a7e4de4efa8b83f0a1ef6445da09">More...</a><br /></td></tr>
<tr class="separator:abda4a7e4de4efa8b83f0a1ef6445da09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3199a5d7bb5c9ea9fcd544e67dff6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ace3199a5d7bb5c9ea9fcd544e67dff6b">rescale_to_avg_std</a> (double nuavg, double nustd, <a class="el" href="class_bimage.html">Bimage</a> *pmask)</td></tr>
<tr class="memdesc:ace3199a5d7bb5c9ea9fcd544e67dff6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the image data to a given average and standard deviation.  <a href="class_bimage.html#ace3199a5d7bb5c9ea9fcd544e67dff6b">More...</a><br /></td></tr>
<tr class="separator:ace3199a5d7bb5c9ea9fcd544e67dff6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55253f5cbc24af2d07edf348d81772cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a55253f5cbc24af2d07edf348d81772cb">truncate</a> (double minim, double maxim, double setmin, double setmax)</td></tr>
<tr class="memdesc:a55253f5cbc24af2d07edf348d81772cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates image data to a given minimum and maximum.  <a href="class_bimage.html#a55253f5cbc24af2d07edf348d81772cb">More...</a><br /></td></tr>
<tr class="separator:a55253f5cbc24af2d07edf348d81772cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0112a4c9c0d3c8dcd41b17f540584517"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0112a4c9c0d3c8dcd41b17f540584517">truncate_to_min_max</a> (double minim, double maxim)</td></tr>
<tr class="memdesc:a0112a4c9c0d3c8dcd41b17f540584517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates image data to a given minimum and maximum.  <a href="class_bimage.html#a0112a4c9c0d3c8dcd41b17f540584517">More...</a><br /></td></tr>
<tr class="separator:a0112a4c9c0d3c8dcd41b17f540584517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972a0567449bfb9aff48b05aafec5c7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a972a0567449bfb9aff48b05aafec5c7e">truncate_to_avg</a> (double minim, double maxim)</td></tr>
<tr class="memdesc:a972a0567449bfb9aff48b05aafec5c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets voxels in image data exceeding a given minimum and maximum to the average.  <a href="class_bimage.html#a972a0567449bfb9aff48b05aafec5c7e">More...</a><br /></td></tr>
<tr class="separator:a972a0567449bfb9aff48b05aafec5c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76678f39fb8dc645ec3d54d9494db3d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a76678f39fb8dc645ec3d54d9494db3d9">truncate_to_background</a> (double minim, double maxim)</td></tr>
<tr class="memdesc:a76678f39fb8dc645ec3d54d9494db3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets voxels in image data exceeding a given minimum and maximum to the image background.  <a href="class_bimage.html#a76678f39fb8dc645ec3d54d9494db3d9">More...</a><br /></td></tr>
<tr class="separator:a76678f39fb8dc645ec3d54d9494db3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a2c7e875d850bfd0dbc3e46b9ea998"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a10a2c7e875d850bfd0dbc3e46b9ea998">limit_levels</a> (int nlevels)</td></tr>
<tr class="memdesc:a10a2c7e875d850bfd0dbc3e46b9ea998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a full gray scale image to a limited level image.  <a href="class_bimage.html#a10a2c7e875d850bfd0dbc3e46b9ea998">More...</a><br /></td></tr>
<tr class="separator:a10a2c7e875d850bfd0dbc3e46b9ea998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3eb1f754594a556d8a2d43a074b91a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#add3eb1f754594a556d8a2d43a074b91a">normalize</a> (long imgnum, double <a class="el" href="class_bimage.html#a8b7559f244271ee490d3746da9a02378">average</a>, double stdev, int norm_type, long bins)</td></tr>
<tr class="memdesc:add3eb1f754594a556d8a2d43a074b91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a sub-image to a desired average and standard deviation.  <a href="class_bimage.html#add3eb1f754594a556d8a2d43a074b91a">More...</a><br /></td></tr>
<tr class="separator:add3eb1f754594a556d8a2d43a074b91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6cf645edf16da07022babcacf20692"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9b6cf645edf16da07022babcacf20692">normalize</a> (double <a class="el" href="class_bimage.html#a8b7559f244271ee490d3746da9a02378">average</a>, double stdev, int norm_type)</td></tr>
<tr class="memdesc:a9b6cf645edf16da07022babcacf20692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a set of images to a desired average and standard deviation.  <a href="class_bimage.html#a9b6cf645edf16da07022babcacf20692">More...</a><br /></td></tr>
<tr class="separator:a9b6cf645edf16da07022babcacf20692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d99849ef19cf0e3af2adeb2182ed0a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0d99849ef19cf0e3af2adeb2182ed0a2">normalize_local</a> (long kernel_size)</td></tr>
<tr class="memdesc:a0d99849ef19cf0e3af2adeb2182ed0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes by subtracting local average and dividing by local standard deviation.  <a href="class_bimage.html#a0d99849ef19cf0e3af2adeb2182ed0a2">More...</a><br /></td></tr>
<tr class="separator:a0d99849ef19cf0e3af2adeb2182ed0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673b8d495c7e50207c95034787cae2b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a673b8d495c7e50207c95034787cae2b6">normalize_local</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; <a class="el" href="structkernel.html">kernel</a>)</td></tr>
<tr class="memdesc:a673b8d495c7e50207c95034787cae2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes by subtracting local average and dividing by local standard deviation.  <a href="class_bimage.html#a673b8d495c7e50207c95034787cae2b6">More...</a><br /></td></tr>
<tr class="separator:a673b8d495c7e50207c95034787cae2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa0057b767acf23c99af72b999b5368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abaa0057b767acf23c99af72b999b5368">square</a> ()</td></tr>
<tr class="memdesc:abaa0057b767acf23c99af72b999b5368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the square of an image.  <a href="class_bimage.html#abaa0057b767acf23c99af72b999b5368">More...</a><br /></td></tr>
<tr class="separator:abaa0057b767acf23c99af72b999b5368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7411e52811a3b4f86631e89f3a19da2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7411e52811a3b4f86631e89f3a19da2e">square_root</a> ()</td></tr>
<tr class="memdesc:a7411e52811a3b4f86631e89f3a19da2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the square root of an image.  <a href="class_bimage.html#a7411e52811a3b4f86631e89f3a19da2e">More...</a><br /></td></tr>
<tr class="separator:a7411e52811a3b4f86631e89f3a19da2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e71e8fb84408cc791660173295d23d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6e71e8fb84408cc791660173295d23d9">logarithm</a> ()</td></tr>
<tr class="memdesc:a6e71e8fb84408cc791660173295d23d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the logarithm of the image data.  <a href="class_bimage.html#a6e71e8fb84408cc791660173295d23d9">More...</a><br /></td></tr>
<tr class="separator:a6e71e8fb84408cc791660173295d23d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71f57ecd1286f7194495e506bb3b6cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae71f57ecd1286f7194495e506bb3b6cc">exponential</a> ()</td></tr>
<tr class="memdesc:ae71f57ecd1286f7194495e506bb3b6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the exponential of the image data.  <a href="class_bimage.html#ae71f57ecd1286f7194495e506bb3b6cc">More...</a><br /></td></tr>
<tr class="separator:ae71f57ecd1286f7194495e506bb3b6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a98004da23cb718e3e039f2ae130f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a92a98004da23cb718e3e039f2ae130f9">gradient_correction</a> ()</td></tr>
<tr class="memdesc:a92a98004da23cb718e3e039f2ae130f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and corrects for a linear gradient across an image.  <a href="class_bimage.html#a92a98004da23cb718e3e039f2ae130f9">More...</a><br /></td></tr>
<tr class="separator:a92a98004da23cb718e3e039f2ae130f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0022ff9560c5435a775b17cda6859d21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0022ff9560c5435a775b17cda6859d21">quadric_correct</a> (vector&lt; double &gt; param)</td></tr>
<tr class="memdesc:a0022ff9560c5435a775b17cda6859d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corrects for a quadric surface.  <a href="class_bimage.html#a0022ff9560c5435a775b17cda6859d21">More...</a><br /></td></tr>
<tr class="separator:a0022ff9560c5435a775b17cda6859d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4374a6540837e7e0fb667ade95387125"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4374a6540837e7e0fb667ade95387125">quadric_fit</a> ()</td></tr>
<tr class="memdesc:a4374a6540837e7e0fb667ade95387125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fits the whole image to a quadric surface.  <a href="class_bimage.html#a4374a6540837e7e0fb667ade95387125">More...</a><br /></td></tr>
<tr class="separator:a4374a6540837e7e0fb667ade95387125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960a7f0cde5092bb23f788c359c5388a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a960a7f0cde5092bb23f788c359c5388a">thickness</a> (double reference, double emfp)</td></tr>
<tr class="memdesc:a960a7f0cde5092bb23f788c359c5388a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a thickness based on intensities with respect to a reference.  <a href="class_bimage.html#a960a7f0cde5092bb23f788c359c5388a">More...</a><br /></td></tr>
<tr class="separator:a960a7f0cde5092bb23f788c359c5388a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eca04ce6fa6cbd93a59ed0bb0474e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac1eca04ce6fa6cbd93a59ed0bb0474e0">calculate_background</a> (long nn, int flag)</td></tr>
<tr class="memdesc:ac1eca04ce6fa6cbd93a59ed0bb0474e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the background for one sub-image.  <a href="class_bimage.html#ac1eca04ce6fa6cbd93a59ed0bb0474e0">More...</a><br /></td></tr>
<tr class="separator:ac1eca04ce6fa6cbd93a59ed0bb0474e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fbcdfea888cba3b6891cb7c0685077"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a86fbcdfea888cba3b6891cb7c0685077">calculate_background</a> (int flag=0)</td></tr>
<tr class="memdesc:a86fbcdfea888cba3b6891cb7c0685077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the background for each sub-image.  <a href="class_bimage.html#a86fbcdfea888cba3b6891cb7c0685077">More...</a><br /></td></tr>
<tr class="separator:a86fbcdfea888cba3b6891cb7c0685077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad111b7044a4c05761f372ce2f5688ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aad111b7044a4c05761f372ce2f5688ae">calculate_background</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, long nn, int flag=0)</td></tr>
<tr class="memdesc:aad111b7044a4c05761f372ce2f5688ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the background for one sub-image.  <a href="class_bimage.html#aad111b7044a4c05761f372ce2f5688ae">More...</a><br /></td></tr>
<tr class="separator:aad111b7044a4c05761f372ce2f5688ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7535de626d0c458869842fe6379a9ba5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7535de626d0c458869842fe6379a9ba5">calculate_background</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, int flag=0)</td></tr>
<tr class="memdesc:a7535de626d0c458869842fe6379a9ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the background for each sub-image.  <a href="class_bimage.html#a7535de626d0c458869842fe6379a9ba5">More...</a><br /></td></tr>
<tr class="separator:a7535de626d0c458869842fe6379a9ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c22f850dcdc8bef046cb78707ac808"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab4c22f850dcdc8bef046cb78707ac808">correct_background</a> (long nn, int flag)</td></tr>
<tr class="memdesc:ab4c22f850dcdc8bef046cb78707ac808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corrects the background for one sub-image.  <a href="class_bimage.html#ab4c22f850dcdc8bef046cb78707ac808">More...</a><br /></td></tr>
<tr class="separator:ab4c22f850dcdc8bef046cb78707ac808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae097d0c9a4d324888c4225f6dc64eff5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae097d0c9a4d324888c4225f6dc64eff5">correct_background</a> (int flag=0)</td></tr>
<tr class="memdesc:ae097d0c9a4d324888c4225f6dc64eff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corrects the background for each sub-image.  <a href="class_bimage.html#ae097d0c9a4d324888c4225f6dc64eff5">More...</a><br /></td></tr>
<tr class="separator:ae097d0c9a4d324888c4225f6dc64eff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60f07470d38a7a7c791741e14b81792"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa60f07470d38a7a7c791741e14b81792">correct_background</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, int flag=0)</td></tr>
<tr class="memdesc:aa60f07470d38a7a7c791741e14b81792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corrects the background for each sub-image.  <a href="class_bimage.html#aa60f07470d38a7a7c791741e14b81792">More...</a><br /></td></tr>
<tr class="separator:aa60f07470d38a7a7c791741e14b81792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb34c252e6a493a4672317f6790c6bfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abb34c252e6a493a4672317f6790c6bfc">subtract_background</a> ()</td></tr>
<tr class="memdesc:abb34c252e6a493a4672317f6790c6bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the background for each sub-image.  <a href="class_bimage.html#abb34c252e6a493a4672317f6790c6bfc">More...</a><br /></td></tr>
<tr class="separator:abb34c252e6a493a4672317f6790c6bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45890e60f74185ddfc88080dcbeda69e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a45890e60f74185ddfc88080dcbeda69e">shift_background</a> (double bkg)</td></tr>
<tr class="memdesc:a45890e60f74185ddfc88080dcbeda69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the background for each sub-image to a given value.  <a href="class_bimage.html#a45890e60f74185ddfc88080dcbeda69e">More...</a><br /></td></tr>
<tr class="separator:a45890e60f74185ddfc88080dcbeda69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85f1d0fdde7701db60b1b62833ffefd"><td class="memItemLeft" align="right" valign="top">vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab85f1d0fdde7701db60b1b62833ffefd">histogram</a> (long bins, double &amp;scale, double &amp;offset)</td></tr>
<tr class="memdesc:ab85f1d0fdde7701db60b1b62833ffefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the histogram of an image.  <a href="class_bimage.html#ab85f1d0fdde7701db60b1b62833ffefd">More...</a><br /></td></tr>
<tr class="separator:ab85f1d0fdde7701db60b1b62833ffefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bde5665ebee734c283db7db9c99b74f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6bde5665ebee734c283db7db9c99b74f">histogram</a> (long bins)</td></tr>
<tr class="memdesc:a6bde5665ebee734c283db7db9c99b74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the histogram of an image.  <a href="class_bimage.html#a6bde5665ebee734c283db7db9c99b74f">More...</a><br /></td></tr>
<tr class="separator:a6bde5665ebee734c283db7db9c99b74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2eff813946f4af3af738ae4bfd4f0b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa2eff813946f4af3af738ae4bfd4f0b9">histogram_counts</a> (int flags=0)</td></tr>
<tr class="memdesc:aa2eff813946f4af3af738ae4bfd4f0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the peaks in a quantized image from the histogram.  <a href="class_bimage.html#aa2eff813946f4af3af738ae4bfd4f0b9">More...</a><br /></td></tr>
<tr class="separator:aa2eff813946f4af3af738ae4bfd4f0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5664a095dcb822b3236ccfcc2b7165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aaf5664a095dcb822b3236ccfcc2b7165">percentiles</a> ()</td></tr>
<tr class="memdesc:aaf5664a095dcb822b3236ccfcc2b7165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the percentiles from the histogram of an image.  <a href="class_bimage.html#aaf5664a095dcb822b3236ccfcc2b7165">More...</a><br /></td></tr>
<tr class="separator:aaf5664a095dcb822b3236ccfcc2b7165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7b63e6c18d1efbd0e152a9d88aaa47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aad7b63e6c18d1efbd0e152a9d88aaa47">histogram_minmax</a> (double &amp;tmin, double &amp;tmax)</td></tr>
<tr class="memdesc:aad7b63e6c18d1efbd0e152a9d88aaa47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates minimum and maximum thresholds for truncation.  <a href="class_bimage.html#aad7b63e6c18d1efbd0e152a9d88aaa47">More...</a><br /></td></tr>
<tr class="separator:aad7b63e6c18d1efbd0e152a9d88aaa47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17118ec3a626445c87adb236a8fd69ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a17118ec3a626445c87adb236a8fd69ca">histogram_otsu_variance</a> (long bins)</td></tr>
<tr class="memdesc:a17118ec3a626445c87adb236a8fd69ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inter-set variance of the bisection of a historgram using the method of Otsu.  <a href="class_bimage.html#a17118ec3a626445c87adb236a8fd69ca">More...</a><br /></td></tr>
<tr class="separator:a17118ec3a626445c87adb236a8fd69ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cdfb0e8c07177ab797bfacd8cf7136"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a89cdfb0e8c07177ab797bfacd8cf7136">otsu_threshold</a> (long bins)</td></tr>
<tr class="memdesc:a89cdfb0e8c07177ab797bfacd8cf7136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the threshold from a histogram according to Otsu.  <a href="class_bimage.html#a89cdfb0e8c07177ab797bfacd8cf7136">More...</a><br /></td></tr>
<tr class="separator:a89cdfb0e8c07177ab797bfacd8cf7136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1320da7a667791d7caf69d8de5f334"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8a1320da7a667791d7caf69d8de5f334">otsu_variance</a> (vector&lt; long &gt; h)</td></tr>
<tr class="memdesc:a8a1320da7a667791d7caf69d8de5f334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inter-set variance of the bisection of a historgram using the method of Otsu.  <a href="class_bimage.html#a8a1320da7a667791d7caf69d8de5f334">More...</a><br /></td></tr>
<tr class="separator:a8a1320da7a667791d7caf69d8de5f334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee47d4e71e12e5d0572b3d57dbc048"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a24ee47d4e71e12e5d0572b3d57dbc048">histogram_multi_thresholds</a> (long bins, long number)</td></tr>
<tr class="memdesc:a24ee47d4e71e12e5d0572b3d57dbc048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates multiple thresholds from a histogram.  <a href="class_bimage.html#a24ee47d4e71e12e5d0572b3d57dbc048">More...</a><br /></td></tr>
<tr class="separator:a24ee47d4e71e12e5d0572b3d57dbc048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0ea79752667dd909d5becad0eec7ae"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6d0ea79752667dd909d5becad0eec7ae">histogram_gauss_fit</a> (long bins, long ngauss=1)</td></tr>
<tr class="memdesc:a6d0ea79752667dd909d5becad0eec7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fits a gaussian function to a histogram of an image.  <a href="class_bimage.html#a6d0ea79752667dd909d5becad0eec7ae">More...</a><br /></td></tr>
<tr class="separator:a6d0ea79752667dd909d5becad0eec7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf99ed74e096630cc1d98601ae73d6b"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aacf99ed74e096630cc1d98601ae73d6b">histogram_gauss_fit2</a> (long bins, long ngauss=1)</td></tr>
<tr class="separator:aacf99ed74e096630cc1d98601ae73d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3183f34921b1302daac2ef214bd0fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae3183f34921b1302daac2ef214bd0fbf">histogram_gauss_plot</a> (long bins, long ngauss=1)</td></tr>
<tr class="memdesc:ae3183f34921b1302daac2ef214bd0fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fits a gaussian function to a histogram of an image.  <a href="class_bimage.html#ae3183f34921b1302daac2ef214bd0fbf">More...</a><br /></td></tr>
<tr class="separator:ae3183f34921b1302daac2ef214bd0fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab66dfa88e4a41d2c23d6ce3dc50b1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1ab66dfa88e4a41d2c23d6ce3dc50b1e">histogram_poisson_fit</a> (long bins, int flag=0)</td></tr>
<tr class="memdesc:a1ab66dfa88e4a41d2c23d6ce3dc50b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fits a poisson function to a histogram of an image.  <a href="class_bimage.html#a1ab66dfa88e4a41d2c23d6ce3dc50b1e">More...</a><br /></td></tr>
<tr class="separator:a1ab66dfa88e4a41d2c23d6ce3dc50b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92d1c8b78e7032d0810e50691308d6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa92d1c8b78e7032d0810e50691308d6a">resize</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; translate, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:aa92d1c8b78e7032d0810e50691308d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes without interpolation or rescaling.  <a href="class_bimage.html#aa92d1c8b78e7032d0810e50691308d6a">More...</a><br /></td></tr>
<tr class="separator:aa92d1c8b78e7032d0810e50691308d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceac93b83e083d4149e77dc87b21d468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aceac93b83e083d4149e77dc87b21d468">resize_copy</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; translate, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:aceac93b83e083d4149e77dc87b21d468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes without interpolation or rescaling.  <a href="class_bimage.html#aceac93b83e083d4149e77dc87b21d468">More...</a><br /></td></tr>
<tr class="separator:aceac93b83e083d4149e77dc87b21d468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6f5ec793f21d082df60e9365eeb417"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9e6f5ec793f21d082df60e9365eeb417">resize_wrap</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; translate)</td></tr>
<tr class="memdesc:a9e6f5ec793f21d082df60e9365eeb417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes without interpolation or rescaling.  <a href="class_bimage.html#a9e6f5ec793f21d082df60e9365eeb417">More...</a><br /></td></tr>
<tr class="separator:a9e6f5ec793f21d082df60e9365eeb417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ad16a7706778bce66dc7caf93ceea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a34ad16a7706778bce66dc7caf93ceea0">resize_wrap_copy</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; translate)</td></tr>
<tr class="memdesc:a34ad16a7706778bce66dc7caf93ceea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes with wrapping without interpolation or rescaling.  <a href="class_bimage.html#a34ad16a7706778bce66dc7caf93ceea0">More...</a><br /></td></tr>
<tr class="separator:a34ad16a7706778bce66dc7caf93ceea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130d1713a0034d563b93034b05680768"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a130d1713a0034d563b93034b05680768">pad</a> (long sz, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a130d1713a0034d563b93034b05680768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pads an image to a new size with a given fill value.  <a href="class_bimage.html#a130d1713a0034d563b93034b05680768">More...</a><br /></td></tr>
<tr class="separator:a130d1713a0034d563b93034b05680768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7768e1c67e5fcb2a57d36878003b93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8f7768e1c67e5fcb2a57d36878003b93">pad</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; sz, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a8f7768e1c67e5fcb2a57d36878003b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pads an image to a new size with a given fill value.  <a href="class_bimage.html#a8f7768e1c67e5fcb2a57d36878003b93">More...</a><br /></td></tr>
<tr class="separator:a8f7768e1c67e5fcb2a57d36878003b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211fe34d03f455a6da9ffae457618b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a211fe34d03f455a6da9ffae457618b29">pad_copy</a> (long sz, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a211fe34d03f455a6da9ffae457618b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pads an image to a new size with a given fill value.  <a href="class_bimage.html#a211fe34d03f455a6da9ffae457618b29">More...</a><br /></td></tr>
<tr class="separator:a211fe34d03f455a6da9ffae457618b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7d060153f985a71eb45ce5dd52ed5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2a7d060153f985a71eb45ce5dd52ed5a">pad_copy</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; sz, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a2a7d060153f985a71eb45ce5dd52ed5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pads an image to a new size with a given fill value.  <a href="class_bimage.html#a2a7d060153f985a71eb45ce5dd52ed5a">More...</a><br /></td></tr>
<tr class="separator:a2a7d060153f985a71eb45ce5dd52ed5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf488f62aca81f8ec7d4835c97103bc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abf488f62aca81f8ec7d4835c97103bc8">shrink_wrap</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; translate)</td></tr>
<tr class="memdesc:abf488f62aca81f8ec7d4835c97103bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks an image to a new size with wrapping of the excluded edges.  <a href="class_bimage.html#abf488f62aca81f8ec7d4835c97103bc8">More...</a><br /></td></tr>
<tr class="separator:abf488f62aca81f8ec7d4835c97103bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5bcb6486e3258d8d7f4df3ab61081d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ade5bcb6486e3258d8d7f4df3ab61081d">enlarge</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; scale)</td></tr>
<tr class="memdesc:ade5bcb6486e3258d8d7f4df3ab61081d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enlarges an image by an inetger scale.  <a href="class_bimage.html#ade5bcb6486e3258d8d7f4df3ab61081d">More...</a><br /></td></tr>
<tr class="separator:ade5bcb6486e3258d8d7f4df3ab61081d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de7d9fd87a5c93d12ae9e9366e33b7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3de7d9fd87a5c93d12ae9e9366e33b7a">montage</a> (int first, int cols, int rows, int skip=0, int flipy=0)</td></tr>
<tr class="memdesc:a3de7d9fd87a5c93d12ae9e9366e33b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges an image into a montage of 2D slices for display.  <a href="class_bimage.html#a3de7d9fd87a5c93d12ae9e9366e33b7a">More...</a><br /></td></tr>
<tr class="separator:a3de7d9fd87a5c93d12ae9e9366e33b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e87c1320e30753ce7e908a4ccd93b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a38e87c1320e30753ce7e908a4ccd93b6">shape</a> (int type, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; rect, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; start, double width, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a38e87c1320e30753ce7e908a4ccd93b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shape in an image and fills it with a constant value.  <a href="class_bimage.html#a38e87c1320e30753ce7e908a4ccd93b6">More...</a><br /></td></tr>
<tr class="separator:a38e87c1320e30753ce7e908a4ccd93b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5f912dd3240b4763bf53cda85da9e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8c5f912dd3240b4763bf53cda85da9e1">shape</a> (long nn, int type, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; rect, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; start, double width, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a8c5f912dd3240b4763bf53cda85da9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shape in an image and fills it with a constant value.  <a href="class_bimage.html#a8c5f912dd3240b4763bf53cda85da9e1">More...</a><br /></td></tr>
<tr class="separator:a8c5f912dd3240b4763bf53cda85da9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d059625d3892b2a07da71d3e8b400a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9d059625d3892b2a07da71d3e8b400a9">line</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; start, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; end, double width, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a9d059625d3892b2a07da71d3e8b400a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a line in an image and fills it with a constant value.  <a href="class_bimage.html#a9d059625d3892b2a07da71d3e8b400a9">More...</a><br /></td></tr>
<tr class="separator:a9d059625d3892b2a07da71d3e8b400a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647a5820a81c3ed26344e4c5540446d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a647a5820a81c3ed26344e4c5540446d8">edge_mask</a> (int type, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; rect, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; start, double width)</td></tr>
<tr class="memdesc:a647a5820a81c3ed26344e4c5540446d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mask with the edge approaching zero.  <a href="class_bimage.html#a647a5820a81c3ed26344e4c5540446d8">More...</a><br /></td></tr>
<tr class="separator:a647a5820a81c3ed26344e4c5540446d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3a7ec44e12c8449b6d6505e6b9938f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aab3a7ec44e12c8449b6d6505e6b9938f">edge</a> (int type, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; rect, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; start, double width, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:aab3a7ec44e12c8449b6d6505e6b9938f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooths the image edge with a soft rectangular function.  <a href="class_bimage.html#aab3a7ec44e12c8449b6d6505e6b9938f">More...</a><br /></td></tr>
<tr class="separator:aab3a7ec44e12c8449b6d6505e6b9938f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca127a5e81dc5a37da132f66c0747bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0ca127a5e81dc5a37da132f66c0747bf">edge</a> (long nn, int type, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; rect, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; start, double width, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a0ca127a5e81dc5a37da132f66c0747bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooths the image edge with a soft rectangular function.  <a href="class_bimage.html#a0ca127a5e81dc5a37da132f66c0747bf">More...</a><br /></td></tr>
<tr class="separator:a0ca127a5e81dc5a37da132f66c0747bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fe20c911fb2f64e13e285720a6f37c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a89fe20c911fb2f64e13e285720a6f37c">hanning_taper</a> (double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a89fe20c911fb2f64e13e285720a6f37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply Hanning taper window to the image.  <a href="class_bimage.html#a89fe20c911fb2f64e13e285720a6f37c">More...</a><br /></td></tr>
<tr class="separator:a89fe20c911fb2f64e13e285720a6f37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540ad8a401b61ff5602ffe643efc2b58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a540ad8a401b61ff5602ffe643efc2b58">sphere</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#a5f9345465a753a4ace75a2b1d7c379ba">center</a>, double radius, double width=0, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a540ad8a401b61ff5602ffe643efc2b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a sphere within an image with a uniform value.  <a href="class_bimage.html#a540ad8a401b61ff5602ffe643efc2b58">More...</a><br /></td></tr>
<tr class="separator:a540ad8a401b61ff5602ffe643efc2b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe49c9cdf6885b620cf141fb8ef081d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abfe49c9cdf6885b620cf141fb8ef081d">cylinder</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#a5f9345465a753a4ace75a2b1d7c379ba">center</a>, double radius, double <a class="el" href="class_bimage.html#a53f0e717f7eb6d7cbe3282a752872ca3">height</a>, double width, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:abfe49c9cdf6885b620cf141fb8ef081d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a cylinder within an image with a uniform value.  <a href="class_bimage.html#abfe49c9cdf6885b620cf141fb8ef081d">More...</a><br /></td></tr>
<tr class="separator:abfe49c9cdf6885b620cf141fb8ef081d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b232571fb7ecd9f8304a39fc16a5fab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8b232571fb7ecd9f8304a39fc16a5fab">gaussian_sphere</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#a5f9345465a753a4ace75a2b1d7c379ba">center</a>, double sigma, double amp)</td></tr>
<tr class="memdesc:a8b232571fb7ecd9f8304a39fc16a5fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a gaussian sphere within an image with a uniform value.  <a href="class_bimage.html#a8b232571fb7ecd9f8304a39fc16a5fab">More...</a><br /></td></tr>
<tr class="separator:a8b232571fb7ecd9f8304a39fc16a5fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb93c9e36f480a8b8c7cf40b826a37a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aafb93c9e36f480a8b8c7cf40b826a37a">shell</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#a5f9345465a753a4ace75a2b1d7c379ba">center</a>, double minrad, double maxrad, double width, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:aafb93c9e36f480a8b8c7cf40b826a37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a shell within an image with a uniform value.  <a href="class_bimage.html#aafb93c9e36f480a8b8c7cf40b826a37a">More...</a><br /></td></tr>
<tr class="separator:aafb93c9e36f480a8b8c7cf40b826a37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa909a61852ba0685fbebca6c091c667e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa909a61852ba0685fbebca6c091c667e">shell</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#a5f9345465a753a4ace75a2b1d7c379ba">center</a>, double minrad, double maxrad, double width, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:aa909a61852ba0685fbebca6c091c667e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a shell within an image with a uniform value.  <a href="class_bimage.html#aa909a61852ba0685fbebca6c091c667e">More...</a><br /></td></tr>
<tr class="separator:aa909a61852ba0685fbebca6c091c667e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d40a435fef4c6e8c9bff4bf4b4d6f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a50d40a435fef4c6e8c9bff4bf4b4d6f5">shell_wrap</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#a5f9345465a753a4ace75a2b1d7c379ba">center</a>, double minrad, double maxrad, double width, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a50d40a435fef4c6e8c9bff4bf4b4d6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a shell within an image with a uniform value with wrapping.  <a href="class_bimage.html#a50d40a435fef4c6e8c9bff4bf4b4d6f5">More...</a><br /></td></tr>
<tr class="separator:a50d40a435fef4c6e8c9bff4bf4b4d6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6e0c4b18f647d68db21c1fbbfaac3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5b6e0c4b18f647d68db21c1fbbfaac3b">bar</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; start, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; end, double width, double edge_width, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a5b6e0c4b18f647d68db21c1fbbfaac3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a bar between start and end points.  <a href="class_bimage.html#a5b6e0c4b18f647d68db21c1fbbfaac3b">More...</a><br /></td></tr>
<tr class="separator:a5b6e0c4b18f647d68db21c1fbbfaac3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637c8c9c3adab0168669c4b0a2bfe29f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a637c8c9c3adab0168669c4b0a2bfe29f">bar</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; start, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; end, double width, double edge_width, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a637c8c9c3adab0168669c4b0a2bfe29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a bar between start and end points.  <a href="class_bimage.html#a637c8c9c3adab0168669c4b0a2bfe29f">More...</a><br /></td></tr>
<tr class="separator:a637c8c9c3adab0168669c4b0a2bfe29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e05702e10a44ce4cea8cb193d892740"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3e05702e10a44ce4cea8cb193d892740">quadric</a> (double *param)</td></tr>
<tr class="memdesc:a3e05702e10a44ce4cea8cb193d892740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a quadric surface over the whole image.  <a href="class_bimage.html#a3e05702e10a44ce4cea8cb193d892740">More...</a><br /></td></tr>
<tr class="separator:a3e05702e10a44ce4cea8cb193d892740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64a1edf3326cf703a0b596059704889"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab64a1edf3326cf703a0b596059704889">chirp</a> (double freq_scale, double freq_shift=0)</td></tr>
<tr class="memdesc:ab64a1edf3326cf703a0b596059704889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a chirp image.  <a href="class_bimage.html#ab64a1edf3326cf703a0b596059704889">More...</a><br /></td></tr>
<tr class="separator:ab64a1edf3326cf703a0b596059704889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010a69d94b27256f673831bec3ede99b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a010a69d94b27256f673831bec3ede99b">fill_gaps</a> (long step)</td></tr>
<tr class="memdesc:a010a69d94b27256f673831bec3ede99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the voxels that are not calculated.  <a href="class_bimage.html#a010a69d94b27256f673831bec3ede99b">More...</a><br /></td></tr>
<tr class="separator:a010a69d94b27256f673831bec3ede99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7885caeffe8b1c90eaf9651fd575d749"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7885caeffe8b1c90eaf9651fd575d749">interpolate_gaps</a> (long step)</td></tr>
<tr class="memdesc:a7885caeffe8b1c90eaf9651fd575d749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the voxels that are not calculated.  <a href="class_bimage.html#a7885caeffe8b1c90eaf9651fd575d749">More...</a><br /></td></tr>
<tr class="separator:a7885caeffe8b1c90eaf9651fd575d749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb9247a8453a7e7907517b837d31144"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afeb9247a8453a7e7907517b837d31144">transform</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; scale, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; translate, <a class="el" href="class_matrix3.html">Matrix3</a> mat, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:afeb9247a8453a7e7907517b837d31144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms an image by translation, rotation, scaling and skewing, in place.  <a href="class_bimage.html#afeb9247a8453a7e7907517b837d31144">More...</a><br /></td></tr>
<tr class="separator:afeb9247a8453a7e7907517b837d31144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b24fc84bde3d429023c6a2d19e993b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af8b24fc84bde3d429023c6a2d19e993b">transform</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; scale, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; translate, <a class="el" href="class_matrix3.html">Matrix3</a> mat, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:af8b24fc84bde3d429023c6a2d19e993b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms an image by translation, rotation, scaling and skewing, returning a new image.  <a href="class_bimage.html#af8b24fc84bde3d429023c6a2d19e993b">More...</a><br /></td></tr>
<tr class="separator:af8b24fc84bde3d429023c6a2d19e993b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba54e71d897721376cfaab4e6c360cf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aba54e71d897721376cfaab4e6c360cf5">transform_voxel</a> (long i, <a class="el" href="class_bimage.html">Bimage</a> *pt, long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; oldorigin, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; nuorigin, <a class="el" href="class_matrix3.html">Matrix3</a> affmat, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>)</td></tr>
<tr class="separator:aba54e71d897721376cfaab4e6c360cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb5e8ee13e1fdc6ae91cf24a7b1000c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3eb5e8ee13e1fdc6ae91cf24a7b1000c">transform</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; scale, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; translate, <a class="el" href="class_matrix3.html">Matrix3</a> mat, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a3eb5e8ee13e1fdc6ae91cf24a7b1000c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a sub-image by translation, rotation, scaling and skewing, returning a single new image.  <a href="class_bimage.html#a3eb5e8ee13e1fdc6ae91cf24a7b1000c">More...</a><br /></td></tr>
<tr class="separator:a3eb5e8ee13e1fdc6ae91cf24a7b1000c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88866b740da67ec07103b1d342cc3a98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a88866b740da67ec07103b1d342cc3a98">rotate</a> ()</td></tr>
<tr class="memdesc:a88866b740da67ec07103b1d342cc3a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image using parameters defined in the image in place.  <a href="class_bimage.html#a88866b740da67ec07103b1d342cc3a98">More...</a><br /></td></tr>
<tr class="separator:a88866b740da67ec07103b1d342cc3a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27f87167748ab84725b81c74438b932"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab27f87167748ab84725b81c74438b932">rotate</a> (double <a class="el" href="_vector3_8h.html#ae39c57d147eeec4507b1687fed37f53e">angle</a>)</td></tr>
<tr class="memdesc:ab27f87167748ab84725b81c74438b932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image around the z-axis by the given angle in place.  <a href="class_bimage.html#ab27f87167748ab84725b81c74438b932">More...</a><br /></td></tr>
<tr class="separator:ab27f87167748ab84725b81c74438b932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc92a9f1c9ff02d2c22b9e7a9ffb1be4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adc92a9f1c9ff02d2c22b9e7a9ffb1be4">rotate</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; axis, double <a class="el" href="_vector3_8h.html#ae39c57d147eeec4507b1687fed37f53e">angle</a>)</td></tr>
<tr class="memdesc:adc92a9f1c9ff02d2c22b9e7a9ffb1be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image using an axis and angle in place.  <a href="class_bimage.html#adc92a9f1c9ff02d2c22b9e7a9ffb1be4">More...</a><br /></td></tr>
<tr class="separator:adc92a9f1c9ff02d2c22b9e7a9ffb1be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf45aa1df7f0171cc46ffaf00d4507a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7bf45aa1df7f0171cc46ffaf00d4507a">rotate</a> (<a class="el" href="class_view.html">View</a> <a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>)</td></tr>
<tr class="memdesc:a7bf45aa1df7f0171cc46ffaf00d4507a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image to a specified view in place.  <a href="class_bimage.html#a7bf45aa1df7f0171cc46ffaf00d4507a">More...</a><br /></td></tr>
<tr class="separator:a7bf45aa1df7f0171cc46ffaf00d4507a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c655354c84a54ec1b4bd71c8af60be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad2c655354c84a54ec1b4bd71c8af60be">rotate</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; translate, <a class="el" href="class_view.html">View</a> <a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>)</td></tr>
<tr class="memdesc:ad2c655354c84a54ec1b4bd71c8af60be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image to a specified view in place.  <a href="class_bimage.html#ad2c655354c84a54ec1b4bd71c8af60be">More...</a><br /></td></tr>
<tr class="separator:ad2c655354c84a54ec1b4bd71c8af60be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6256d410696b7e3294809706e015efe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad6256d410696b7e3294809706e015efe">rotate</a> (<a class="el" href="class_matrix3.html">Matrix3</a> mat)</td></tr>
<tr class="memdesc:ad6256d410696b7e3294809706e015efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image using the specified matrix.  <a href="class_bimage.html#ad6256d410696b7e3294809706e015efe">More...</a><br /></td></tr>
<tr class="separator:ad6256d410696b7e3294809706e015efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8847c323035bc8efc85d9f8de52baf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aac8847c323035bc8efc85d9f8de52baf">rotate</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; translate, <a class="el" href="class_matrix3.html">Matrix3</a> mat)</td></tr>
<tr class="memdesc:aac8847c323035bc8efc85d9f8de52baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image using the specified shift and matrix.  <a href="class_bimage.html#aac8847c323035bc8efc85d9f8de52baf">More...</a><br /></td></tr>
<tr class="separator:aac8847c323035bc8efc85d9f8de52baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6607d768271a95c3b9f35933e991ad2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6607d768271a95c3b9f35933e991ad2e">rotate</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize)</td></tr>
<tr class="memdesc:a6607d768271a95c3b9f35933e991ad2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image using parameters defined in the image.  <a href="class_bimage.html#a6607d768271a95c3b9f35933e991ad2e">More...</a><br /></td></tr>
<tr class="separator:a6607d768271a95c3b9f35933e991ad2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b52ec12fd191c8f312cfa658fca1ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab7b52ec12fd191c8f312cfa658fca1ba">rotate</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, double <a class="el" href="_vector3_8h.html#ae39c57d147eeec4507b1687fed37f53e">angle</a>)</td></tr>
<tr class="memdesc:ab7b52ec12fd191c8f312cfa658fca1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image around the z-axis by the given angle.  <a href="class_bimage.html#ab7b52ec12fd191c8f312cfa658fca1ba">More...</a><br /></td></tr>
<tr class="separator:ab7b52ec12fd191c8f312cfa658fca1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c535401a34f4be682c0cedc8de5237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af9c535401a34f4be682c0cedc8de5237">rotate</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; axis, double <a class="el" href="_vector3_8h.html#ae39c57d147eeec4507b1687fed37f53e">angle</a>)</td></tr>
<tr class="memdesc:af9c535401a34f4be682c0cedc8de5237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image using an axis and angle.  <a href="class_bimage.html#af9c535401a34f4be682c0cedc8de5237">More...</a><br /></td></tr>
<tr class="separator:af9c535401a34f4be682c0cedc8de5237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e899df9053f40b4f83f2f2398c79629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3e899df9053f40b4f83f2f2398c79629">rotate</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, <a class="el" href="class_view.html">View</a> <a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>)</td></tr>
<tr class="memdesc:a3e899df9053f40b4f83f2f2398c79629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image to a specified view.  <a href="class_bimage.html#a3e899df9053f40b4f83f2f2398c79629">More...</a><br /></td></tr>
<tr class="separator:a3e899df9053f40b4f83f2f2398c79629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3c27171aa545d21f78bf9053bb5055"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0e3c27171aa545d21f78bf9053bb5055">rotate</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; translate, <a class="el" href="class_view.html">View</a> <a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>)</td></tr>
<tr class="memdesc:a0e3c27171aa545d21f78bf9053bb5055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image to a specified view.  <a href="class_bimage.html#a0e3c27171aa545d21f78bf9053bb5055">More...</a><br /></td></tr>
<tr class="separator:a0e3c27171aa545d21f78bf9053bb5055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27ac57c3c18d91f290b3881d2f29d95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa27ac57c3c18d91f290b3881d2f29d95">rotate</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, <a class="el" href="class_matrix3.html">Matrix3</a> mat)</td></tr>
<tr class="memdesc:aa27ac57c3c18d91f290b3881d2f29d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image using the specified matrix.  <a href="class_bimage.html#aa27ac57c3c18d91f290b3881d2f29d95">More...</a><br /></td></tr>
<tr class="separator:aa27ac57c3c18d91f290b3881d2f29d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad873912e785241f662e91058d513cc91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad873912e785241f662e91058d513cc91">rotate_and_add</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>, <a class="el" href="class_view.html">View</a> <a class="el" href="class_bimage.html#ab474ad5f14737ab4931c0171a5d95579">view</a>)</td></tr>
<tr class="memdesc:ad873912e785241f662e91058d513cc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image to a specified view and adds it to another image.  <a href="class_bimage.html#ad873912e785241f662e91058d513cc91">More...</a><br /></td></tr>
<tr class="separator:ad873912e785241f662e91058d513cc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6011cf7fd6d019afb2c0025e949d30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9c6011cf7fd6d019afb2c0025e949d30">orient</a> (<a class="el" href="class_view.html">View</a> *views)</td></tr>
<tr class="memdesc:a9c6011cf7fd6d019afb2c0025e949d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates multiple copies oriented according to views.  <a href="class_bimage.html#a9c6011cf7fd6d019afb2c0025e949d30">More...</a><br /></td></tr>
<tr class="separator:a9c6011cf7fd6d019afb2c0025e949d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accac475d79e9c3cc1c6ebdc6f0148d69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#accac475d79e9c3cc1c6ebdc6f0148d69">mirror</a> ()</td></tr>
<tr class="memdesc:accac475d79e9c3cc1c6ebdc6f0148d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts/mirrors each image through its origin.  <a href="class_bimage.html#accac475d79e9c3cc1c6ebdc6f0148d69">More...</a><br /></td></tr>
<tr class="separator:accac475d79e9c3cc1c6ebdc6f0148d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f416c3ad809348ac75ef571b6874d99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vec, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a7f416c3ad809348ac75ef571b6874d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts an image.  <a href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">More...</a><br /></td></tr>
<tr class="separator:a7f416c3ad809348ac75ef571b6874d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35b264e07b883cb7128b9539ceb05af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa35b264e07b883cb7128b9539ceb05af">shift</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vec, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:aa35b264e07b883cb7128b9539ceb05af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts one sub-image.  <a href="class_bimage.html#aa35b264e07b883cb7128b9539ceb05af">More...</a><br /></td></tr>
<tr class="separator:aa35b264e07b883cb7128b9539ceb05af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358a46af05970ae98fe37d43333af8fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a358a46af05970ae98fe37d43333af8fb">shift_wrap</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vec)</td></tr>
<tr class="memdesc:a358a46af05970ae98fe37d43333af8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts an image.  <a href="class_bimage.html#a358a46af05970ae98fe37d43333af8fb">More...</a><br /></td></tr>
<tr class="separator:a358a46af05970ae98fe37d43333af8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215f5b8d6d4748458c05434ebd7f006b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a215f5b8d6d4748458c05434ebd7f006b">shift_wrap</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; vec)</td></tr>
<tr class="memdesc:a215f5b8d6d4748458c05434ebd7f006b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts one sub-image with wrapping.  <a href="class_bimage.html#a215f5b8d6d4748458c05434ebd7f006b">More...</a><br /></td></tr>
<tr class="separator:a215f5b8d6d4748458c05434ebd7f006b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9345465a753a4ace75a2b1d7c379ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5f9345465a753a4ace75a2b1d7c379ba">center</a> (int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a5f9345465a753a4ace75a2b1d7c379ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centers an image.  <a href="class_bimage.html#a5f9345465a753a4ace75a2b1d7c379ba">More...</a><br /></td></tr>
<tr class="separator:a5f9345465a753a4ace75a2b1d7c379ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1442cea3c82de6ac0793d38241abaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aea1442cea3c82de6ac0793d38241abaa">center_wrap</a> ()</td></tr>
<tr class="memdesc:aea1442cea3c82de6ac0793d38241abaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centers an image with wrapping.  <a href="class_bimage.html#aea1442cea3c82de6ac0793d38241abaa">More...</a><br /></td></tr>
<tr class="separator:aea1442cea3c82de6ac0793d38241abaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b57fc3c6d4e3ea245b11686bf4c8ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a32b57fc3c6d4e3ea245b11686bf4c8ae">zero_origin</a> ()</td></tr>
<tr class="memdesc:a32b57fc3c6d4e3ea245b11686bf4c8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the origins to zero with wrapping.  <a href="class_bimage.html#a32b57fc3c6d4e3ea245b11686bf4c8ae">More...</a><br /></td></tr>
<tr class="separator:a32b57fc3c6d4e3ea245b11686bf4c8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dd5f8f962afb07c80b14efbf922a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad6dd5f8f962afb07c80b14efbf922a29">reciprocal_half</a> ()</td></tr>
<tr class="separator:ad6dd5f8f962afb07c80b14efbf922a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5003afb6ec7e7d88800197dc47e4abfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5003afb6ec7e7d88800197dc47e4abfc">scale_to_same_size</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref)</td></tr>
<tr class="memdesc:a5003afb6ec7e7d88800197dc47e4abfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales and image to the given reference.  <a href="class_bimage.html#a5003afb6ec7e7d88800197dc47e4abfc">More...</a><br /></td></tr>
<tr class="separator:a5003afb6ec7e7d88800197dc47e4abfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8221a6b44bccd9fb4bd31cc31320fcaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8221a6b44bccd9fb4bd31cc31320fcaa">scale_to_reference</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, <a class="el" href="class_bimage.html">Bimage</a> *pmask, double scalemin, double scalemax, double step)</td></tr>
<tr class="memdesc:a8221a6b44bccd9fb4bd31cc31320fcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales and image to the given reference, searching for the correct scale.  <a href="class_bimage.html#a8221a6b44bccd9fb4bd31cc31320fcaa">More...</a><br /></td></tr>
<tr class="separator:a8221a6b44bccd9fb4bd31cc31320fcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7a3a7acb990d667c474c2c7d694b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afa7a3a7acb990d667c474c2c7d694b30">scale_to_reference</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, <a class="el" href="class_bimage.html">Bimage</a> *pmask=NULL)</td></tr>
<tr class="memdesc:afa7a3a7acb990d667c474c2c7d694b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales and image to the given reference, searching for the correct scale.  <a href="class_bimage.html#afa7a3a7acb990d667c474c2c7d694b30">More...</a><br /></td></tr>
<tr class="separator:afa7a3a7acb990d667c474c2c7d694b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d5028551a2b8fde28e38228f3e998b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac9d5028551a2b8fde28e38228f3e998b">symmetrize</a> (<a class="el" href="class_bstring.html">Bstring</a> &amp;symmetry_string, int flag)</td></tr>
<tr class="separator:ac9d5028551a2b8fde28e38228f3e998b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9234ec2ff8a260449cf950cdafa717a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac9234ec2ff8a260449cf950cdafa717a">symmetrize</a> (<a class="el" href="struct_bsymmetry.html">Bsymmetry</a> sym, int flag)</td></tr>
<tr class="separator:ac9234ec2ff8a260449cf950cdafa717a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb92270632a302bdf4773ee5da2be0a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adcb92270632a302bdf4773ee5da2be0a">symmetrize</a> (<a class="el" href="class_bstring.html">Bstring</a> &amp;symmetry_string, <a class="el" href="class_view.html">View</a> ref_view, int flag)</td></tr>
<tr class="separator:adcb92270632a302bdf4773ee5da2be0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9780d7cbd494044686c433a6b525b9b6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9780d7cbd494044686c433a6b525b9b6">symmetrize_cyclic</a> (int cyclic, int flag)</td></tr>
<tr class="separator:a9780d7cbd494044686c433a6b525b9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda5f353fd53c60a772c4457e6585a8b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adda5f353fd53c60a772c4457e6585a8b">symmetrize</a> (<a class="el" href="struct_bsymmetry.html">Bsymmetry</a> sym, <a class="el" href="class_view.html">View</a> ref_view, int flag)</td></tr>
<tr class="memdesc:adda5f353fd53c60a772c4457e6585a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies point group symmetry to an image.  <a href="class_bimage.html#adda5f353fd53c60a772c4457e6585a8b">More...</a><br /></td></tr>
<tr class="separator:adda5f353fd53c60a772c4457e6585a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a35640e535bfe59e5e9fbe19a7980d3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4a35640e535bfe59e5e9fbe19a7980d3">check_point_group</a> (<a class="el" href="class_bstring.html">Bstring</a> &amp;check_string)</td></tr>
<tr class="memdesc:a4a35640e535bfe59e5e9fbe19a7980d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for the requested symmetries.  <a href="class_bimage.html#a4a35640e535bfe59e5e9fbe19a7980d3">More...</a><br /></td></tr>
<tr class="separator:a4a35640e535bfe59e5e9fbe19a7980d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5260d542a8919de15b8398dfd2f90c78"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5260d542a8919de15b8398dfd2f90c78">find_cyclic_point_group</a> (<a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym, int binfac, double hires, double lores)</td></tr>
<tr class="memdesc:a5260d542a8919de15b8398dfd2f90c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the orientation for an image with a cyclic point group symmetry.  <a href="class_bimage.html#a5260d542a8919de15b8398dfd2f90c78">More...</a><br /></td></tr>
<tr class="separator:a5260d542a8919de15b8398dfd2f90c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914355785c950b3e733936a999fb155b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a914355785c950b3e733936a999fb155b">find_point_group</a> (<a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym, double angle_step, int binfac, double hires, double lores, int flags)</td></tr>
<tr class="memdesc:a914355785c950b3e733936a999fb155b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the orientation for an image with a specific point group symmetry.  <a href="class_bimage.html#a914355785c950b3e733936a999fb155b">More...</a><br /></td></tr>
<tr class="separator:a914355785c950b3e733936a999fb155b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1204e425ce7833d410445af713a8792a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1204e425ce7833d410445af713a8792a">rotate_to_axis</a> (<a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym, long axis, long axis_flag)</td></tr>
<tr class="memdesc:a1204e425ce7833d410445af713a8792a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates to a symmetry axis.  <a href="class_bimage.html#a1204e425ce7833d410445af713a8792a">More...</a><br /></td></tr>
<tr class="separator:a1204e425ce7833d410445af713a8792a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521d7a03503be2b8ec4a4090e81ada1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a521d7a03503be2b8ec4a4090e81ada1e">change_symmetry</a> (<a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;symold, <a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;symnu, double radius, double z_slope)</td></tr>
<tr class="memdesc:a521d7a03503be2b8ec4a4090e81ada1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the symmetry order for cyclic and dihedral maps.  <a href="class_bimage.html#a521d7a03503be2b8ec4a4090e81ada1e">More...</a><br /></td></tr>
<tr class="separator:a521d7a03503be2b8ec4a4090e81ada1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b10d20714d9de3585a5d17a5db6021b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9b10d20714d9de3585a5d17a5db6021b">symmetry_equivalent</a> (<a class="el" href="class_bimage.html">Bimage</a> *ptemp, <a class="el" href="class_bimage.html">Bimage</a> *pmask, <a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym)</td></tr>
<tr class="memdesc:a9b10d20714d9de3585a5d17a5db6021b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the symmetry equivalent orientation of a particle with respect to a template.  <a href="class_bimage.html#a9b10d20714d9de3585a5d17a5db6021b">More...</a><br /></td></tr>
<tr class="separator:a9b10d20714d9de3585a5d17a5db6021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441cf6a9232c52cd99f32acdb1ba905d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a441cf6a9232c52cd99f32acdb1ba905d">symmetry_equivalent_cyclic</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref, <a class="el" href="class_bimage.html">Bimage</a> *pmask, <a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym)</td></tr>
<tr class="memdesc:a441cf6a9232c52cd99f32acdb1ba905d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the cyclic symmetry equivalent orientation of a particle with respect to a template.  <a href="class_bimage.html#a441cf6a9232c52cd99f32acdb1ba905d">More...</a><br /></td></tr>
<tr class="separator:a441cf6a9232c52cd99f32acdb1ba905d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc844206e18c734ce3dc13bf775754b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adc844206e18c734ce3dc13bf775754b0">levelmask_asymmetric_units</a> (<a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym, int <a class="el" href="class_bimage.html#a760143d3cb8fd5d6e1245ecd215821a2">index</a>)</td></tr>
<tr class="memdesc:adc844206e18c734ce3dc13bf775754b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a multi-level mask to indicate asymmetric units.  <a href="class_bimage.html#adc844206e18c734ce3dc13bf775754b0">More...</a><br /></td></tr>
<tr class="separator:adc844206e18c734ce3dc13bf775754b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2051e36bed46213a60d8c727a8e4fd6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2051e36bed46213a60d8c727a8e4fd6e">replicate_asymmetric_unit</a> (<a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym)</td></tr>
<tr class="memdesc:a2051e36bed46213a60d8c727a8e4fd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a full map from one asymmetric unit.  <a href="class_bimage.html#a2051e36bed46213a60d8c727a8e4fd6e">More...</a><br /></td></tr>
<tr class="separator:a2051e36bed46213a60d8c727a8e4fd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325003555664ad5ab63d7313d15fd26e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a325003555664ad5ab63d7313d15fd26e">find_symmetric_view</a> (<a class="el" href="class_bimage.html">Bimage</a> *ptemp, <a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym, double phi_step, double theta_step, double alpha_step, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>)</td></tr>
<tr class="memdesc:a325003555664ad5ab63d7313d15fd26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the view that on symmetrizing fits best to a symmetric template. <br  />
  <a href="class_bimage.html#a325003555664ad5ab63d7313d15fd26e">More...</a><br /></td></tr>
<tr class="separator:a325003555664ad5ab63d7313d15fd26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2838d721c0aacfa1d4368509813bb1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acf2838d721c0aacfa1d4368509813bb1">helix_interpolate</a> (long i, double helix_rise, double helix_angle, int zmin, int zmax, double radius, int norm_flag=1)</td></tr>
<tr class="separator:acf2838d721c0aacfa1d4368509813bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab207c264e19d9a213331accd25de29a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab207c264e19d9a213331accd25de29a6">dyad_interpolate</a> (long i, int norm_flag=1)</td></tr>
<tr class="separator:ab207c264e19d9a213331accd25de29a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200ab278f109331849725f5398930f8e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a200ab278f109331849725f5398930f8e">tube_interpolate</a> (long i, int h, int k, double latconst, int zmin, int zmax, double radius, int norm_flag=1)</td></tr>
<tr class="separator:a200ab278f109331849725f5398930f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006beeeff826f2c0cc1842f9b0a68ff2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a006beeeff826f2c0cc1842f9b0a68ff2">helix_symmetrize</a> (double helix_rise, double helix_angle, int dyad_axis, int zmin, int zmax, double radius, int norm_flag=1)</td></tr>
<tr class="memdesc:a006beeeff826f2c0cc1842f9b0a68ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrizes an image given helical symmetry parameters.  <a href="class_bimage.html#a006beeeff826f2c0cc1842f9b0a68ff2">More...</a><br /></td></tr>
<tr class="separator:a006beeeff826f2c0cc1842f9b0a68ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b58edcb6fea8c4b1bd1ccd54790ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a45b58edcb6fea8c4b1bd1ccd54790ffd">seamed_helix_symmetrize</a> (double helix_rise, double helix_angle, double seam_shift, int dyad_axis, int zmin, int zmax, double radius, int norm_flag)</td></tr>
<tr class="memdesc:a45b58edcb6fea8c4b1bd1ccd54790ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrizes an image given helical symmetry parameters and seam shift parameter.  <a href="class_bimage.html#a45b58edcb6fea8c4b1bd1ccd54790ffd">More...</a><br /></td></tr>
<tr class="separator:a45b58edcb6fea8c4b1bd1ccd54790ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e04fb8bc837bf7f030b4fb061e1bdbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8e04fb8bc837bf7f030b4fb061e1bdbf">symmetrize_cylinder</a> (int flag)</td></tr>
<tr class="memdesc:a8e04fb8bc837bf7f030b4fb061e1bdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a cylindrically symmetrized map.  <a href="class_bimage.html#a8e04fb8bc837bf7f030b4fb061e1bdbf">More...</a><br /></td></tr>
<tr class="separator:a8e04fb8bc837bf7f030b4fb061e1bdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff0d6899e55fcad02d800f179e87e46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abff0d6899e55fcad02d800f179e87e46">symmetrize_cylinder</a> ()</td></tr>
<tr class="memdesc:abff0d6899e55fcad02d800f179e87e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a cylindrically symmetrized map.  <a href="class_bimage.html#abff0d6899e55fcad02d800f179e87e46">More...</a><br /></td></tr>
<tr class="separator:abff0d6899e55fcad02d800f179e87e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9ffa51405f1702ea3091f35fa66902"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8f9ffa51405f1702ea3091f35fa66902">tube_symmetrize</a> (int h, int k, double latconst, int zmin, int zmax, double radius, int norm_flag=1)</td></tr>
<tr class="memdesc:a8f9ffa51405f1702ea3091f35fa66902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrizes an image given tubular lattice parameters.  <a href="class_bimage.html#a8f9ffa51405f1702ea3091f35fa66902">More...</a><br /></td></tr>
<tr class="separator:a8f9ffa51405f1702ea3091f35fa66902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff64a952f50ef4f0d7752823927a842"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aaff64a952f50ef4f0d7752823927a842">convert_to_helix</a> (double helix_rise, double helix_angle, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; offset)</td></tr>
<tr class="memdesc:aaff64a952f50ef4f0d7752823927a842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a map to a helix.  <a href="class_bimage.html#aaff64a952f50ef4f0d7752823927a842">More...</a><br /></td></tr>
<tr class="separator:aaff64a952f50ef4f0d7752823927a842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a729cd6b00a8a5031ca545921e5014b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1a729cd6b00a8a5031ca545921e5014b">distort_elliptically</a> (double <a class="el" href="_vector3_8h.html#ae39c57d147eeec4507b1687fed37f53e">angle</a>, double <a class="el" href="class_bimage.html#a7f416c3ad809348ac75ef571b6874d99">shift</a>)</td></tr>
<tr class="memdesc:a1a729cd6b00a8a5031ca545921e5014b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a tubular cylinder to an elliptical profile.  <a href="class_bimage.html#a1a729cd6b00a8a5031ca545921e5014b">More...</a><br /></td></tr>
<tr class="separator:a1a729cd6b00a8a5031ca545921e5014b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7f8e0e6c7601e156216fc0552f24d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8d7f8e0e6c7601e156216fc0552f24d7">test_helix_parameters</a> (double <a class="el" href="_vector3_8h.html#ae39c57d147eeec4507b1687fed37f53e">angle</a>, double hires, double lores, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; mask_size, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; mask_start, long max_iter, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>, double &amp;cc)</td></tr>
<tr class="separator:a8d7f8e0e6c7601e156216fc0552f24d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf92f8a5678c4bf76b6b1530dc228aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acaf92f8a5678c4bf76b6b1530dc228aa">find_helix_parameters</a> (double angle_start, double angle_end, double angle_step, int bin, double hires, double lores, double radius)</td></tr>
<tr class="memdesc:acaf92f8a5678c4bf76b6b1530dc228aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best helix parameters for helical map.  <a href="class_bimage.html#acaf92f8a5678c4bf76b6b1530dc228aa">More...</a><br /></td></tr>
<tr class="separator:acaf92f8a5678c4bf76b6b1530dc228aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6a7f6c65c1e731404fee3c2fbf7336"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3d6a7f6c65c1e731404fee3c2fbf7336">test_helix_parameters</a> (double rise, double <a class="el" href="_vector3_8h.html#ae39c57d147eeec4507b1687fed37f53e">angle</a>, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; mask_size, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; mask_start)</td></tr>
<tr class="separator:a3d6a7f6c65c1e731404fee3c2fbf7336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c7c1606f1635f114b13ee6a0fa7441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac3c7c1606f1635f114b13ee6a0fa7441">find_helix_parameters</a> (double rise_start, double rise_end, double rise_step, double angle_start, double angle_end, double angle_step, int bin, double radius)</td></tr>
<tr class="memdesc:ac3c7c1606f1635f114b13ee6a0fa7441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best helix parameters for helical map.  <a href="class_bimage.html#ac3c7c1606f1635f114b13ee6a0fa7441">More...</a><br /></td></tr>
<tr class="separator:ac3c7c1606f1635f114b13ee6a0fa7441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9eb9c30f80919647fbcd1626f5c611"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2a9eb9c30f80919647fbcd1626f5c611">helix_segment_correlation_one</a> (long i, double angle_start, double angle_end, double angle_step, int bin, double hires, double lores, double radius, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a6ecaa8728bab23c3a7d96fe0cadc75f2">planf</a>, <a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> <a class="el" href="bico_8cpp.html#a9ec8849996c5e210d7b7e8e05b98639d">planb</a>, double *cc)</td></tr>
<tr class="separator:a2a9eb9c30f80919647fbcd1626f5c611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6080c797d3cb69253b985303271e080e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6080c797d3cb69253b985303271e080e">helix_segment_correlation</a> (int <a class="el" href="class_bimage.html#a960a7f0cde5092bb23f788c359c5388a">thickness</a>, double angle_start, double angle_end, double angle_step, int bin, double hires, double lores, double radius)</td></tr>
<tr class="memdesc:a6080c797d3cb69253b985303271e080e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the correlation over rotation angles between helical segments.  <a href="class_bimage.html#a6080c797d3cb69253b985303271e080e">More...</a><br /></td></tr>
<tr class="separator:a6080c797d3cb69253b985303271e080e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6ce6033d308dc4276493460266243c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3b6ce6033d308dc4276493460266243c">transform_lines</a> ()</td></tr>
<tr class="separator:a3b6ce6033d308dc4276493460266243c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce50ec5b49ecf11d7dca124c6a85b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7ce50ec5b49ecf11d7dca124c6a85b90">helical_cross_section</a> (double helix_rise, double helix_angle, double scale, double hires)</td></tr>
<tr class="memdesc:a7ce50ec5b49ecf11d7dca124c6a85b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a helical cross section from line transforms of a filament.  <a href="class_bimage.html#a7ce50ec5b49ecf11d7dca124c6a85b90">More...</a><br /></td></tr>
<tr class="separator:a7ce50ec5b49ecf11d7dca124c6a85b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af717a562427570bee1788cf53f3dc408"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af717a562427570bee1788cf53f3dc408">snvariance</a> (double snradius)</td></tr>
<tr class="memdesc:af717a562427570bee1788cf53f3dc408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the ratio of variance inside and outside a given radius.  <a href="class_bimage.html#af717a562427570bee1788cf53f3dc408">More...</a><br /></td></tr>
<tr class="separator:af717a562427570bee1788cf53f3dc408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03e8e721a1d85ad7a40d4d03d3c0574"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad03e8e721a1d85ad7a40d4d03d3c0574">extrude_cross_section</a> (long <a class="el" href="_vector3_8h.html#a7baf5ed670fcf9bcca9a3a400820e292">length</a>, double helix_rise, double helix_angle, int fill_type, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>)</td></tr>
<tr class="memdesc:ad03e8e721a1d85ad7a40d4d03d3c0574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrudes a 2D cross section into a 3D continuous helix.  <a href="class_bimage.html#ad03e8e721a1d85ad7a40d4d03d3c0574">More...</a><br /></td></tr>
<tr class="separator:ad03e8e721a1d85ad7a40d4d03d3c0574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ee26442c0bafb0b25476062545ebfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa5ee26442c0bafb0b25476062545ebfe">filament_width</a> (long width, long lim_lo, long lim_hi)</td></tr>
<tr class="memdesc:aa5ee26442c0bafb0b25476062545ebfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the width of a filament.  <a href="class_bimage.html#aa5ee26442c0bafb0b25476062545ebfe">More...</a><br /></td></tr>
<tr class="separator:aa5ee26442c0bafb0b25476062545ebfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37eb70146e2c6730f8757cb02eae628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad37eb70146e2c6730f8757cb02eae628">filament_density</a> (double width)</td></tr>
<tr class="memdesc:ad37eb70146e2c6730f8757cb02eae628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the density per pixel length of a filament.  <a href="class_bimage.html#ad37eb70146e2c6730f8757cb02eae628">More...</a><br /></td></tr>
<tr class="separator:ad37eb70146e2c6730f8757cb02eae628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba420d47cf61f7095470e8e9c2aeba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3ba420d47cf61f7095470e8e9c2aeba9">filament_from_projections</a> (double hi_res, int flag=0)</td></tr>
<tr class="memdesc:a3ba420d47cf61f7095470e8e9c2aeba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a filament from a set of projections.  <a href="class_bimage.html#a3ba420d47cf61f7095470e8e9c2aeba9">More...</a><br /></td></tr>
<tr class="separator:a3ba420d47cf61f7095470e8e9c2aeba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e58dfcfdf34ccd506bed0d3ef5b4db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7e58dfcfdf34ccd506bed0d3ef5b4db5">radial</a> (long minrad, long maxrad, double rad_step=1, int wrap=0)</td></tr>
<tr class="memdesc:a7e58dfcfdf34ccd506bed0d3ef5b4db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the radial average of an image.  <a href="class_bimage.html#a7e58dfcfdf34ccd506bed0d3ef5b4db5">More...</a><br /></td></tr>
<tr class="separator:a7e58dfcfdf34ccd506bed0d3ef5b4db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebe92011b255b290b14be60266b8632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6ebe92011b255b290b14be60266b8632">radial</a> (long minrad, long maxrad, double rad_step, <a class="el" href="class_bimage.html">Bimage</a> *pmask, int wrap=0)</td></tr>
<tr class="memdesc:a6ebe92011b255b290b14be60266b8632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the radial average of an image.  <a href="class_bimage.html#a6ebe92011b255b290b14be60266b8632">More...</a><br /></td></tr>
<tr class="separator:a6ebe92011b255b290b14be60266b8632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9873d1561805e0845a44c24cf2b4d872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9873d1561805e0845a44c24cf2b4d872">radial</a> (long minrad, long maxrad, double rad_step, double ellipticity, double <a class="el" href="_vector3_8h.html#ae39c57d147eeec4507b1687fed37f53e">angle</a>, <a class="el" href="class_bimage.html">Bimage</a> *pmask, int wrap=0)</td></tr>
<tr class="memdesc:a9873d1561805e0845a44c24cf2b4d872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the radial average of an image.  <a href="class_bimage.html#a9873d1561805e0845a44c24cf2b4d872">More...</a><br /></td></tr>
<tr class="separator:a9873d1561805e0845a44c24cf2b4d872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e666b9c155a9929050dcf4b0f339789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8e666b9c155a9929050dcf4b0f339789">radial_symmetry_adjusted</a> (double rad_start, double rad_end, double rad_step, double spherical_fraction, <a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym)</td></tr>
<tr class="memdesc:a8e666b9c155a9929050dcf4b0f339789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the symmetry-adjusted radial average of an image.  <a href="class_bimage.html#a8e666b9c155a9929050dcf4b0f339789">More...</a><br /></td></tr>
<tr class="separator:a8e666b9c155a9929050dcf4b0f339789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4764ac2099326f8550a9f85f9e8290"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adf4764ac2099326f8550a9f85f9e8290">radial_fit</a> (<a class="el" href="class_bimage.html">Bimage</a> *pref)</td></tr>
<tr class="memdesc:adf4764ac2099326f8550a9f85f9e8290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fits a radial profile to a reference radial profile.  <a href="class_bimage.html#adf4764ac2099326f8550a9f85f9e8290">More...</a><br /></td></tr>
<tr class="separator:adf4764ac2099326f8550a9f85f9e8290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f717fb32a8f0dc296581f6987e5c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a47f717fb32a8f0dc296581f6987e5c23">radial_to_full</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>)</td></tr>
<tr class="memdesc:a47f717fb32a8f0dc296581f6987e5c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a full 2D or 3D image from a radial profile in a 1D image.  <a href="class_bimage.html#a47f717fb32a8f0dc296581f6987e5c23">More...</a><br /></td></tr>
<tr class="separator:a47f717fb32a8f0dc296581f6987e5c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f15732e3911c087fbf9ed1f8762447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a09f15732e3911c087fbf9ed1f8762447">cartesian_to_spherical</a> (long nannuli, long nphi, long ntheta)</td></tr>
<tr class="memdesc:a09f15732e3911c087fbf9ed1f8762447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an image with spherical coordinates.  <a href="class_bimage.html#a09f15732e3911c087fbf9ed1f8762447">More...</a><br /></td></tr>
<tr class="separator:a09f15732e3911c087fbf9ed1f8762447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80ca2aed25743abb540366ef12cfcff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad80ca2aed25743abb540366ef12cfcff">cartesian_to_cylindrical</a> (long nannuli, long nphi, int flag=0)</td></tr>
<tr class="memdesc:ad80ca2aed25743abb540366ef12cfcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an image with cylindrical coordinates.  <a href="class_bimage.html#ad80ca2aed25743abb540366ef12cfcff">More...</a><br /></td></tr>
<tr class="separator:ad80ca2aed25743abb540366ef12cfcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013af83454914211aea16cea113711a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a013af83454914211aea16cea113711a5">polar_transform</a> (long nangles, long ann_min, long ann_max, long dann, long zmin, long zmax, long zinc)</td></tr>
<tr class="memdesc:a013af83454914211aea16cea113711a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an image with cylindrical coordinates by integration.  <a href="class_bimage.html#a013af83454914211aea16cea113711a5">More...</a><br /></td></tr>
<tr class="separator:a013af83454914211aea16cea113711a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426b883cb5948d3d72776e8dab1370be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a426b883cb5948d3d72776e8dab1370be">polar_power_spectrum</a> (double resolution, long num_angle)</td></tr>
<tr class="memdesc:a426b883cb5948d3d72776e8dab1370be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the polar power spectrum of a 2D transform amplitude or intensity image.  <a href="class_bimage.html#a426b883cb5948d3d72776e8dab1370be">More...</a><br /></td></tr>
<tr class="separator:a426b883cb5948d3d72776e8dab1370be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdfaa89652d965acbf3a94cb87501b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7bdfaa89652d965acbf3a94cb87501b8">line_powerspectra</a> (<a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> plan)</td></tr>
<tr class="memdesc:a7bdfaa89652d965acbf3a94cb87501b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the 1D power spectrum of each line in an image.  <a href="class_bimage.html#a7bdfaa89652d965acbf3a94cb87501b8">More...</a><br /></td></tr>
<tr class="separator:a7bdfaa89652d965acbf3a94cb87501b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886dcdd400fd1e7a920975dad3c43835"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a886dcdd400fd1e7a920975dad3c43835">radial_shells</a> ()</td></tr>
<tr class="memdesc:a886dcdd400fd1e7a920975dad3c43835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an image with slices representing radial shell projections.  <a href="class_bimage.html#a886dcdd400fd1e7a920975dad3c43835">More...</a><br /></td></tr>
<tr class="separator:a886dcdd400fd1e7a920975dad3c43835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2ba8a5f6c80e5ac4e9b52a87e907f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0a2ba8a5f6c80e5ac4e9b52a87e907f8">cylindrical_shells</a> ()</td></tr>
<tr class="memdesc:a0a2ba8a5f6c80e5ac4e9b52a87e907f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an image with slices representing cylindrical shell projections.  <a href="class_bimage.html#a0a2ba8a5f6c80e5ac4e9b52a87e907f8">More...</a><br /></td></tr>
<tr class="separator:a0a2ba8a5f6c80e5ac4e9b52a87e907f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a73644b93a8f9033ada10246f952e0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5a73644b93a8f9033ada10246f952e0a">radial_sections</a> (double rad_start, double rad_end, double rad_step, double spherical_fraction, <a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym, int fill_type=<a class="el" href="utilities_8h.html#ae8a4ca63176786d1254d05591419ba9c">FILL_USER</a>, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a5a73644b93a8f9033ada10246f952e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an image with slices giving the radial section projections.  <a href="class_bimage.html#a5a73644b93a8f9033ada10246f952e0a">More...</a><br /></td></tr>
<tr class="separator:a5a73644b93a8f9033ada10246f952e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a29bbf90a10dd26c13974ba24320196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2a29bbf90a10dd26c13974ba24320196">radial_coverage</a> (double threshold, double rad_step=1)</td></tr>
<tr class="memdesc:a2a29bbf90a10dd26c13974ba24320196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the coverage in each radial shell.  <a href="class_bimage.html#a2a29bbf90a10dd26c13974ba24320196">More...</a><br /></td></tr>
<tr class="separator:a2a29bbf90a10dd26c13974ba24320196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c930e1334ca602ae39bcf26b3a6f851"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8c930e1334ca602ae39bcf26b3a6f851">topograph_to_surface</a> (<a class="el" href="class_bimage.html">Bimage</a> *psd, long nz, double <a class="el" href="class_bimage.html#a0df18d85c91d522f3f3c2d8ea56b1850">density</a>, double resolution)</td></tr>
<tr class="memdesc:a8c930e1334ca602ae39bcf26b3a6f851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 2D AFM image to a 3D density map.  <a href="class_bimage.html#a8c930e1334ca602ae39bcf26b3a6f851">More...</a><br /></td></tr>
<tr class="separator:a8c930e1334ca602ae39bcf26b3a6f851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de22ac24c7afaac9c174a4b4ff27bc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1de22ac24c7afaac9c174a4b4ff27bc9">surface_to_topograph</a> (double threshold, int dir=0)</td></tr>
<tr class="memdesc:a1de22ac24c7afaac9c174a4b4ff27bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 3D image to a 2D height image.  <a href="class_bimage.html#a1de22ac24c7afaac9c174a4b4ff27bc9">More...</a><br /></td></tr>
<tr class="separator:a1de22ac24c7afaac9c174a4b4ff27bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d462f9cb36da0a45674bcedfa787d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a94d462f9cb36da0a45674bcedfa787d1">rotate_height</a> (<a class="el" href="class_matrix3.html">Matrix3</a> mat, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; translate, double threshold=0)</td></tr>
<tr class="memdesc:a94d462f9cb36da0a45674bcedfa787d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates a 3D map and calculates the height along the z-axis.  <a href="class_bimage.html#a94d462f9cb36da0a45674bcedfa787d1">More...</a><br /></td></tr>
<tr class="separator:a94d462f9cb36da0a45674bcedfa787d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f0e717f7eb6d7cbe3282a752872ca3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a53f0e717f7eb6d7cbe3282a752872ca3">height</a> (<a class="el" href="class_view.html">View</a> *views, double threshold=0)</td></tr>
<tr class="memdesc:a53f0e717f7eb6d7cbe3282a752872ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a set of height images from a 3D density map.  <a href="class_bimage.html#a53f0e717f7eb6d7cbe3282a752872ca3">More...</a><br /></td></tr>
<tr class="separator:a53f0e717f7eb6d7cbe3282a752872ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bc0d2d19d1c538cd9680c101d9a780"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a42bc0d2d19d1c538cd9680c101d9a780">integer_interpolation</a> (int integer_factor)</td></tr>
<tr class="separator:a42bc0d2d19d1c538cd9680c101d9a780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671612e813fa45a25abde953884831cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a671612e813fa45a25abde953884831cc">integer_interpolation</a> (int integer_factor, int odd)</td></tr>
<tr class="memdesc:a671612e813fa45a25abde953884831cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates by an integer scale with a density-preserving overlapping kernel.  <a href="class_bimage.html#a671612e813fa45a25abde953884831cc">More...</a><br /></td></tr>
<tr class="separator:a671612e813fa45a25abde953884831cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c5acae2d99305b8eec1997f9db2097"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a47c5acae2d99305b8eec1997f9db2097">bin</a> (long b)</td></tr>
<tr class="separator:a47c5acae2d99305b8eec1997f9db2097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbd4d70177757388e094c53aba5ecf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afcbd4d70177757388e094c53aba5ecf3">bin</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; bk)</td></tr>
<tr class="memdesc:afcbd4d70177757388e094c53aba5ecf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bins by an integer size in place.  <a href="class_bimage.html#afcbd4d70177757388e094c53aba5ecf3">More...</a><br /></td></tr>
<tr class="separator:afcbd4d70177757388e094c53aba5ecf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4877e67ebf6c884b156f8256db16b92b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4877e67ebf6c884b156f8256db16b92b">bin_copy</a> (long b)</td></tr>
<tr class="separator:a4877e67ebf6c884b156f8256db16b92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720b12635718c76bafb0d844b2264f6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a720b12635718c76bafb0d844b2264f6b">bin_copy</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; bk)</td></tr>
<tr class="memdesc:a720b12635718c76bafb0d844b2264f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bins by an integer size and returns a new image.  <a href="class_bimage.html#a720b12635718c76bafb0d844b2264f6b">More...</a><br /></td></tr>
<tr class="separator:a720b12635718c76bafb0d844b2264f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea01ef4b1ce5c9a28c2fbef72c87f45b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aea01ef4b1ce5c9a28c2fbef72c87f45b">bin_around_origin</a> (int bin)</td></tr>
<tr class="memdesc:aea01ef4b1ce5c9a28c2fbef72c87f45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bins by an integer size making sure the origin falls on a binned voxel, and returns a new image.  <a href="class_bimage.html#aea01ef4b1ce5c9a28c2fbef72c87f45b">More...</a><br /></td></tr>
<tr class="separator:aea01ef4b1ce5c9a28c2fbef72c87f45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1b04d31f25a73455f662662193c9ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#add1b04d31f25a73455f662662193c9ac">median_bin</a> (int binning)</td></tr>
<tr class="memdesc:add1b04d31f25a73455f662662193c9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bins by an integer size, selecting the kernel median.  <a href="class_bimage.html#add1b04d31f25a73455f662662193c9ac">More...</a><br /></td></tr>
<tr class="separator:add1b04d31f25a73455f662662193c9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8789a73a0157946672911c639e820126"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8789a73a0157946672911c639e820126">noise_uniform</a> (double rmin, double rmax)</td></tr>
<tr class="memdesc:a8789a73a0157946672911c639e820126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an image with a uniform random distribution of densities.  <a href="class_bimage.html#a8789a73a0157946672911c639e820126">More...</a><br /></td></tr>
<tr class="separator:a8789a73a0157946672911c639e820126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada19a7de518b9a3ae873b75729c8f74a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ada19a7de518b9a3ae873b75729c8f74a">noise_gaussian</a> (double ravg=0, double rstd=1)</td></tr>
<tr class="memdesc:ada19a7de518b9a3ae873b75729c8f74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an image with a gaussian random distribution of densities.  <a href="class_bimage.html#ada19a7de518b9a3ae873b75729c8f74a">More...</a><br /></td></tr>
<tr class="separator:ada19a7de518b9a3ae873b75729c8f74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4e6a903ad879bba330eb40f419d8ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#adc4e6a903ad879bba330eb40f419d8ac">noise_poisson</a> (double ravg)</td></tr>
<tr class="memdesc:adc4e6a903ad879bba330eb40f419d8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an image with a poisson random distribution of densities.  <a href="class_bimage.html#adc4e6a903ad879bba330eb40f419d8ac">More...</a><br /></td></tr>
<tr class="separator:adc4e6a903ad879bba330eb40f419d8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b440a133368904a12132742c4c8c07d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2b440a133368904a12132742c4c8c07d">noise_logistical</a> (double ravg, double rstd)</td></tr>
<tr class="memdesc:a2b440a133368904a12132742c4c8c07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an image with a gaussian random distribution of densities.  <a href="class_bimage.html#a2b440a133368904a12132742c4c8c07d">More...</a><br /></td></tr>
<tr class="separator:a2b440a133368904a12132742c4c8c07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be1dd59316cc9ba6cb3af8a2cd7364f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0be1dd59316cc9ba6cb3af8a2cd7364f">noise_spectral</a> (double alpha)</td></tr>
<tr class="memdesc:a0be1dd59316cc9ba6cb3af8a2cd7364f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a noise map with a defined spectral decay.  <a href="class_bimage.html#a0be1dd59316cc9ba6cb3af8a2cd7364f">More...</a><br /></td></tr>
<tr class="separator:a0be1dd59316cc9ba6cb3af8a2cd7364f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e52a939175e002908692140c372213d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7e52a939175e002908692140c372213d">mask</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>)</td></tr>
<tr class="memdesc:a7e52a939175e002908692140c372213d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masks an image.  <a href="class_bimage.html#a7e52a939175e002908692140c372213d">More...</a><br /></td></tr>
<tr class="separator:a7e52a939175e002908692140c372213d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1513d43b73d238e6b087fe2e4a2dc873"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1513d43b73d238e6b087fe2e4a2dc873">to_mask</a> ()</td></tr>
<tr class="separator:a1513d43b73d238e6b087fe2e4a2dc873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8256eb1e4caa7cabb1a72f0287d98d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9d8256eb1e4caa7cabb1a72f0287d98d">to_mask</a> (double threshold)</td></tr>
<tr class="memdesc:a9d8256eb1e4caa7cabb1a72f0287d98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the image to a mask.  <a href="class_bimage.html#a9d8256eb1e4caa7cabb1a72f0287d98d">More...</a><br /></td></tr>
<tr class="separator:a9d8256eb1e4caa7cabb1a72f0287d98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d369e4ff6b9dafa6f4e7c3cc624cc8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3d369e4ff6b9dafa6f4e7c3cc624cc8d">mask_by_threshold</a> (double threshold)</td></tr>
<tr class="memdesc:a3d369e4ff6b9dafa6f4e7c3cc624cc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mask based on an image at a given threshold.  <a href="class_bimage.html#a3d369e4ff6b9dafa6f4e7c3cc624cc8d">More...</a><br /></td></tr>
<tr class="separator:a3d369e4ff6b9dafa6f4e7c3cc624cc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680ab2f328a430aa2419e8f99a7171ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a680ab2f328a430aa2419e8f99a7171ca">mask_by_thresholds</a> (vector&lt; double &gt; threshold)</td></tr>
<tr class="memdesc:a680ab2f328a430aa2419e8f99a7171ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mask based on an image at given thresholds.  <a href="class_bimage.html#a680ab2f328a430aa2419e8f99a7171ca">More...</a><br /></td></tr>
<tr class="separator:a680ab2f328a430aa2419e8f99a7171ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9e6d8253c07d69800a8eb4a349a81b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abf9e6d8253c07d69800a8eb4a349a81b">mask_by_conditional_thresholds</a> (vector&lt; double &gt; threshold)</td></tr>
<tr class="memdesc:abf9e6d8253c07d69800a8eb4a349a81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mask based on a conditional hierarchy of thresholds.  <a href="class_bimage.html#abf9e6d8253c07d69800a8eb4a349a81b">More...</a><br /></td></tr>
<tr class="separator:abf9e6d8253c07d69800a8eb4a349a81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6366dbd7f4291754ee084a5a47aed4e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af6366dbd7f4291754ee084a5a47aed4e">mask_stats</a> ()</td></tr>
<tr class="memdesc:af6366dbd7f4291754ee084a5a47aed4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates statistics for a mask.  <a href="class_bimage.html#af6366dbd7f4291754ee084a5a47aed4e">More...</a><br /></td></tr>
<tr class="separator:af6366dbd7f4291754ee084a5a47aed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a53e32389be9d324c6a5020c0d46478"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8a53e32389be9d324c6a5020c0d46478">mask_invert</a> ()</td></tr>
<tr class="memdesc:a8a53e32389be9d324c6a5020c0d46478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts a mask.  <a href="class_bimage.html#a8a53e32389be9d324c6a5020c0d46478">More...</a><br /></td></tr>
<tr class="separator:a8a53e32389be9d324c6a5020c0d46478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d63999cd5d4250dcd81210958cac78"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a93d63999cd5d4250dcd81210958cac78">mask_combine</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, int operation)</td></tr>
<tr class="memdesc:a93d63999cd5d4250dcd81210958cac78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two masks with different operations.  <a href="class_bimage.html#a93d63999cd5d4250dcd81210958cac78">More...</a><br /></td></tr>
<tr class="separator:a93d63999cd5d4250dcd81210958cac78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c294d3382038ecc8c54bccfd4583d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a19c294d3382038ecc8c54bccfd4583d3">mask_extract</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask)</td></tr>
<tr class="memdesc:a19c294d3382038ecc8c54bccfd4583d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeroes everything outside the mask and return the excised feature.  <a href="class_bimage.html#a19c294d3382038ecc8c54bccfd4583d3">More...</a><br /></td></tr>
<tr class="separator:a19c294d3382038ecc8c54bccfd4583d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ceb4eeff446c3ed0cc5b937cab227c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab8ceb4eeff446c3ed0cc5b937cab227c">max_in_kernel</a> (long ksize)</td></tr>
<tr class="separator:ab8ceb4eeff446c3ed0cc5b937cab227c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f025da30842a514cb858e8054cc53"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6e4f025da30842a514cb858e8054cc53">mask_dilate_erode</a> (unsigned char dir)</td></tr>
<tr class="memdesc:a6e4f025da30842a514cb858e8054cc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilates or erodes a binary mask.  <a href="class_bimage.html#a6e4f025da30842a514cb858e8054cc53">More...</a><br /></td></tr>
<tr class="separator:a6e4f025da30842a514cb858e8054cc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36613b563af19c946ca869f076bf634"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af36613b563af19c946ca869f076bf634">mask_dilate</a> (long times=1)</td></tr>
<tr class="memdesc:af36613b563af19c946ca869f076bf634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilates a binary mask.  <a href="class_bimage.html#af36613b563af19c946ca869f076bf634">More...</a><br /></td></tr>
<tr class="separator:af36613b563af19c946ca869f076bf634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902d3c93fd01cff5be2cf247ab42c437"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a902d3c93fd01cff5be2cf247ab42c437">mask_erode</a> (long times=1)</td></tr>
<tr class="memdesc:a902d3c93fd01cff5be2cf247ab42c437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erodes a binary mask.  <a href="class_bimage.html#a902d3c93fd01cff5be2cf247ab42c437">More...</a><br /></td></tr>
<tr class="separator:a902d3c93fd01cff5be2cf247ab42c437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3e82bba9f9618a7bb03ccdd3a2a223"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aaa3e82bba9f9618a7bb03ccdd3a2a223">mask_open</a> (int times=1)</td></tr>
<tr class="memdesc:aaa3e82bba9f9618a7bb03ccdd3a2a223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a binary mask.  <a href="class_bimage.html#aaa3e82bba9f9618a7bb03ccdd3a2a223">More...</a><br /></td></tr>
<tr class="separator:aaa3e82bba9f9618a7bb03ccdd3a2a223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc50476f618586e13c5d2ba99a3a4d5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2fc50476f618586e13c5d2ba99a3a4d5">mask_close</a> (int times=1)</td></tr>
<tr class="memdesc:a2fc50476f618586e13c5d2ba99a3a4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a binary mask.  <a href="class_bimage.html#a2fc50476f618586e13c5d2ba99a3a4d5">More...</a><br /></td></tr>
<tr class="separator:a2fc50476f618586e13c5d2ba99a3a4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82fd40b41c01945499551804754d76b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac82fd40b41c01945499551804754d76b">mask_fill</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; voxel)</td></tr>
<tr class="memdesc:ac82fd40b41c01945499551804754d76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an empty part of a mask indicated by the given voxel.  <a href="class_bimage.html#ac82fd40b41c01945499551804754d76b">More...</a><br /></td></tr>
<tr class="separator:ac82fd40b41c01945499551804754d76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a554846aee83da6a7c471ca3ae8636"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab7a554846aee83da6a7c471ca3ae8636">mask_shell</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>, double rad_min, double rad_max)</td></tr>
<tr class="separator:ab7a554846aee83da6a7c471ca3ae8636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca2b4d4df22975e0790da09f03d6b13"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acca2b4d4df22975e0790da09f03d6b13">mask_plane</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>, <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; normal)</td></tr>
<tr class="memdesc:acca2b4d4df22975e0790da09f03d6b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mask on one side of a plane.  <a href="class_bimage.html#acca2b4d4df22975e0790da09f03d6b13">More...</a><br /></td></tr>
<tr class="separator:acca2b4d4df22975e0790da09f03d6b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b23d253a27fc9adead69d5f94f16ec7"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2b23d253a27fc9adead69d5f94f16ec7">mask_rectangle</a> (double <a class="el" href="_vector3_8h.html#a7baf5ed670fcf9bcca9a3a400820e292">length</a>, double width, double rect_angle, int wrap)</td></tr>
<tr class="memdesc:a2b23d253a27fc9adead69d5f94f16ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mask along an axis within a 2D image.  <a href="class_bimage.html#a2b23d253a27fc9adead69d5f94f16ec7">More...</a><br /></td></tr>
<tr class="separator:a2b23d253a27fc9adead69d5f94f16ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836137ddada36d9ee07e0c778597470c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a836137ddada36d9ee07e0c778597470c">mask_symmetrize</a> (<a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym)</td></tr>
<tr class="memdesc:a836137ddada36d9ee07e0c778597470c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symetrizes a mask.  <a href="class_bimage.html#a836137ddada36d9ee07e0c778597470c">More...</a><br /></td></tr>
<tr class="separator:a836137ddada36d9ee07e0c778597470c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b263c23f182cd36c93e7de6dc0741e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9b263c23f182cd36c93e7de6dc0741e5">mask_fspace_resize</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; nusize)</td></tr>
<tr class="memdesc:a9b263c23f182cd36c93e7de6dc0741e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes a reciprocal space mask.  <a href="class_bimage.html#a9b263c23f182cd36c93e7de6dc0741e5">More...</a><br /></td></tr>
<tr class="separator:a9b263c23f182cd36c93e7de6dc0741e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad411c82b4d184c05045f3ecb4cbee83d"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad411c82b4d184c05045f3ecb4cbee83d">fspace_default_bands</a> (double res_lo, double res_hi)</td></tr>
<tr class="memdesc:ad411c82b4d184c05045f3ecb4cbee83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up default frequency space bands to generate a mask.  <a href="class_bimage.html#ad411c82b4d184c05045f3ecb4cbee83d">More...</a><br /></td></tr>
<tr class="separator:ad411c82b4d184c05045f3ecb4cbee83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab103c7cb8674784b51c313026b294cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab103c7cb8674784b51c313026b294cde">mask_fspace_banded</a> (vector&lt; double &gt; &amp;band)</td></tr>
<tr class="memdesc:ab103c7cb8674784b51c313026b294cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate reciprocal space mask based on a specification of bands.  <a href="class_bimage.html#ab103c7cb8674784b51c313026b294cde">More...</a><br /></td></tr>
<tr class="separator:ab103c7cb8674784b51c313026b294cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb39a8ba9b2b27d51721e89af40582a5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#acb39a8ba9b2b27d51721e89af40582a5">mask_missing_wedge</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>, double tilt_axis, double tilt_neg, double tilt_pos, double resolution)</td></tr>
<tr class="memdesc:acb39a8ba9b2b27d51721e89af40582a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mask with a missing wedge.  <a href="class_bimage.html#acb39a8ba9b2b27d51721e89af40582a5">More...</a><br /></td></tr>
<tr class="separator:acb39a8ba9b2b27d51721e89af40582a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90602f4654cd1d2479828eddf096ddb3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a90602f4654cd1d2479828eddf096ddb3">mask_missing_pyramid</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>, double tilt_axis1, double tilt_axis2, double tilt_neg1, double tilt_pos1, double tilt_neg2, double tilt_pos2, double resolution)</td></tr>
<tr class="memdesc:a90602f4654cd1d2479828eddf096ddb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mask with a missing pyramid.  <a href="class_bimage.html#a90602f4654cd1d2479828eddf096ddb3">More...</a><br /></td></tr>
<tr class="separator:a90602f4654cd1d2479828eddf096ddb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e19d75253d301436865e742712abe5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a81e19d75253d301436865e742712abe5">mask_missing_cone</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; <a class="el" href="class_bimage.html#abbbc219bc9f6b027e29563617a756bbd">origin</a>, double mis_ang, double resolution)</td></tr>
<tr class="memdesc:a81e19d75253d301436865e742712abe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mask with a missing cone.  <a href="class_bimage.html#a81e19d75253d301436865e742712abe5">More...</a><br /></td></tr>
<tr class="separator:a81e19d75253d301436865e742712abe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b60c0e93b7ed7fd9141fcf89edd24f6"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1b60c0e93b7ed7fd9141fcf89edd24f6">mask_missing_find</a> (<a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; ori, double resolution, <a class="el" href="class_bstring.html">Bstring</a> &amp;mis_type)</td></tr>
<tr class="memdesc:a1b60c0e93b7ed7fd9141fcf89edd24f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a missing mask from an example image.  <a href="class_bimage.html#a1b60c0e93b7ed7fd9141fcf89edd24f6">More...</a><br /></td></tr>
<tr class="separator:a1b60c0e93b7ed7fd9141fcf89edd24f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d83b3bde0fc65afea592336ea84424"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a90d83b3bde0fc65afea592336ea84424">mask_pack_plane</a> (<a class="el" href="class_matrix3.html">Matrix3</a> mat, double hi_res, double scale)</td></tr>
<tr class="memdesc:a90d83b3bde0fc65afea592336ea84424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs a 2D mask into a 3D reciprocal space volume. <br  />
  <a href="class_bimage.html#a90d83b3bde0fc65afea592336ea84424">More...</a><br /></td></tr>
<tr class="separator:a90d83b3bde0fc65afea592336ea84424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78b4ad1046f5e78339620f7ac38309f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac78b4ad1046f5e78339620f7ac38309f">variance_threshold</a> (double lowvar)</td></tr>
<tr class="memdesc:ac78b4ad1046f5e78339620f7ac38309f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a threshold for a local variance image.  <a href="class_bimage.html#ac78b4ad1046f5e78339620f7ac38309f">More...</a><br /></td></tr>
<tr class="separator:ac78b4ad1046f5e78339620f7ac38309f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d30db7452d06854cadb693a84e2385a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3d30db7452d06854cadb693a84e2385a">variance_mask</a> (long kernel_size, double lowvar=1e-6, int bkg_flag=0)</td></tr>
<tr class="memdesc:a3d30db7452d06854cadb693a84e2385a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a mask based on local variance.  <a href="class_bimage.html#a3d30db7452d06854cadb693a84e2385a">More...</a><br /></td></tr>
<tr class="separator:a3d30db7452d06854cadb693a84e2385a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ac74f2bb136585165376ab7feb7b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa0ac74f2bb136585165376ab7feb7b2b">tile_mask</a> (long step)</td></tr>
<tr class="memdesc:aa0ac74f2bb136585165376ab7feb7b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a mask to a tiled multilevel mask.  <a href="class_bimage.html#aa0ac74f2bb136585165376ab7feb7b2b">More...</a><br /></td></tr>
<tr class="separator:aa0ac74f2bb136585165376ab7feb7b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1da94077a3d1099442e779a338873d3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa1da94077a3d1099442e779a338873d3">mask_split</a> (long voxels_per_level)</td></tr>
<tr class="memdesc:aa1da94077a3d1099442e779a338873d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a mask to a multilevel mask with a given number of voxels per level.  <a href="class_bimage.html#aa1da94077a3d1099442e779a338873d3">More...</a><br /></td></tr>
<tr class="separator:aa1da94077a3d1099442e779a338873d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b050b7abd5bbe9ba1b22ea6f6c55c22"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a9b050b7abd5bbe9ba1b22ea6f6c55c22">levelmask_collapse</a> ()</td></tr>
<tr class="memdesc:a9b050b7abd5bbe9ba1b22ea6f6c55c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse a multi-level mask to a binary mask.  <a href="class_bimage.html#a9b050b7abd5bbe9ba1b22ea6f6c55c22">More...</a><br /></td></tr>
<tr class="separator:a9b050b7abd5bbe9ba1b22ea6f6c55c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc85fb79cd16369c7fa58ee7cb9a8c4"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7bc85fb79cd16369c7fa58ee7cb9a8c4">levelmask_add</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, int add_level=1)</td></tr>
<tr class="memdesc:a7bc85fb79cd16369c7fa58ee7cb9a8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bilevel mask to a level mask.  <a href="class_bimage.html#a7bc85fb79cd16369c7fa58ee7cb9a8c4">More...</a><br /></td></tr>
<tr class="separator:a7bc85fb79cd16369c7fa58ee7cb9a8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8f8a71d29892880177dba00493a97b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3b8f8a71d29892880177dba00493a97b">levelmask_dilate</a> (int times)</td></tr>
<tr class="memdesc:a3b8f8a71d29892880177dba00493a97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilates a level mask.  <a href="class_bimage.html#a3b8f8a71d29892880177dba00493a97b">More...</a><br /></td></tr>
<tr class="separator:a3b8f8a71d29892880177dba00493a97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa93c8bce1563c143cbc32bd8c024c3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abfa93c8bce1563c143cbc32bd8c024c3">levelmask_dilate</a> ()</td></tr>
<tr class="memdesc:abfa93c8bce1563c143cbc32bd8c024c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilates a level mask.  <a href="class_bimage.html#abfa93c8bce1563c143cbc32bd8c024c3">More...</a><br /></td></tr>
<tr class="separator:abfa93c8bce1563c143cbc32bd8c024c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c503a8bad6d5188959ef2102372c805"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4c503a8bad6d5188959ef2102372c805">levelmask_select</a> (<a class="el" href="class_bstring.html">Bstring</a> &amp;select_list, int flag=0)</td></tr>
<tr class="memdesc:a4c503a8bad6d5188959ef2102372c805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retains the selected levels in a multi-level mask.  <a href="class_bimage.html#a4c503a8bad6d5188959ef2102372c805">More...</a><br /></td></tr>
<tr class="separator:a4c503a8bad6d5188959ef2102372c805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f3b28f7dcabcf950bed87b5c43fe68"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad7f3b28f7dcabcf950bed87b5c43fe68">levelmask_combine</a> (<a class="el" href="class_bstring.html">Bstring</a> &amp;select_list)</td></tr>
<tr class="memdesc:ad7f3b28f7dcabcf950bed87b5c43fe68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the selected levels in a multi-level mask and renumber.  <a href="class_bimage.html#ad7f3b28f7dcabcf950bed87b5c43fe68">More...</a><br /></td></tr>
<tr class="separator:ad7f3b28f7dcabcf950bed87b5c43fe68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c655e6d6031423e7028b3d163c0a264"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0c655e6d6031423e7028b3d163c0a264">levelmask_select</a> (long nn, <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; voxel)</td></tr>
<tr class="memdesc:a0c655e6d6031423e7028b3d163c0a264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retains the selected levels in a multi-level mask.  <a href="class_bimage.html#a0c655e6d6031423e7028b3d163c0a264">More...</a><br /></td></tr>
<tr class="separator:a0c655e6d6031423e7028b3d163c0a264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00376e3fe457712ab10246026c478c89"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a00376e3fe457712ab10246026c478c89">levelmask_select</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask)</td></tr>
<tr class="memdesc:a00376e3fe457712ab10246026c478c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects regions overlapping a mask.  <a href="class_bimage.html#a00376e3fe457712ab10246026c478c89">More...</a><br /></td></tr>
<tr class="separator:a00376e3fe457712ab10246026c478c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152515cc985bb3785ae95e258381c211"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a152515cc985bb3785ae95e258381c211">levelmask_switch</a> (long index1, long index2)</td></tr>
<tr class="memdesc:a152515cc985bb3785ae95e258381c211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches two segments in a multi-level mask.  <a href="class_bimage.html#a152515cc985bb3785ae95e258381c211">More...</a><br /></td></tr>
<tr class="separator:a152515cc985bb3785ae95e258381c211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e31bfb7410474d13a52648e8d6a3c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad6e31bfb7410474d13a52648e8d6a3c8">level_masked_stats</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask)</td></tr>
<tr class="memdesc:ad6e31bfb7410474d13a52648e8d6a3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Caclulates statistics for all the regions defined by a multi-level mask.  <a href="class_bimage.html#ad6e31bfb7410474d13a52648e8d6a3c8">More...</a><br /></td></tr>
<tr class="separator:ad6e31bfb7410474d13a52648e8d6a3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd966c254c4470cdf8a9e1d9254e0438"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#afd966c254c4470cdf8a9e1d9254e0438">levelmask_symmetrize</a> (<a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;sym)</td></tr>
<tr class="memdesc:afd966c254c4470cdf8a9e1d9254e0438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symetrizes a multi-level mask.  <a href="class_bimage.html#afd966c254c4470cdf8a9e1d9254e0438">More...</a><br /></td></tr>
<tr class="separator:afd966c254c4470cdf8a9e1d9254e0438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8266d26a479d99b845c7125e4efab7f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8266d26a479d99b845c7125e4efab7f1">level_mask_extract</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, int fill_type=0, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>=0)</td></tr>
<tr class="memdesc:a8266d26a479d99b845c7125e4efab7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts all the regions associated with a multi-level mask.  <a href="class_bimage.html#a8266d26a479d99b845c7125e4efab7f1">More...</a><br /></td></tr>
<tr class="separator:a8266d26a479d99b845c7125e4efab7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a2be8e3d04b368f3bfd57256809719"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa1a2be8e3d04b368f3bfd57256809719">levelmask_average_region_size</a> ()</td></tr>
<tr class="memdesc:aa1a2be8e3d04b368f3bfd57256809719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the average size of regions in a level mask.  <a href="class_bimage.html#aa1a2be8e3d04b368f3bfd57256809719">More...</a><br /></td></tr>
<tr class="separator:aa1a2be8e3d04b368f3bfd57256809719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17d6f37ff5cbbdcde7620f05141678e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af17d6f37ff5cbbdcde7620f05141678e">levelmask_clean</a> ()</td></tr>
<tr class="memdesc:af17d6f37ff5cbbdcde7620f05141678e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes empty levels from a multi-level mask.  <a href="class_bimage.html#af17d6f37ff5cbbdcde7620f05141678e">More...</a><br /></td></tr>
<tr class="separator:af17d6f37ff5cbbdcde7620f05141678e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86476781a80154c519dd0ddf5962ec43"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a86476781a80154c519dd0ddf5962ec43">levelmask_colorize</a> ()</td></tr>
<tr class="memdesc:a86476781a80154c519dd0ddf5962ec43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colorizes a multi-level mask with random color assignments.  <a href="class_bimage.html#a86476781a80154c519dd0ddf5962ec43">More...</a><br /></td></tr>
<tr class="separator:a86476781a80154c519dd0ddf5962ec43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001d55537c8ef53c9a8db4e4db51550b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a001d55537c8ef53c9a8db4e4db51550b">levelmask_color_by_size</a> ()</td></tr>
<tr class="memdesc:a001d55537c8ef53c9a8db4e4db51550b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color a multi-level mask based on the volumes of regions.  <a href="class_bimage.html#a001d55537c8ef53c9a8db4e4db51550b">More...</a><br /></td></tr>
<tr class="separator:a001d55537c8ef53c9a8db4e4db51550b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4b48837a8edb33dd4003ed717d03e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a8f4b48837a8edb33dd4003ed717d03e1">levelmask_region_size</a> ()</td></tr>
<tr class="memdesc:a8f4b48837a8edb33dd4003ed717d03e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a mask to reflect region sizes.  <a href="class_bimage.html#a8f4b48837a8edb33dd4003ed717d03e1">More...</a><br /></td></tr>
<tr class="separator:a8f4b48837a8edb33dd4003ed717d03e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c3d811f32bcb221a5692271fd2e4df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a42c3d811f32bcb221a5692271fd2e4df">levelmask_size_histogram</a> ()</td></tr>
<tr class="memdesc:a42c3d811f32bcb221a5692271fd2e4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color a multi-level mask based on the volumes of regions.  <a href="class_bimage.html#a42c3d811f32bcb221a5692271fd2e4df">More...</a><br /></td></tr>
<tr class="separator:a42c3d811f32bcb221a5692271fd2e4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d213b882cd62b6ddd30592a8b9df45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a47d213b882cd62b6ddd30592a8b9df45">mask_interface_matrix</a> (int img_num)</td></tr>
<tr class="memdesc:a47d213b882cd62b6ddd30592a8b9df45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the interfaces between regions.  <a href="class_bimage.html#a47d213b882cd62b6ddd30592a8b9df45">More...</a><br /></td></tr>
<tr class="separator:a47d213b882cd62b6ddd30592a8b9df45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94451f98c91c97bf0dee26b0b2a7deab"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a94451f98c91c97bf0dee26b0b2a7deab">mask_region_interfaces</a> (int reg_num)</td></tr>
<tr class="memdesc:a94451f98c91c97bf0dee26b0b2a7deab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the whole interface matrix or interfaces for one region only.  <a href="class_bimage.html#a94451f98c91c97bf0dee26b0b2a7deab">More...</a><br /></td></tr>
<tr class="separator:a94451f98c91c97bf0dee26b0b2a7deab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032c319d4fb989ec7da3c9088c17a987"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a032c319d4fb989ec7da3c9088c17a987">mask_merge_delete</a> (long min_size, long min_if)</td></tr>
<tr class="memdesc:a032c319d4fb989ec7da3c9088c17a987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the interfaces between regions and deletes/merges small ones.  <a href="class_bimage.html#a032c319d4fb989ec7da3c9088c17a987">More...</a><br /></td></tr>
<tr class="separator:a032c319d4fb989ec7da3c9088c17a987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ba83e822caca17e4f2eabfb761f6f3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a26ba83e822caca17e4f2eabfb761f6f3">apply_soft_mask</a> (long nn, <a class="el" href="class_bimage.html">Bimage</a> *pmask, int fill_type, double <a class="el" href="class_bimage.html#a31c23502ddd87cbb33e533a97282effb">fill</a>)</td></tr>
<tr class="memdesc:a26ba83e822caca17e4f2eabfb761f6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a soft mask to a sub-image.  <a href="class_bimage.html#a26ba83e822caca17e4f2eabfb761f6f3">More...</a><br /></td></tr>
<tr class="separator:a26ba83e822caca17e4f2eabfb761f6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55bb02394e154f3b19519c3be2c8c98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ac55bb02394e154f3b19519c3be2c8c98">regions</a> (double threshold, int sign)</td></tr>
<tr class="memdesc:ac55bb02394e154f3b19519c3be2c8c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments an image into contiguous regions.  <a href="class_bimage.html#ac55bb02394e154f3b19519c3be2c8c98">More...</a><br /></td></tr>
<tr class="separator:ac55bb02394e154f3b19519c3be2c8c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c44ca1140db2f36355ae99a0d0e933a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a7c44ca1140db2f36355ae99a0d0e933a">region_assign</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, long idx, long region_number, double threshold, int sign)</td></tr>
<tr class="memdesc:a7c44ca1140db2f36355ae99a0d0e933a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all the pixels that are part of the same region.  <a href="class_bimage.html#a7c44ca1140db2f36355ae99a0d0e933a">More...</a><br /></td></tr>
<tr class="separator:a7c44ca1140db2f36355ae99a0d0e933a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5480279ea3c3895fb01a20ffb1839ce7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a5480279ea3c3895fb01a20ffb1839ce7">region_threshold_series</a> (double threshold_first, double threshold_last, double threshold_step)</td></tr>
<tr class="memdesc:a5480279ea3c3895fb01a20ffb1839ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments a map through a series of thresholds and reports results.  <a href="class_bimage.html#a5480279ea3c3895fb01a20ffb1839ce7">More...</a><br /></td></tr>
<tr class="separator:a5480279ea3c3895fb01a20ffb1839ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e749d2074b4a2e493324e9b526c4e0"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ab0e749d2074b4a2e493324e9b526c4e0">region_flood</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, double threshold_hi, double threshold_lo, double threshold_step, int fill_borders)</td></tr>
<tr class="memdesc:ab0e749d2074b4a2e493324e9b526c4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and expands a region map from a starting to ending threshold value.  <a href="class_bimage.html#ab0e749d2074b4a2e493324e9b526c4e0">More...</a><br /></td></tr>
<tr class="separator:ab0e749d2074b4a2e493324e9b526c4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af285f9b976519ffee80fd03a19db17eb"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af285f9b976519ffee80fd03a19db17eb">check_neighbors</a> (long idx)</td></tr>
<tr class="memdesc:af285f9b976519ffee80fd03a19db17eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check neighbors in region map and assign a value if a neighbor is assigned.  <a href="class_bimage.html#af285f9b976519ffee80fd03a19db17eb">More...</a><br /></td></tr>
<tr class="separator:af285f9b976519ffee80fd03a19db17eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fd2cd3face95c2fb85f2adfb36532f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a08fd2cd3face95c2fb85f2adfb36532f">track_gradient</a> (double threshold, int flag=0)</td></tr>
<tr class="memdesc:a08fd2cd3face95c2fb85f2adfb36532f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a segmented image from peaks above a threshold value.  <a href="class_bimage.html#a08fd2cd3face95c2fb85f2adfb36532f">More...</a><br /></td></tr>
<tr class="separator:a08fd2cd3face95c2fb85f2adfb36532f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e5ef2e7188a1ba225d6f2c31932686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a97e5ef2e7188a1ba225d6f2c31932686">region_peaks</a> (long kernel_size, double threshold, int flood=0, int wrap=0)</td></tr>
<tr class="memdesc:a97e5ef2e7188a1ba225d6f2c31932686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a segmented image from peaks above a threshold value.  <a href="class_bimage.html#a97e5ef2e7188a1ba225d6f2c31932686">More...</a><br /></td></tr>
<tr class="separator:a97e5ef2e7188a1ba225d6f2c31932686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea7cb2268b8f1823316f78fa1180bc7"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aaea7cb2268b8f1823316f78fa1180bc7">blobs</a> (double threshold, double min_size, double max_size, double setvalue, int sign)</td></tr>
<tr class="memdesc:aaea7cb2268b8f1823316f78fa1180bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies contiguous regions above a given threshold (blobs) and eliminate those less than a minimum size.  <a href="class_bimage.html#aaea7cb2268b8f1823316f78fa1180bc7">More...</a><br /></td></tr>
<tr class="separator:aaea7cb2268b8f1823316f78fa1180bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bdc44f4581bd59d988cd52ea5d10a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa7bdc44f4581bd59d988cd52ea5d10a4">filter_extremes</a> ()</td></tr>
<tr class="memdesc:aa7bdc44f4581bd59d988cd52ea5d10a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the extremes out of a micrograph image.  <a href="class_bimage.html#aa7bdc44f4581bd59d988cd52ea5d10a4">More...</a><br /></td></tr>
<tr class="separator:aa7bdc44f4581bd59d988cd52ea5d10a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68563296b57a2d9c25362546f8bf2e2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a68563296b57a2d9c25362546f8bf2e2e">filter_extremes</a> (int mod_flag)</td></tr>
<tr class="memdesc:a68563296b57a2d9c25362546f8bf2e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the extremes out of an image.  <a href="class_bimage.html#a68563296b57a2d9c25362546f8bf2e2e">More...</a><br /></td></tr>
<tr class="separator:a68563296b57a2d9c25362546f8bf2e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd3f470d765801f6061d67342a8b42b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#abcd3f470d765801f6061d67342a8b42b">filter_extremes</a> (double tmin, double tmax, int <a class="el" href="structkernel.html">kernel</a>=3)</td></tr>
<tr class="memdesc:abcd3f470d765801f6061d67342a8b42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the extremes out of an image by replacing with adjacent averages.  <a href="class_bimage.html#abcd3f470d765801f6061d67342a8b42b">More...</a><br /></td></tr>
<tr class="separator:abcd3f470d765801f6061d67342a8b42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f42862e052c422dc5868b9b1234cd5d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a2f42862e052c422dc5868b9b1234cd5d">replace_maxima</a> (double threshold)</td></tr>
<tr class="memdesc:a2f42862e052c422dc5868b9b1234cd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces maxima above a threshold using local averages.  <a href="class_bimage.html#a2f42862e052c422dc5868b9b1234cd5d">More...</a><br /></td></tr>
<tr class="separator:a2f42862e052c422dc5868b9b1234cd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9526b2fed89d032614d58b597db290"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a6b9526b2fed89d032614d58b597db290">mass_threshold</a> (long img_num, double mol_weight, double rho)</td></tr>
<tr class="memdesc:a6b9526b2fed89d032614d58b597db290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the density threshold associated with a particular molecular weight.  <a href="class_bimage.html#a6b9526b2fed89d032614d58b597db290">More...</a><br /></td></tr>
<tr class="separator:a6b9526b2fed89d032614d58b597db290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49ed68863064bb22ca6dc210a712f66"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ad49ed68863064bb22ca6dc210a712f66">mass_at_threshold</a> (long img_num, double threshold, double rho)</td></tr>
<tr class="memdesc:ad49ed68863064bb22ca6dc210a712f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mass from the density threshold.  <a href="class_bimage.html#ad49ed68863064bb22ca6dc210a712f66">More...</a><br /></td></tr>
<tr class="separator:ad49ed68863064bb22ca6dc210a712f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1514d68d5b4b97a826bca033250c4926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a1514d68d5b4b97a826bca033250c4926">internal_volume</a> (double threshold)</td></tr>
<tr class="memdesc:a1514d68d5b4b97a826bca033250c4926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the internal volume of a shell.  <a href="class_bimage.html#a1514d68d5b4b97a826bca033250c4926">More...</a><br /></td></tr>
<tr class="separator:a1514d68d5b4b97a826bca033250c4926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d2caa457d42a0e1991e63ac4dcf82a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a42d2caa457d42a0e1991e63ac4dcf82a">internal_volume</a> (double threshold, int mask_out_freq)</td></tr>
<tr class="memdesc:a42d2caa457d42a0e1991e63ac4dcf82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the internal volume of a shell.  <a href="class_bimage.html#a42d2caa457d42a0e1991e63ac4dcf82a">More...</a><br /></td></tr>
<tr class="separator:a42d2caa457d42a0e1991e63ac4dcf82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3805a269db97bedf75fea6100a28a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae3805a269db97bedf75fea6100a28a09">kmeans_segment</a> (long nregion=2, long max_iter=10, double ratio=1)</td></tr>
<tr class="memdesc:ae3805a269db97bedf75fea6100a28a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments an image based on K-means.  <a href="class_bimage.html#ae3805a269db97bedf75fea6100a28a09">More...</a><br /></td></tr>
<tr class="separator:ae3805a269db97bedf75fea6100a28a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092cc4d52f3a396c699f83dcbd4a2ad4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_sgraph.html">GSgraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a092cc4d52f3a396c699f83dcbd4a2ad4">graph_setup</a> (int connect_type)</td></tr>
<tr class="memdesc:a092cc4d52f3a396c699f83dcbd4a2ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializing voxels and edges for graph-based segmentation.  <a href="class_bimage.html#a092cc4d52f3a396c699f83dcbd4a2ad4">More...</a><br /></td></tr>
<tr class="separator:a092cc4d52f3a396c699f83dcbd4a2ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7e93591778f6edd9ac10c841202b58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_sgraph.html">GSgraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a3e7e93591778f6edd9ac10c841202b58">graph_segment</a> (int type=1, int connect_type=0, double complexity=0, long min_size=0)</td></tr>
<tr class="memdesc:a3e7e93591778f6edd9ac10c841202b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Graph-based segmentation of an image.  <a href="class_bimage.html#a3e7e93591778f6edd9ac10c841202b58">More...</a><br /></td></tr>
<tr class="separator:a3e7e93591778f6edd9ac10c841202b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51056d0e235ae01a7ed58427a1c204ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a51056d0e235ae01a7ed58427a1c204ef">graph_segments_to_image</a> (<a class="el" href="class_g_sgraph.html">GSgraph</a> &amp;g)</td></tr>
<tr class="memdesc:a51056d0e235ae01a7ed58427a1c204ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting a graph-based segmentation to an image.  <a href="class_bimage.html#a51056d0e235ae01a7ed58427a1c204ef">More...</a><br /></td></tr>
<tr class="separator:a51056d0e235ae01a7ed58427a1c204ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8566ad6dc2ec1f6545904b0be3b463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aca8566ad6dc2ec1f6545904b0be3b463">graph_segments_to_mask</a> (<a class="el" href="class_g_sgraph.html">GSgraph</a> &amp;g)</td></tr>
<tr class="memdesc:aca8566ad6dc2ec1f6545904b0be3b463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting a graph-based segmentation to a multi-level mask.  <a href="class_bimage.html#aca8566ad6dc2ec1f6545904b0be3b463">More...</a><br /></td></tr>
<tr class="separator:aca8566ad6dc2ec1f6545904b0be3b463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0967da4dc8941259b9e4e03fbc169b8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0967da4dc8941259b9e4e03fbc169b8e">superpixels_update</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, vector&lt; long &gt; vstep, double colorweight, vector&lt; <a class="el" href="class_bsuperpixel.html">Bsuperpixel</a> &gt; &amp;seg)</td></tr>
<tr class="separator:a0967da4dc8941259b9e4e03fbc169b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed87b5005e95430846c84a77a59a7231"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_bsuperpixel.html">Bsuperpixel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aed87b5005e95430846c84a77a59a7231">superpixels_from_mask</a> (long cc, long step)</td></tr>
<tr class="memdesc:aed87b5005e95430846c84a77a59a7231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create superpixels from a multilevel mask.  <a href="class_bimage.html#aed87b5005e95430846c84a77a59a7231">More...</a><br /></td></tr>
<tr class="separator:aed87b5005e95430846c84a77a59a7231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33a023390e57b9360c07a7e29897096"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_bsuperpixel.html">Bsuperpixel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#aa33a023390e57b9360c07a7e29897096">superpixels</a> (long step, double colorweight=0.2, long iterations=10, double stop=1)</td></tr>
<tr class="memdesc:aa33a023390e57b9360c07a7e29897096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment the image into superpixels.  <a href="class_bimage.html#aa33a023390e57b9360c07a7e29897096">More...</a><br /></td></tr>
<tr class="separator:aa33a023390e57b9360c07a7e29897096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8595e7180726af4e712990b8d8c1e69"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_bsuperpixel.html">Bsuperpixel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#af8595e7180726af4e712990b8d8c1e69">superpixels</a> (long step, double colorweight=0.2, long iterations=10, long bin_levels=1, double stop=1)</td></tr>
<tr class="separator:af8595e7180726af4e712990b8d8c1e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d5f0fe96415e7d334ab657393b7f21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#ae3d5f0fe96415e7d334ab657393b7f21">impose_superpixels</a> (<a class="el" href="class_bimage.html">Bimage</a> *pmask, vector&lt; <a class="el" href="class_bsuperpixel.html">Bsuperpixel</a> &gt; &amp;seg, int impose)</td></tr>
<tr class="memdesc:ae3d5f0fe96415e7d334ab657393b7f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose superpixel features onto an image.  <a href="class_bimage.html#ae3d5f0fe96415e7d334ab657393b7f21">More...</a><br /></td></tr>
<tr class="separator:ae3d5f0fe96415e7d334ab657393b7f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0195ccc461a1a7c1170461211e66f103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a0195ccc461a1a7c1170461211e66f103">next</a></td></tr>
<tr class="separator:a0195ccc461a1a7c1170461211e66f103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3d90a7e963c8fb653f825eb139b045"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bsub__image.html">Bsub_image</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bimage.html#a4c3d90a7e963c8fb653f825eb139b045">image</a></td></tr>
<tr class="separator:a4c3d90a7e963c8fb653f825eb139b045"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >General image parameter class. </p>
<pre class="fragment">All floating point coordinates are in angstroms and converted 
using the voxel units parameters.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a425d720ea28e3566a1cbc1eca8ed9c8d" name="a425d720ea28e3566a1cbc1eca8ed9c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425d720ea28e3566a1cbc1eca8ed9c8d">&#9670;&nbsp;</a></span>Bimage() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bimage::Bimage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an image. </p>
<pre class="fragment">The internal initialization function is called.
</pre> 
</div>
</div>
<a id="a2019f6168e64ab28ee4aecf26c608bec" name="a2019f6168e64ab28ee4aecf26c608bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2019f6168e64ab28ee4aecf26c608bec">&#9670;&nbsp;</a></span>Bimage() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bimage::Bimage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_bimage.html">Bimage</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The copy constructor. </p>
<pre class="fragment">The internal copy function is called.
</pre> 
</div>
</div>
<a id="a43bf591cb81fbd5a134f22a4996f9e2a" name="a43bf591cb81fbd5a134f22a4996f9e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bf591cb81fbd5a134f22a4996f9e2a">&#9670;&nbsp;</a></span>Bimage() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bimage::Bimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a> &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>readdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>img_select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an image from a file. </p>
<pre class="fragment">The internal initialization function is called.
</pre> 
</div>
</div>
<a id="a05fefb596c7347a4bbc1f484ae90f6bb" name="a05fefb596c7347a4bbc1f484ae90f6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fefb596c7347a4bbc1f484ae90f6bb">&#9670;&nbsp;</a></span>Bimage() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bimage::Bimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a>&#160;</td>
          <td class="paramname"><em>ctype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>data type. </td></tr>
    <tr><td class="paramname">ctype</td><td>compound type. </td></tr>
    <tr><td class="paramname">nx</td><td>x dimension. </td></tr>
    <tr><td class="paramname">ny</td><td>y dimension. </td></tr>
    <tr><td class="paramname">nz</td><td>z dimension. </td></tr>
    <tr><td class="paramname">nn</td><td>number of sub-images. <pre class="fragment">The internal initialization function is called.
The basic properties and size is set up and the data allocated.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fcb3757ada7420ce5a48fff2fb1ce0c" name="a8fcb3757ada7420ce5a48fff2fb1ce0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcb3757ada7420ce5a48fff2fb1ce0c">&#9670;&nbsp;</a></span>Bimage() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bimage::Bimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a>&#160;</td>
          <td class="paramname"><em>ctype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>data type. </td></tr>
    <tr><td class="paramname">ctype</td><td>compound type. </td></tr>
    <tr><td class="paramname">size</td><td>image size. </td></tr>
    <tr><td class="paramname">nn</td><td>number of sub-images. <pre class="fragment">The internal initialization function is called.
The basic properties and size is set up and the data allocated.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd8f2cf3ae088ca3d5d171e159571e90" name="abd8f2cf3ae088ca3d5d171e159571e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8f2cf3ae088ca3d5d171e159571e90">&#9670;&nbsp;</a></span>Bimage() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bimage::Bimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a>&#160;</td>
          <td class="paramname"><em>ctype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; long &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>data type. </td></tr>
    <tr><td class="paramname">ctype</td><td>compound type. </td></tr>
    <tr><td class="paramname">size</td><td>image size. </td></tr>
    <tr><td class="paramname">nn</td><td>number of sub-images.</td></tr>
  </table>
  </dd>
</dl>
<p>The internal initialization function is called. The basic properties and size is set up and the data allocated. </p>

</div>
</div>
<a id="af7e9eef81a78901639de38bbdba0a5d1" name="af7e9eef81a78901639de38bbdba0a5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e9eef81a78901639de38bbdba0a5d1">&#9670;&nbsp;</a></span>Bimage() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bimage::Bimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a generic multi-channel image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>data type. </td></tr>
    <tr><td class="paramname">nc</td><td>number of channels. </td></tr>
    <tr><td class="paramname">nx</td><td>x dimension. </td></tr>
    <tr><td class="paramname">ny</td><td>y dimension. </td></tr>
    <tr><td class="paramname">nz</td><td>z dimension. </td></tr>
    <tr><td class="paramname">nn</td><td>number of sub-images. <pre class="fragment">The internal initialization function is called.
The basic properties and size is set up and the data allocated.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dde3db934477ded98998ebec647881a" name="a6dde3db934477ded98998ebec647881a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dde3db934477ded98998ebec647881a">&#9670;&nbsp;</a></span>Bimage() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bimage::Bimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a generic multi-channel image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>data type. </td></tr>
    <tr><td class="paramname">nc</td><td>number of channels. </td></tr>
    <tr><td class="paramname">size</td><td>image size. </td></tr>
    <tr><td class="paramname">nn</td><td>number of sub-images. <pre class="fragment">The internal initialization function is called.
The basic properties and size is set up and the data allocated.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9104e8dd80432d70e95570fb4c593fa0" name="a9104e8dd80432d70e95570fb4c593fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9104e8dd80432d70e95570fb4c593fa0">&#9670;&nbsp;</a></span>Bimage() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bimage::Bimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an image from a 2D matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>matrix. </td></tr>
    <tr><td class="paramname">scale</td><td>integer scale for enlarging the image. <pre class="fragment">The internal initialization function is called.
The basic properties and size is set up and the data allocated.
The matrix contents are transferred with dimension scaling.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad612df25d03e9be007a57ab619e5e76e" name="ad612df25d03e9be007a57ab619e5e76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad612df25d03e9be007a57ab619e5e76e">&#9670;&nbsp;</a></span>~Bimage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bimage::~Bimage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image destructor. </p>
<pre class="fragment">All properties and associated data are deallocated.
</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6829f765ef3e6b7cfd9b2e542e96e68f" name="a6829f765ef3e6b7cfd9b2e542e96e68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6829f765ef3e6b7cfd9b2e542e96e68f">&#9670;&nbsp;</a></span>absolute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::absolute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts to absolute values. </p>

</div>
</div>
<a id="a3caf0fd81251dd1d57aa3fb336000591" name="a3caf0fd81251dd1d57aa3fb336000591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caf0fd81251dd1d57aa3fb336000591">&#9670;&nbsp;</a></span>add() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds another image to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>image to be added. <pre class="fragment">Requirement: The images must have the same size.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d255c2a8212c0d798c04135f95d8ab7" name="a1d255c2a8212c0d798c04135f95d8ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d255c2a8212c0d798c04135f95d8ab7">&#9670;&nbsp;</a></span>add() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds another image to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>image to be added. </td></tr>
    <tr><td class="paramname">scale</td><td>density scale to other image </td></tr>
    <tr><td class="paramname">shift</td><td>density shift to other image. <pre class="fragment">Requirement: The images must have the same size.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba22e1bb37a9565161d49c7908f2fce7" name="aba22e1bb37a9565161d49c7908f2fce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba22e1bb37a9565161d49c7908f2fce7">&#9670;&nbsp;</a></span>add() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::add </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant value to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>constant to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5557cef39f005b06b6bd75993a75e54f" name="a5557cef39f005b06b6bd75993a75e54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5557cef39f005b06b6bd75993a75e54f">&#9670;&nbsp;</a></span>add() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::add </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a value at a given location to neigboring data elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x location. </td></tr>
    <tr><td class="paramname">yy</td><td>y location. </td></tr>
    <tr><td class="paramname">zz</td><td>z location. </td></tr>
    <tr><td class="paramname">nn</td><td>image number (4 th dimension). </td></tr>
    <tr><td class="paramname">v</td><td>value to add. <pre class="fragment">Inverse of trilinear interpolation.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04cec4b61e523881e5cc05f62c0058a8" name="a04cec4b61e523881e5cc05f62c0058a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cec4b61e523881e5cc05f62c0058a8">&#9670;&nbsp;</a></span>add() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::add </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_complex.html">Complex</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>cv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af77f64f607b94b80056a05befc2b686d" name="af77f64f607b94b80056a05befc2b686d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77f64f607b94b80056a05befc2b686d">&#9670;&nbsp;</a></span>add() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::add </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a172ef81a15fd705cd86f2479d4ab307c" name="a172ef81a15fd705cd86f2479d4ab307c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172ef81a15fd705cd86f2479d4ab307c">&#9670;&nbsp;</a></span>add() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::add </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds another image to a sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">*p</td><td>image to be added. <pre class="fragment">Requirement: The images must have the same size.
If the FOM block is defined, it is used to accumulate a sum of:
    the FOM block of the added image if it exists,
    or otherwise the square of the data added.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f7eff4366c6603d8c6f95960e4883cf" name="a4f7eff4366c6603d8c6f95960e4883cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7eff4366c6603d8c6f95960e4883cf">&#9670;&nbsp;</a></span>add() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::add </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds another image to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">*p</td><td>image to be added. </td></tr>
    <tr><td class="paramname">scale</td><td>density scale to other image </td></tr>
    <tr><td class="paramname">shift</td><td>density shift to other image. <pre class="fragment">Requirement: The images must have the same size.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fc989995479711dd10761d2f7385a3e" name="a4fc989995479711dd10761d2f7385a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc989995479711dd10761d2f7385a3e">&#9670;&nbsp;</a></span>align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; &gt; Bimage::align </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ref_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lo_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>edge_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gauss_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>aln_bin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligns and sums a set of sub-images, first progressively and then iteratively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_num</td><td>reference sub-image. </td></tr>
    <tr><td class="paramname">window</td><td>moving sum window. </td></tr>
    <tr><td class="paramname">step</td><td>moving sum interval. </td></tr>
    <tr><td class="paramname">*pmask</td><td>cross-correlation mask. </td></tr>
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lo_res</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">shift_limit</td><td>limit on extent of search for shift. </td></tr>
    <tr><td class="paramname">edge_width</td><td>width of smoothing edge. </td></tr>
    <tr><td class="paramname">gauss_width</td><td>decay coefficient for smoothing edge. </td></tr>
    <tr><td class="paramname">aln_bin</td><td>3-value vector indicating binning level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;Vector3&lt;double&gt;&gt; vector of shifts. <pre class="fragment">The images are first aligned using a progressive algorith starting with 
the indicated reference image.
The images are then aligned iteratively using the average image to 
improve the average.
The image is extensively modified and should not be used for further processing.
</pre> </dd></dl>

</div>
</div>
<a id="a7ceb1c51aa8f8a520fea19befa25b313" name="a7ceb1c51aa8f8a520fea19befa25b313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ceb1c51aa8f8a520fea19befa25b313">&#9670;&nbsp;</a></span>align2D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::align2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_polar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ann_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ann_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>prs_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf_1D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb_1D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf_2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb_2D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the best in-plane alignment for two 2D images using polar power spectra. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pref</td><td>reference 2D image. </td></tr>
    <tr><td class="paramname">res_polar</td><td>polar resolution limit. </td></tr>
    <tr><td class="paramname">ann_min</td><td>minimum annulus (&gt;=0). </td></tr>
    <tr><td class="paramname">ann_max</td><td>maximum annulus (&lt; image radius). </td></tr>
    <tr><td class="paramname">*prs_mask</td><td>dual mask. </td></tr>
    <tr><td class="paramname">shift_limit</td><td>maximum shift from nominal origin of box. </td></tr>
    <tr><td class="paramname">angle_limit</td><td>maximum rotation from original in-plane rotation angle. </td></tr>
    <tr><td class="paramname">planf_1D</td><td>FFT forward plan for polar images. </td></tr>
    <tr><td class="paramname">planb_1D</td><td>FFT backward plan for polar images. </td></tr>
    <tr><td class="paramname">planf_2D</td><td>FFT forward plan for 2D images. </td></tr>
    <tr><td class="paramname">planb_2D</td><td>FFT backward plan for 2D images. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double correlation coefficient. <pre class="fragment">Both the image and reference is converted to polar images using the 
current origins. The annuli of the polar images are cross-correlated
to find the rotation angle. The reference is rotated and cross-correlated
with the image to determine a new origin for the image. This is iterated
untill the rotation angle and origin of the image does not change any more,
or a maximum number of iterations.
The cross-correlation is done with the provided mask..
The correlation coefficient return is the cross-correlation peak.
The input images must be equal-sized square 2D images.
</pre> </dd></dl>

</div>
</div>
<a id="ab4243b9407c5220fabf6f7c23b16d999" name="ab4243b9407c5220fabf6f7c23b16d999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4243b9407c5220fabf6f7c23b16d999">&#9670;&nbsp;</a></span>align2D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::align2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ann_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ann_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the best in-plane alignment for two 2D images using polar power spectra. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pref</td><td>reference 2D image. </td></tr>
    <tr><td class="paramname">ann_min</td><td>minimum annulus (&gt;=0). </td></tr>
    <tr><td class="paramname">ann_max</td><td>maximum annulus (&lt; image radius). </td></tr>
    <tr><td class="paramname">res_lo</td><td>low resolution limit (angstrom). </td></tr>
    <tr><td class="paramname">res_hi</td><td>high resolution limit (angstrom). </td></tr>
    <tr><td class="paramname">shift_limit</td><td>maximum shift from nominal origin of box. </td></tr>
    <tr><td class="paramname">angle_limit</td><td>maximum rotation from original in-plane rotation angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double correlation coefficient. <pre class="fragment">This is a simplified interface to the other function Bimage::align2D.
All the fourier transform and rotation functions are handled internally.
</pre> </dd></dl>

</div>
</div>
<a id="afd7765f966cffac40807eb001959fa28" name="afd7765f966cffac40807eb001959fa28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7765f966cffac40807eb001959fa28">&#9670;&nbsp;</a></span>align2D_pps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::align2D_pps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the best in-plane alignment for two 2D images using polar power spectra. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pref</td><td>reference 2D image. </td></tr>
    <tr><td class="paramname">res_hi</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">res_lo</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">shift_limit</td><td>maximum shift from nominal origin of box. </td></tr>
    <tr><td class="paramname">angle_limit</td><td>maximum rotation from original in-plane rotation angle. </td></tr>
    <tr><td class="paramname">planf</td><td>FFT forward plan. </td></tr>
    <tr><td class="paramname">planb</td><td>FFT backward plan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double correlation coefficient. <pre class="fragment">The rotation angle is found by cross-correlating the annuli
of the polar transforms of the power spectra of the image and the
reference image. If the full asu flag is not set, the annular cross-correlation
is done both forwards and backwards to detect mirror images, with the sign 
of the angle indicating which direction is best (&gt;0 =&gt; forwards, &lt;0 =&gt; backwards).
The resolution limit specified in the image is used to low-pass filter 
the cross-correlation. The shift is then determined by cross-correlation 
after rotating the reference image, as well as its 180° rotation to deal with
that ambiguity in the power spectrum.
The correlation coefficient return is the cross-correlation peak.
The input images must be equal-sized square 2D images.
The origin and rotation angle is returned in the image structure.
</pre> </dd></dl>

</div>
</div>
<a id="ac91286dc4862354d4dd617144e6fa8e1" name="ac91286dc4862354d4dd617144e6fa8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91286dc4862354d4dd617144e6fa8e1">&#9670;&nbsp;</a></span>align_fast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_svalue.html">JSvalue</a> Bimage::align_fast </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ref_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lo_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>edge_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gauss_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligns and sums a set of sub-images, first progressively and then iteratively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_num</td><td>reference sub-image. </td></tr>
    <tr><td class="paramname">*pmask</td><td>cross-correlation mask. </td></tr>
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lo_res</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">shift_limit</td><td>limit on extent of search for shift. </td></tr>
    <tr><td class="paramname">edge_width</td><td>width of smoothing edge. </td></tr>
    <tr><td class="paramname">gauss_width</td><td>decay coefficient for smoothing edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double average shift. <pre class="fragment">The images are first aligned using a progressive algorith starting with 
the indicated reference image.
The images are then aligned iteratively using the average image to 
improve the average.
</pre> </dd></dl>

</div>
</div>
<a id="aa91803c287ab037bc7a3c403291acc2f" name="aa91803c287ab037bc7a3c403291acc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91803c287ab037bc7a3c403291acc2f">&#9670;&nbsp;</a></span>align_progressive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::align_progressive </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lo_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligns and sums a set of sub-images using a progressive algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nref</td><td>reference sub-image. </td></tr>
    <tr><td class="paramname">*pmask</td><td>cross-correlation mask. </td></tr>
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lo_res</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">shift_limit</td><td>limit on extent of search for shift. </td></tr>
    <tr><td class="paramname">planf</td><td>plan for forward Fourier transform. </td></tr>
    <tr><td class="paramname">planb</td><td>plan for backward Fourier transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* summed reference image. <pre class="fragment">The images are aligned against the reference images with progressive
addition to reference to decrease noise.
</pre> </dd></dl>

</div>
</div>
<a id="aa79aa0e953c56c5ce8e1a1498f386751" name="aa79aa0e953c56c5ce8e1a1498f386751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79aa0e953c56c5ce8e1a1498f386751">&#9670;&nbsp;</a></span>align_progressive_fast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::align_progressive_fast </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligns and sums a set of sub-images using a progressive algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nref</td><td>reference sub-image. </td></tr>
    <tr><td class="paramname">shift_limit</td><td>limit on extent of search for shift. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* summed reference image. <pre class="fragment">The images are aligned against the reference images with progressive
addition to reference to decrease noise.
</pre> </dd></dl>

</div>
</div>
<a id="adab24545dd418ba976941ee9cc5aaad4" name="adab24545dd418ba976941ee9cc5aaad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab24545dd418ba976941ee9cc5aaad4">&#9670;&nbsp;</a></span>alloc_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::alloc_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adfd7c5588e083504f2bcdb551682dd57" name="adfd7c5588e083504f2bcdb551682dd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd7c5588e083504f2bcdb551682dd57">&#9670;&nbsp;</a></span>aniso_average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::aniso_average </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an anisotropic average within a kernel based on the local gradient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ksize</td><td>kernel radius. </td></tr>
    <tr><td class="paramname">w</td><td>gradient weight (0 reverts to isotropic). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new image. </dd></dl>

</div>
</div>
<a id="a26ba83e822caca17e4f2eabfb761f6f3" name="a26ba83e822caca17e4f2eabfb761f6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ba83e822caca17e4f2eabfb761f6f3">&#9670;&nbsp;</a></span>apply_soft_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::apply_soft_mask </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a soft mask to a sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">pmask</td><td>soft mask: [0,1]. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>value of edge voxels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is multiplied with the mask, filling in the remainder 
with the fill value.
Requirement: The mask must range from 0 to 1.
</pre> </dd></dl>

</div>
</div>
<a id="adb1bceb367182c8e7f159fec64b95982" name="adb1bceb367182c8e7f159fec64b95982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1bceb367182c8e7f159fec64b95982">&#9670;&nbsp;</a></span>assemble_tiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::assemble_tiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assembles overlapping tiles into this image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pt</td><td>multi-image containing tiles. </td></tr>
    <tr><td class="paramname">flag</td><td>flag to set overlap handling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The origin in each tile specifies the starting location.
Where tiles overlap, the integration is determined by the flag:
0 = simple addition with averaging afterwards.
1 = a gradual transition from one tile to the other.
2 = place just the central part of each tile.
The original data in the image is overwritten.
</pre> </dd></dl>

</div>
</div>
<a id="a58df899bf2137ec1046c1432d4ea0014" name="a58df899bf2137ec1046c1432d4ea0014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58df899bf2137ec1046c1432d4ea0014">&#9670;&nbsp;</a></span>auto_correlate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::auto_correlate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an autocorrelation map by Fast Fourier transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">FFTW library (www.fftw.org).
A multi-image 1D, 2D and 3D data set is transformed forward, the 
transform multiplied by its complex conjugate, followed by backward 
transformation and rescaling by 1/(N*N). Data beyond the resolution 
set in the image structure are zeroed. Therefore the correct setting 
of units and resolution in the image are required. Defaults for the 
units are usually 1 Angstrom/voxel and a zero resolution would
include the whole image (i.e., no resolution limitation).
The resultant image is Float.
</pre> </dd></dl>

</div>
</div>
<a id="a3de98170ee996fa85f1802250e646a87" name="a3de98170ee996fa85f1802250e646a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de98170ee996fa85f1802250e646a87">&#9670;&nbsp;</a></span>average() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::average </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95753acb1cb55e4e013e0b4a486a5c01" name="a95753acb1cb55e4e013e0b4a486a5c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95753acb1cb55e4e013e0b4a486a5c01">&#9670;&nbsp;</a></span>average() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::average </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b7559f244271ee490d3746da9a02378" name="a8b7559f244271ee490d3746da9a02378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7559f244271ee490d3746da9a02378">&#9670;&nbsp;</a></span>average() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::average </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iscale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Averages in 3D when scaling is less than 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>channel. </td></tr>
    <tr><td class="paramname">xf</td><td>x location. </td></tr>
    <tr><td class="paramname">yf</td><td>y location. </td></tr>
    <tr><td class="paramname">zf</td><td>z location. </td></tr>
    <tr><td class="paramname">nn</td><td>image number. </td></tr>
    <tr><td class="paramname">iscale</td><td>inverse scale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double average. <pre class="fragment">All neighboring voxels in x, y and z are averaged and result returned.
</pre> </dd></dl>

</div>
</div>
<a id="a536c5f24e8492683cc0c65678c524ed2" name="a536c5f24e8492683cc0c65678c524ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536c5f24e8492683cc0c65678c524ed2">&#9670;&nbsp;</a></span>average2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::average2D </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iscale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Averages in the xy plane when scaling is less than 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>channel. </td></tr>
    <tr><td class="paramname">xf</td><td>x location. </td></tr>
    <tr><td class="paramname">yf</td><td>y location. </td></tr>
    <tr><td class="paramname">zf</td><td>z location. </td></tr>
    <tr><td class="paramname">nn</td><td>image number. </td></tr>
    <tr><td class="paramname">iscale</td><td>inverse scale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double average. <pre class="fragment">All neighboring voxels in x and y are averaged and result returned.
</pre> </dd></dl>

</div>
</div>
<a id="a7a758b80d8b664281665fd2a22183024" name="a7a758b80d8b664281665fd2a22183024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a758b80d8b664281665fd2a22183024">&#9670;&nbsp;</a></span>average_images() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::average_images </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34e86e673f3794fc9f2ec5c04540c2a4" name="a34e86e673f3794fc9f2ec5c04540c2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e86e673f3794fc9f2ec5c04540c2a4">&#9670;&nbsp;</a></span>average_images() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::average_images </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Averages all sub-images and optionally calculates standard deviation image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sd</td><td>flag to calculate linked standard deviation image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* average image. </dd></dl>

</div>
</div>
<a id="a0d72986433c77abdb1bbfef125df3cf7" name="a0d72986433c77abdb1bbfef125df3cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d72986433c77abdb1bbfef125df3cf7">&#9670;&nbsp;</a></span>average_phase_difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::average_phase_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>weighting</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the average of the absolute phase difference between two images within given resolution shells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>real space reference image. </td></tr>
    <tr><td class="paramname">res_hi</td><td>upper resolution limit. </td></tr>
    <tr><td class="paramname">res_lo</td><td>lower resolution limit. </td></tr>
    <tr><td class="paramname">weighting</td><td>weighting type: 0, none; 1, p1-amp; 2, p2-amp; 3, both amps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double average of the cosine of the phase difference. <pre class="fragment">Both images are Fourier transformed and the absolute phase
difference calculated and averaged.
</pre> </dd></dl>

</div>
</div>
<a id="aaaa6013e0f403993b7dde45889a0e0ef" name="aaaa6013e0f403993b7dde45889a0e0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa6013e0f403993b7dde45889a0e0ef">&#9670;&nbsp;</a></span>back_project()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::back_project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69f89659be398fec283e1c267f33c190" name="a69f89659be398fec283e1c267f33c190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f89659be398fec283e1c267f33c190">&#9670;&nbsp;</a></span>background() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::background </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bkg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbfb6a4d3284e436475955bc786ac840" name="adbfb6a4d3284e436475955bc786ac840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfb6a4d3284e436475955bc786ac840">&#9670;&nbsp;</a></span>background() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::background </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa931beeddd098f0759308ef1e11c076c" name="aa931beeddd098f0759308ef1e11c076c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa931beeddd098f0759308ef1e11c076c">&#9670;&nbsp;</a></span>background() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::background </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bkg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a637c8c9c3adab0168669c4b0a2bfe29f" name="a637c8c9c3adab0168669c4b0a2bfe29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637c8c9c3adab0168669c4b0a2bfe29f">&#9670;&nbsp;</a></span>bar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::bar </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>edge_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a bar between start and end points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">start</td><td>start of bar. </td></tr>
    <tr><td class="paramname">end</td><td>end of bar. </td></tr>
    <tr><td class="paramname">width</td><td>width of bar. </td></tr>
    <tr><td class="paramname">edge_width</td><td>bar edge width. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">A bar is generated with the given fill value from the start point
to the end point and with a defined width and gaussian edge.
</pre> </dd></dl>

</div>
</div>
<a id="a5b6e0c4b18f647d68db21c1fbbfaac3b" name="a5b6e0c4b18f647d68db21c1fbbfaac3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6e0c4b18f647d68db21c1fbbfaac3b">&#9670;&nbsp;</a></span>bar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::bar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>edge_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a bar between start and end points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>start of bar. </td></tr>
    <tr><td class="paramname">end</td><td>end of bar. </td></tr>
    <tr><td class="paramname">width</td><td>width of bar. </td></tr>
    <tr><td class="paramname">edge_width</td><td>bar edge width. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">A bar is generated with the given fill value from the start point
to the end point and with a defined width and gaussian edge.
</pre> </dd></dl>

</div>
</div>
<a id="a47c5acae2d99305b8eec1997f9db2097" name="a47c5acae2d99305b8eec1997f9db2097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c5acae2d99305b8eec1997f9db2097">&#9670;&nbsp;</a></span>bin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::bin </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afcbd4d70177757388e094c53aba5ecf3" name="afcbd4d70177757388e094c53aba5ecf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbd4d70177757388e094c53aba5ecf3">&#9670;&nbsp;</a></span>bin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>bk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bins by an integer size in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bk</td><td>3-value vector of integer bin factors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">An image is binned by an integer size.
</pre> </dd></dl>

</div>
</div>
<a id="aea01ef4b1ce5c9a28c2fbef72c87f45b" name="aea01ef4b1ce5c9a28c2fbef72c87f45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea01ef4b1ce5c9a28c2fbef72c87f45b">&#9670;&nbsp;</a></span>bin_around_origin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::bin_around_origin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bins by an integer size making sure the origin falls on a binned voxel, and returns a new image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bin</td><td>integer bin factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new image. <pre class="fragment">An image is binned by an integer size, square in 2D and cubic in 3D.
</pre> </dd></dl>

</div>
</div>
<a id="a4877e67ebf6c884b156f8256db16b92b" name="a4877e67ebf6c884b156f8256db16b92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4877e67ebf6c884b156f8256db16b92b">&#9670;&nbsp;</a></span>bin_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::bin_copy </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a720b12635718c76bafb0d844b2264f6b" name="a720b12635718c76bafb0d844b2264f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720b12635718c76bafb0d844b2264f6b">&#9670;&nbsp;</a></span>bin_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::bin_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>bk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bins by an integer size and returns a new image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bk</td><td>3-value vector of integer bin factors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new image. <pre class="fragment">An image is binned by an integer size.
</pre> </dd></dl>

</div>
</div>
<a id="a460f2d1622dafdaeb8fc1d61dd0ec462" name="a460f2d1622dafdaeb8fc1d61dd0ec462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460f2d1622dafdaeb8fc1d61dd0ec462">&#9670;&nbsp;</a></span>blend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::blend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blends the two images, creating a new set of sub-images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
    <tr><td class="paramname">number</td><td>number of images in the series. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new image structure, NULL if error. <pre class="fragment">A number of images are created by blending the two input images in
different ratios. The input images become the first and last sub-images of 
the new image structure, with the intermediate images changing over from
the first to the last:
        new_data = (1-fraction)*data1 + fraction*data2
where fraction = index/(number - 1)
At least 3 new sub-images are packed into the new image. 
All of the header information in the first image is copied into the new image.
Both images are converted to floating point.
</pre> </dd></dl>

</div>
</div>
<a id="aaea7cb2268b8f1823316f78fa1180bc7" name="aaea7cb2268b8f1823316f78fa1180bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea7cb2268b8f1823316f78fa1180bc7">&#9670;&nbsp;</a></span>blobs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::blobs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>setvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies contiguous regions above a given threshold (blobs) and eliminate those less than a minimum size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>threshold to define contiguous regions. </td></tr>
    <tr><td class="paramname">min_size</td><td>minimum number of voxels to keep a region. </td></tr>
    <tr><td class="paramname">max_size</td><td>maximum number of voxels to keep a region. </td></tr>
    <tr><td class="paramname">setvalue</td><td>value to assign to deleted regions (typically set to threshold). </td></tr>
    <tr><td class="paramname">sign</td><td>sign controlling direction of thresholding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of voxels set to threshold. <pre class="fragment">All contiguous regions in an image are indexed and their sizes 
calculated. Whether a region is contiguous is defined by a
threshold. Regions smaller than a minimum number of voxels are
set to the threshold value. The input image is modified and
left as a floating point image.
</pre> </dd></dl>

</div>
</div>
<a id="a7535de626d0c458869842fe6379a9ba5" name="a7535de626d0c458869842fe6379a9ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7535de626d0c458869842fe6379a9ba5">&#9670;&nbsp;</a></span>calculate_background() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::calculate_background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the background for each sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>foreground mask. </td></tr>
    <tr><td class="paramname">flag</td><td>flag to specify where to calculate the background: [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">If the mask is specified, it is used to define the part of the 
image to be used for background calculation (where the mask is zero).
</pre> </dd></dl>

</div>
</div>
<a id="aad111b7044a4c05761f372ce2f5688ae" name="aad111b7044a4c05761f372ce2f5688ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad111b7044a4c05761f372ce2f5688ae">&#9670;&nbsp;</a></span>calculate_background() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::calculate_background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the background for one sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>foreground mask. </td></tr>
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">flag</td><td>flag to specify where to calculate the background: [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">If the mask is specified, it is used to define the part of the 
image to be used for background calculation (where the mask is zero).
</pre> </dd></dl>

</div>
</div>
<a id="a86fbcdfea888cba3b6891cb7c0685077" name="a86fbcdfea888cba3b6891cb7c0685077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fbcdfea888cba3b6891cb7c0685077">&#9670;&nbsp;</a></span>calculate_background() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::calculate_background </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the background for each sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>flag to specify where to calculate the background: [0,3] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">The background is taken as the average of the values outside the
circle or sphere enclosed by the image.
</pre> </dd></dl>

</div>
</div>
<a id="ac1eca04ce6fa6cbd93a59ed0bb0474e0" name="ac1eca04ce6fa6cbd93a59ed0bb0474e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eca04ce6fa6cbd93a59ed0bb0474e0">&#9670;&nbsp;</a></span>calculate_background() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::calculate_background </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the background for one sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">flag</td><td>flag to specify where to calculate the background: [0,3] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">The background is taken as the average of the values for:
flag=0,1    outside the circle or sphere enclosed by the image
flag=2      inside the circle or sphere enclosed by the image
flag=3      inside the half-radius circle in the center of the image.
</pre> </dd></dl>

</div>
</div>
<a id="ad80ca2aed25743abb540366ef12cfcff" name="ad80ca2aed25743abb540366ef12cfcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80ca2aed25743abb540366ef12cfcff">&#9670;&nbsp;</a></span>cartesian_to_cylindrical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::cartesian_to_cylindrical </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nannuli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an image with cylindrical coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nannuli</td><td>number of annuli. </td></tr>
    <tr><td class="paramname">nphi</td><td>number of phi angles. </td></tr>
    <tr><td class="paramname">flag</td><td>switch: annulus-angle-z (0), angle-annulus-z (1), z-annulus-angle (2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* cylindrical image. <pre class="fragment">The image is converted to cylindrical form with a specified number of 
annuli and angles. 
A point vector p = {x,y,z} with respect to the image origin (typically
the center of the image) is converted to cylindrical coordinates as follows:
    The distance from the z-origin gives the annulus:
        |p| = sqrt(x*x+y*y)
    Phi is the rotation angle around the z-axis, starting at the x-axis:
        phi = atan(y/x)
    The z-coordinate remains unchanged.
The new dimensions are mapped as follows with their maximum ranges:
    |p|   ===&gt; x_dimension (0 - max(x_size,y_size,z_size)
    phi   ===&gt; y_dimension (0 - 2*PI)
    z     ===&gt; z_dimension
The sampling within these ranges are given by the calling function.
The sampling must be isotropic.
The origins within the sub-image structures are used.
The interpolation routine actually calculates the old cartesian 
coordinates for each set of cylindrical coordinates.
</pre> </dd></dl>

</div>
</div>
<a id="a09f15732e3911c087fbf9ed1f8762447" name="a09f15732e3911c087fbf9ed1f8762447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f15732e3911c087fbf9ed1f8762447">&#9670;&nbsp;</a></span>cartesian_to_spherical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::cartesian_to_spherical </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nannuli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ntheta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an image with spherical coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nannuli</td><td>number of annuli. </td></tr>
    <tr><td class="paramname">nphi</td><td>number of phi angles. </td></tr>
    <tr><td class="paramname">ntheta</td><td>number of theta angles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* spherical image. <pre class="fragment">The image is converted to polar form with a specified number of annuli
and angles in one (a 2D image) or two (a 3D map) directions. The 
angular convention is consistent with the Euler angles used for 3D
image processing. 
A point vector p = {x,y,z} with respect to the image origin (typically
the center of the image) is converted to polar coordinates as follows:
    The size of the vector gives the annulus:
        |p| = sqrt(x*x+y*y+z*z)
    Phi is the rotation angle around the z-axis, starting at the x-axis:
        phi = atan(y/x)
    Theta is the angle between the positive z-axis and the point vector:
        theta = acos(z/|p|)
The new dimensions are mapped as follows with their maximum ranges:
    |p|   ===&gt; x_dimension (0 - max(x_size,y_size,z_size)
    phi   ===&gt; y_dimension (0 - 2*PI)
    theta ===&gt; z_dimension (0 - PI)
The sampling within these ranges are given by the calling function.
The sampling must be isotropic.
The origins within the sub-image structures are used.
The interpolation routine actually calculates the old cartesian 
coordinates for each set of spherical coordinates.
</pre> </dd></dl>

</div>
</div>
<a id="ac8555d13111d99d6736cafc5e9d36232" name="ac8555d13111d99d6736cafc5e9d36232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8555d13111d99d6736cafc5e9d36232">&#9670;&nbsp;</a></span>catenate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::catenate </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> **&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Catenates an array of images of the same size into a multi-image structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>number of images in the array. </td></tr>
    <tr><td class="paramname">**p</td><td>array of images. <pre class="fragment">The images must all have the same dimensions.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe8c89d040e7a16ababdcb654433ef39" name="abe8c89d040e7a16ababdcb654433ef39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8c89d040e7a16ababdcb654433ef39">&#9670;&nbsp;</a></span>ccmap_confidence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::ccmap_confidence </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a confidence level to associate with a cross-correlation peak. </p>
<dl class="section author"><dt>Author</dt><dd>Bernard Heymann and Xiange Zheng </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double P value. <pre class="fragment">The highest two peak maxima are found and used to calculate a
confidence level for the hypothesis that the second highest peak is
different from the first. The two maxima are found by a kernel search
which implicitly assumes that the values associated with a peak
monotonically decays with distance from the peak.
Fisher's z-transform is used to calculate the confidence level:
    P = erfc((zmax - zmax2)/(2*z_sigma))
where
    zmax, zmax2: z-transforms of the highest two peaks.
    z_sigma: standard deviation of the z-transform of the cc map.
The P value is returned
</pre> </dd></dl>

</div>
</div>
<a id="a5f9345465a753a4ace75a2b1d7c379ba" name="a5f9345465a753a4ace75a2b1d7c379ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9345465a753a4ace75a2b1d7c379ba">&#9670;&nbsp;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::center </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Centers an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fill_type</td><td>fill type for filling empty regions. </td></tr>
    <tr><td class="paramname">fill</td><td>value to fill in empty regions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. </dd></dl>

</div>
</div>
<a id="aea1442cea3c82de6ac0793d38241abaa" name="aea1442cea3c82de6ac0793d38241abaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1442cea3c82de6ac0793d38241abaa">&#9670;&nbsp;</a></span>center_wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::center_wrap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Centers an image with wrapping. </p>
<dl class="section return"><dt>Returns</dt><dd>int error code. </dd></dl>

</div>
</div>
<a id="af6f48665392f5a455d8afa04f14c1c98" name="af6f48665392f5a455d8afa04f14c1c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f48665392f5a455d8afa04f14c1c98">&#9670;&nbsp;</a></span>central_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::central_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_s_i___kernel.html">FSI_Kernel</a> *&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wavelength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a central section of a 3D fourier transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>3x3 rotation or skewing matrix. </td></tr>
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">*kernel</td><td>frequency space interpolation kernel. </td></tr>
    <tr><td class="paramname">wavelength</td><td>for Ewald sphere projection, default zero, ± for front or back curvature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new 2D central section. <pre class="fragment">The orientation of the central section is defined by a rotation matrix
and the interpolation is done with a reciprocal space kernel.
The rotation origin is obtained from the map origin.
</pre> </dd></dl>

</div>
</div>
<a id="a521d7a03503be2b8ec4a4090e81ada1e" name="a521d7a03503be2b8ec4a4090e81ada1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521d7a03503be2b8ec4a4090e81ada1e">&#9670;&nbsp;</a></span>change_symmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::change_symmetry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>symold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>symnu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z_slope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the symmetry order for cyclic and dihedral maps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*symold</td><td>original symmetry. </td></tr>
    <tr><td class="paramname">*symnu</td><td>new symmetry. </td></tr>
    <tr><td class="paramname">radius</td><td>radius in voxels of repeating units. </td></tr>
    <tr><td class="paramname">z_slope</td><td>slope along z to adjust radius. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">If the radius is zero, the change in symmetry is done with proportional
shifts that distorts the units in the map.
If the radius is positive, it is used to determine the radial shift for
each unit, giving much less distortion than the proportional shifts.
Variation of the radius of the specimen along z can be handled with
a non-zero z slope parameter.
</pre> </dd></dl>

</div>
</div>
<a id="ae74e7014bad39ad70cf631c4470d6a3c" name="ae74e7014bad39ad70cf631c4470d6a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74e7014bad39ad70cf631c4470d6a3c">&#9670;&nbsp;</a></span>change_transform_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::change_transform_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes a "standard" transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>new image size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector3.html">Vector3&lt;double&gt;</a> scale. <pre class="fragment">A standard transform is resized by inserting or removing
rows or columns in the middle of the data set.
</pre> </dd></dl>

</div>
</div>
<a id="a5edb27a22dcc386452236472c6a1c916" name="a5edb27a22dcc386452236472c6a1c916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5edb27a22dcc386452236472c6a1c916">&#9670;&nbsp;</a></span>change_type() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::change_type </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data type from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*string</td><td>string describing the data type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf2848239c21e111b23b87b4c2a95dd5" name="aaf2848239c21e111b23b87b4c2a95dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2848239c21e111b23b87b4c2a95dd5">&#9670;&nbsp;</a></span>change_type() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::change_type </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>letter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data type indicated by a single letter code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">letter</td><td>letter indicating data type. <pre class="fragment">This function is used in optional command-line arguments to indicate 
a new data type for an image.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05ed25186621c0611497ee8738e9d602" name="a05ed25186621c0611497ee8738e9d602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ed25186621c0611497ee8738e9d602">&#9670;&nbsp;</a></span>change_type() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::change_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a>&#160;</td>
          <td class="paramname"><em>nutype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the data to the new type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nutype</td><td>new data type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6430319a01ff1931cf0d88fb92abca6e" name="a6430319a01ff1931cf0d88fb92abca6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6430319a01ff1931cf0d88fb92abca6e">&#9670;&nbsp;</a></span>channels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::channels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a867c0564aeba2d80617b4f3b6be737da" name="a867c0564aeba2d80617b4f3b6be737da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867c0564aeba2d80617b4f3b6be737da">&#9670;&nbsp;</a></span>channels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::channels </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30d9c3a12d258a7344378aeb8e56eed6" name="a30d9c3a12d258a7344378aeb8e56eed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d9c3a12d258a7344378aeb8e56eed6">&#9670;&nbsp;</a></span>channels_to_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::channels_to_images </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab123614e965e5ca895a14ccf30c234a5" name="ab123614e965e5ca895a14ccf30c234a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab123614e965e5ca895a14ccf30c234a5">&#9670;&nbsp;</a></span>check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks an image for reasonable properties. </p>

</div>
</div>
<a id="a49f620f446bf442126513d907d05752a" name="a49f620f446bf442126513d907d05752a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f620f446bf442126513d907d05752a">&#9670;&nbsp;</a></span>check_compoundtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Bimage::check_compoundtype </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a>&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a981cab4e4430114b52918a2791586777" name="a981cab4e4430114b52918a2791586777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981cab4e4430114b52918a2791586777">&#9670;&nbsp;</a></span>check_if_same_image_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Bimage::check_if_same_image_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two images are the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>image to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool 1 if yes, 0 if no. <pre class="fragment">The function returns the answer and leaves the calling function to 
deal with the result.
</pre> </dd></dl>

</div>
</div>
<a id="a881571949007af044036c47b07b8a3c6" name="a881571949007af044036c47b07b8a3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881571949007af044036c47b07b8a3c6">&#9670;&nbsp;</a></span>check_if_same_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Bimage::check_if_same_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two images are the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>image to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool 1 if yes, 0 if no. <pre class="fragment">The function returns the answer and leaves the calling function to 
deal with the result.
</pre> </dd></dl>

</div>
</div>
<a id="af285f9b976519ffee80fd03a19db17eb" name="af285f9b976519ffee80fd03a19db17eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af285f9b976519ffee80fd03a19db17eb">&#9670;&nbsp;</a></span>check_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::check_neighbors </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check neighbors in region map and assign a value if a neighbor is assigned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>index in multi-image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long new value assigned. </dd></dl>

</div>
</div>
<a id="a4a35640e535bfe59e5e9fbe19a7980d3" name="a4a35640e535bfe59e5e9fbe19a7980d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a35640e535bfe59e5e9fbe19a7980d3">&#9670;&nbsp;</a></span>check_point_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::check_point_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a> &amp;&#160;</td>
          <td class="paramname"><em>check_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for the requested symmetries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;check_string</td><td>string with requested point groups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double symmetry correlation coefficient. <pre class="fragment">Requirement: The input map must be in standard orientation for the symmetry.
For each different symmetry operation, the map is rotated and compared by
real space correlation to the original. 
</pre> </dd></dl>

</div>
</div>
<a id="ad464e07a4843fb9d38eb11345b2325b6" name="ad464e07a4843fb9d38eb11345b2325b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad464e07a4843fb9d38eb11345b2325b6">&#9670;&nbsp;</a></span>check_resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::check_resolution </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the resolution falls within reasonable limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;resolution</td><td>resolution (modified). <pre class="fragment">The resolution is set to between half the real size and the Nyquist frequency.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74e389c2208e3cae5d498ec60fd95a75" name="a74e389c2208e3cae5d498ec60fd95a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e389c2208e3cae5d498ec60fd95a75">&#9670;&nbsp;</a></span>check_sampling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::check_sampling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the sampling is properly specified. </p>
<pre class="fragment">If the sampling is zero or less it is set to 1.
If a dimension size is one, the sampling is set to 1.
</pre> 
</div>
</div>
<a id="ab64a1edf3326cf703a0b596059704889" name="ab64a1edf3326cf703a0b596059704889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64a1edf3326cf703a0b596059704889">&#9670;&nbsp;</a></span>chirp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::chirp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq_shift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a chirp image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq_scale</td><td>frequency scale. </td></tr>
    <tr><td class="paramname">freq_shift</td><td>frequency shift (radians). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="ab8db25e2cb2d3057af80e8469cd3cb77" name="ab8db25e2cb2d3057af80e8469cd3cb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8db25e2cb2d3057af80e8469cd3cb77">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af778ba174284334f20ddef7fc191b249" name="af778ba174284334f20ddef7fc191b249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af778ba174284334f20ddef7fc191b249">&#9670;&nbsp;</a></span>cmyk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_m_y_k.html">CMYK</a>&lt; double &gt; Bimage::cmyk </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a color value at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMYK&lt;double&gt; the color value. <pre class="fragment">The index refers to compound values.
</pre> </dd></dl>

</div>
</div>
<a id="a9e0de82e5c0833c271bbda9847f8cbe2" name="a9e0de82e5c0833c271bbda9847f8cbe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0de82e5c0833c271bbda9847f8cbe2">&#9670;&nbsp;</a></span>cmyk_to_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::cmyk_to_rgb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="class_c_m_y_k.html">CMYK</a> color image to <a class="el" href="class_r_g_b.html">RGB</a>. </p>

</div>
</div>
<a id="aa2898f1eaaf5f0236e239fe49494849d" name="aa2898f1eaaf5f0236e239fe49494849d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2898f1eaaf5f0236e239fe49494849d">&#9670;&nbsp;</a></span>color_blue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::color_blue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a gray-scale image to blue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmin</td><td>lower grayscale boundary. </td></tr>
    <tr><td class="paramname">cmax</td><td>upper grayscale boundary. </td></tr>
    <tr><td class="paramname">flag</td><td>sets the type of conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">A grayscale image is converted to blue between the given minimum and maximum.
</pre> </dd></dl>

</div>
</div>
<a id="ab143e87ca8f289a3ea65566a4c77fbb0" name="ab143e87ca8f289a3ea65566a4c77fbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab143e87ca8f289a3ea65566a4c77fbb0">&#9670;&nbsp;</a></span>color_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::color_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines two colored images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">Each pair of voxels is summed and the result truncated to 255.
</pre> </dd></dl>

</div>
</div>
<a id="a644d535bf1c94569270c32f4d0c0ef40" name="a644d535bf1c94569270c32f4d0c0ef40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644d535bf1c94569270c32f4d0c0ef40">&#9670;&nbsp;</a></span>color_green()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::color_green </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a gray-scale image to green. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmin</td><td>lower grayscale boundary. </td></tr>
    <tr><td class="paramname">cmax</td><td>upper grayscale boundary. </td></tr>
    <tr><td class="paramname">flag</td><td>sets the type of conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">A grayscale image is converted to green between the given minimum and maximum.
</pre> </dd></dl>

</div>
</div>
<a id="abfb6e880fab0904b9702007876322ab6" name="abfb6e880fab0904b9702007876322ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb6e880fab0904b9702007876322ab6">&#9670;&nbsp;</a></span>color_red()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::color_red </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a gray-scale image to red. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmin</td><td>lower grayscale boundary. </td></tr>
    <tr><td class="paramname">cmax</td><td>upper grayscale boundary. </td></tr>
    <tr><td class="paramname">flag</td><td>sets the type of conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">A grayscale image is converted to red between the given minimum and maximum.
</pre> </dd></dl>

</div>
</div>
<a id="ac8cb2a5aa2fc05dc884221e6cc3e7c28" name="ac8cb2a5aa2fc05dc884221e6cc3e7c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cb2a5aa2fc05dc884221e6cc3e7c28">&#9670;&nbsp;</a></span>color_spectrum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::color_spectrum </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Colorizes an image to a spectrum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmin</td><td>lower grayscale boundary. </td></tr>
    <tr><td class="paramname">cmax</td><td>upper grayscale boundary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* color scale image. <pre class="fragment">A grayscale image is converted to RGB and colored from blue (low) to 
red (high). Only the values between the given minimum and maximum is used.
</pre> </dd></dl>

</div>
</div>
<a id="ab7280ee72a088440e3d190ed9203afe8" name="ab7280ee72a088440e3d190ed9203afe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7280ee72a088440e3d190ed9203afe8">&#9670;&nbsp;</a></span>color_to_simple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::color_to_simple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A color image is converted to a simple image. </p>
<pre class="fragment">The new value for each voxel is the average of the RGB color values.
</pre> 
</div>
</div>
<a id="ad307b8fb1ce8c72a850c3ceb0fe89002" name="ad307b8fb1ce8c72a850c3ceb0fe89002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad307b8fb1ce8c72a850c3ceb0fe89002">&#9670;&nbsp;</a></span>combine_channels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::combine_channels </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a>&#160;</td>
          <td class="paramname"><em>ct</em> = <code><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36ad83a0f556634bd31d3357be2a64aac4c">TSimple</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines images as channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nc</td><td>number of channels to create. </td></tr>
    <tr><td class="paramname">ct</td><td>compound type. <pre class="fragment">The input image is replaced with a new image.
If the compound type is single value, the compound type
is inferred from the number of channels.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71edead8db40d0773892175a7b5b7a2a" name="a71edead8db40d0773892175a7b5b7a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71edead8db40d0773892175a7b5b7a2a">&#9670;&nbsp;</a></span>combined_complex_product() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::combined_complex_product </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images. </p>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Requirement: Fourier transform of two images packed into one complex
    data block with the function Bimage::pack_two_in_complex and then
    transformed with the function Bimage::fft.
The Friedel relationships in transforms from real space images are
exploited to transform two images simultaneously and then extract
the individual transforms from the complex data set.
This function extracts the individual transforms and calculates the 
complex conjugate product used in cross-correlation.
The result is scaled by the total power of the two transforms, yielding 
the correlation coefficient when the product is backtransformed into 
the cross-correlation map.
</pre> </dd></dl>

</div>
</div>
<a id="a8f205cb70f7ea0a38369ae7c6f2b5222" name="a8f205cb70f7ea0a38369ae7c6f2b5222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f205cb70f7ea0a38369ae7c6f2b5222">&#9670;&nbsp;</a></span>combined_complex_product() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::combined_complex_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>binary mask (only 0 and 1), NULL if not desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Requirement: Fourier transform of two images packed into one complex
    data block with the function Bimage::pack_two_in_complex and then
    transformed with the function Bimage::fft.
The Friedel relationships in transforms from real space images are
exploited to transform two images simultaneously and then extract
the individual transforms from the complex data set.
This function extracts the individual transforms and calculates the 
complex conjugate product used in cross-correlation.
The result is scaled by the total power of the two transforms, yielding 
the correlation coefficient when the product is backtransformed into 
the cross-correlation map.
</pre> </dd></dl>

</div>
</div>
<a id="a31ff4d6148499e24377c45428ec8c73a" name="a31ff4d6148499e24377c45428ec8c73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ff4d6148499e24377c45428ec8c73a">&#9670;&nbsp;</a></span>combined_complex_product() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::combined_complex_product </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Requirement: Fourier transform of two images packed into one complex
    data block with the function Bimage::pack_two_in_complex and then
    transformed with the function Bimage::fft.
The Friedel relationships in transforms from real space images are
exploited to transform two images simultaneously and then extract
the individual transforms from the complex data set.
This function extracts the individual transforms and calculates the 
complex conjugate product used in cross-correlation.
The result is scaled by the total power of the two transforms within
the resolution limits, yielding the correlation coefficient when
the product is backtransformed into the cross-correlation map.
</pre> </dd></dl>

</div>
</div>
<a id="aa03855b78911b0811e1208885cffc98e" name="aa03855b78911b0811e1208885cffc98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03855b78911b0811e1208885cffc98e">&#9670;&nbsp;</a></span>combined_complex_product() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::combined_complex_product </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">*pmask</td><td>binary mask (only 0 and 1), NULL if not desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Requirement: Fourier transform of two images packed into one complex
    data block with the function Bimage::pack_two_in_complex and then
    transformed with the function Bimage::fft.
The Friedel relationships in transforms from real space images are
exploited to transform two images simultaneously and then extract
the individual transforms from the complex data set.
This function extracts the individual transforms and calculates the 
complex conjugate product used in cross-correlation.
The result is scaled by the total power of the two transforms within
the resolution limits, yielding the correlation coefficient when
the product is backtransformed into the cross-correlation map.
</pre> </dd></dl>

</div>
</div>
<a id="a415d393255e21b878bfdc574146a40e8" name="a415d393255e21b878bfdc574146a40e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415d393255e21b878bfdc574146a40e8">&#9670;&nbsp;</a></span>combined_complex_product_implicit_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::combined_complex_product_implicit_mask </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Requirement: Fourier transform of two images packed into one complex
    data block with the function Bimage::pack_two_in_complex and then
    transformed with the function Bimage::fft.
The Friedel relationships in transforms from real space images are
exploited to transform two images simultaneously and then extract
the individual transforms from the complex data set.
This function extracts the individual transforms and calculates the 
complex conjugate product used in cross-correlation.
An implicit mask is assumed: Only non-zero values in both transforms are considered.
The result is scaled by the total power of the two transforms within
the resolution limits, yielding the correlation coefficient when
the product is backtransformed into the cross-correlation map.
</pre> </dd></dl>

</div>
</div>
<a id="a2bb42c15f87e1e551f9d2dbef8491dcd" name="a2bb42c15f87e1e551f9d2dbef8491dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb42c15f87e1e551f9d2dbef8491dcd">&#9670;&nbsp;</a></span>compatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Bimage::compatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this image has the same number of channels and data type as another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>reference image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool 1 if yes, 0 if no. <pre class="fragment">The function returns the answer and leaves the calling function to 
deal with the result.
</pre> </dd></dl>

</div>
</div>
<a id="a7feb28efaaf52eddebd38d00066a1a2e" name="a7feb28efaaf52eddebd38d00066a1a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7feb28efaaf52eddebd38d00066a1a2e">&#9670;&nbsp;</a></span>complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_complex.html">Complex</a>&lt; double &gt; Bimage::complex </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a complex value at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complex&lt;double&gt; the complex floating point value. <pre class="fragment">The index refers to compound values.
</pre> </dd></dl>

</div>
</div>
<a id="a409f4fa58ef28c6cd7f591a8a89d574c" name="a409f4fa58ef28c6cd7f591a8a89d574c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409f4fa58ef28c6cd7f591a8a89d574c">&#9670;&nbsp;</a></span>complex_apply_dual_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::complex_apply_dual_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a dual mask to a complex image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>mask (converted to floating point). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">The mask is applied to an image, generating two images, the first 
with values retained where the mask is positive, and the second with
values where the mask is negative.
The input image is replaced and the second is created and linked to
the first.
Requirement: The two input images must be the same size.
No statistics are calculated.
</pre> </dd></dl>

</div>
</div>
<a id="a900f7f590e1626c8f521e731cb4a9043" name="a900f7f590e1626c8f521e731cb4a9043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900f7f590e1626c8f521e731cb4a9043">&#9670;&nbsp;</a></span>complex_apply_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::complex_apply_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a mask to a complex image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>mask (converted to floating point). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Wherever the mask is &lt;= 0, the data is set to zero.
Requirement: The two images must be the same size.
No statistics are calculated.
</pre> </dd></dl>

</div>
</div>
<a id="ab46eac20f607c7922eef77c90a40a832" name="ab46eac20f607c7922eef77c90a40a832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46eac20f607c7922eef77c90a40a832">&#9670;&nbsp;</a></span>complex_apply_negative_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::complex_apply_negative_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a negative mask to a complex image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>mask (converted to floating point). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Wherever the mask is &gt;= 0, the data is set to zero.
Requirement: The two images must be the same size.
No statistics are calculated.
</pre> </dd></dl>

</div>
</div>
<a id="adcacc4e756f549b1bb2a60b13ae93a00" name="adcacc4e756f549b1bb2a60b13ae93a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcacc4e756f549b1bb2a60b13ae93a00">&#9670;&nbsp;</a></span>complex_bandpass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::complex_bandpass </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bandpasses a Fourier transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Requirement: a complex Fourier transform.
All data outside the band limits are set to zero.
</pre> </dd></dl>

</div>
</div>
<a id="a6c83144b13c3a4c25a7ef4ec9fcf6685" name="a6c83144b13c3a4c25a7ef4ec9fcf6685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c83144b13c3a4c25a7ef4ec9fcf6685">&#9670;&nbsp;</a></span>complex_conjugate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::complex_conjugate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the complex conjugate image. </p>

</div>
</div>
<a id="a2869ea078baf18fbde181f9831c9bc6f" name="a2869ea078baf18fbde181f9831c9bc6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2869ea078baf18fbde181f9831c9bc6f">&#9670;&nbsp;</a></span>complex_conjugate_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::complex_conjugate_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the product of a complex image with the conjugate of a second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>complex image. </td></tr>
    <tr><td class="paramname">norm</td><td>normalize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Complex conjugate product:
    (a + ib)*(c - id) = (a*c + b*d) + i(b*c - a*d).
Requirement: The two images must be the same size.
No statistics are calculated.
</pre> </dd></dl>

</div>
</div>
<a id="af23fee98976ac23c37ce16d7feac9ee0" name="af23fee98976ac23c37ce16d7feac9ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23fee98976ac23c37ce16d7feac9ee0">&#9670;&nbsp;</a></span>complex_conjugate_product_one2many()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::complex_conjugate_product_one2many </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the product of a complex image with the conjugate of a second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>complex image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Complex conjugate product:
    (a + ib)*(c - id) = (a*c + b*d) + i(b*c - a*d).
Requirement: The two images must be the same size.
No statistics are calculated.
</pre> </dd></dl>

</div>
</div>
<a id="af9dd2401fc3d59bde6d222d8979d12af" name="af9dd2401fc3d59bde6d222d8979d12af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9dd2401fc3d59bde6d222d8979d12af">&#9670;&nbsp;</a></span>complex_multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::complex_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the product of a complex image with a simple image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>simple image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Requirement: The two images must be the same size.
No statistics are calculated.
</pre> </dd></dl>

</div>
</div>
<a id="ad52f5efd5dad2c089de6c1acbb47bb37" name="ad52f5efd5dad2c089de6c1acbb47bb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52f5efd5dad2c089de6c1acbb47bb37">&#9670;&nbsp;</a></span>complex_normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::complex_normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the power in a complex image. </p>
<dl class="section return"><dt>Returns</dt><dd>double power. <pre class="fragment">The first element is set to zero.
The image is scaled by the remaining total power, i.e., the sum of the intensities.
</pre> </dd></dl>

</div>
</div>
<a id="af0390feeaaed888509327745aad01f27" name="af0390feeaaed888509327745aad01f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0390feeaaed888509327745aad01f27">&#9670;&nbsp;</a></span>complex_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::complex_power </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the power in a complex image. </p>
<dl class="section return"><dt>Returns</dt><dd>double power. <pre class="fragment">The first element is set to zero.
The image is scaled by the remaining total power, i.e., the sum of the intensities.
</pre> </dd></dl>

</div>
</div>
<a id="ac7177b199823a9ccbf78fc65f1042038" name="ac7177b199823a9ccbf78fc65f1042038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7177b199823a9ccbf78fc65f1042038">&#9670;&nbsp;</a></span>complex_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::complex_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the complex product of two complex images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>complex image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Complex product:
    (a + ib)*(c + id) = (a*c - b*d) + i(b*c + a*d).
Requirement: The two images must be the same size.
No statistics are calculated.
</pre> </dd></dl>

</div>
</div>
<a id="a484243844b17ec9265365545c5087044" name="a484243844b17ec9265365545c5087044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484243844b17ec9265365545c5087044">&#9670;&nbsp;</a></span>complex_to_amplitudes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::complex_to_amplitudes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The amplitudes from a complex image is written to a simple image. </p>

</div>
</div>
<a id="a3902e92c0036d0d8f812a271f932a0c8" name="a3902e92c0036d0d8f812a271f932a0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3902e92c0036d0d8f812a271f932a0c8">&#9670;&nbsp;</a></span>complex_to_imaginary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::complex_to_imaginary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The imaginary part of a complex image is written to a simple image. </p>

</div>
</div>
<a id="ab9a5fe205d012073c5bc2a902ca3e95a" name="ab9a5fe205d012073c5bc2a902ca3e95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a5fe205d012073c5bc2a902ca3e95a">&#9670;&nbsp;</a></span>complex_to_intensities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::complex_to_intensities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The intensities from a complex image is written to a simple image. </p>

</div>
</div>
<a id="acfcb9c3eab00573289c72f6ee24ed20c" name="acfcb9c3eab00573289c72f6ee24ed20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcb9c3eab00573289c72f6ee24ed20c">&#9670;&nbsp;</a></span>complex_to_phases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::complex_to_phases </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The phases from a complex image is written to a simple image. </p>

</div>
</div>
<a id="ad9d1522e62412070a4694482067f3532" name="ad9d1522e62412070a4694482067f3532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d1522e62412070a4694482067f3532">&#9670;&nbsp;</a></span>complex_to_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::complex_to_real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The real part of a complex image is written to a simple image. </p>

</div>
</div>
<a id="a7d2e55ed269cd9f3bd954ce2f9d18ed0" name="a7d2e55ed269cd9f3bd954ce2f9d18ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2e55ed269cd9f3bd954ce2f9d18ed0">&#9670;&nbsp;</a></span>complex_to_signed_amplitudes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::complex_to_signed_amplitudes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The signed amplitudes from a complex image is written to a simple image. </p>

</div>
</div>
<a id="a94f685cb874a2593c8520b18962be360" name="a94f685cb874a2593c8520b18962be360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f685cb874a2593c8520b18962be360">&#9670;&nbsp;</a></span>compound_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a> Bimage::compound_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2ad0e179f96e2d7fa0bb02d9853c1b6" name="aa2ad0e179f96e2d7fa0bb02d9853c1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ad0e179f96e2d7fa0bb02d9853c1b6">&#9670;&nbsp;</a></span>compound_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::compound_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a>&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba25aac6daf2be313372df9017583703" name="aba25aac6daf2be313372df9017583703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba25aac6daf2be313372df9017583703">&#9670;&nbsp;</a></span>compound_type_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::compound_type_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d7eaa823a3e59fde34b41efa65bc64f" name="a6d7eaa823a3e59fde34b41efa65bc64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7eaa823a3e59fde34b41efa65bc64f">&#9670;&nbsp;</a></span>compound_type_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bstring.html">Bstring</a> Bimage::compound_type_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string representation of a datatype. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_bstring.html">Bstring</a> string representation of a datatype. </dd></dl>

</div>
</div>
<a id="aaff64a952f50ef4f0d7752823927a842" name="aaff64a952f50ef4f0d7752823927a842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff64a952f50ef4f0d7752823927a842">&#9670;&nbsp;</a></span>convert_to_helix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::convert_to_helix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>helix_rise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>helix_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a map to a helix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">helix_rise</td><td>rise per asymmetric unit </td></tr>
    <tr><td class="paramname">helix_angle</td><td>rotation angle per asymmetric unit. </td></tr>
    <tr><td class="paramname">offset</td><td>offset in the xy plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double 0. <pre class="fragment">The data is offset from the central axis based on helical parameters along the axis.
The data is rotated around the offset vector based on the helix rise 
and helix angle by an angle:
                  distance * (1 - cos(helix_angle))
    angle2 = atan ---------------------------------
                            helix_rise
</pre> </dd></dl>

</div>
</div>
<a id="a256555f8b2178b4a267fb0be752656ad" name="a256555f8b2178b4a267fb0be752656ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256555f8b2178b4a267fb0be752656ad">&#9670;&nbsp;</a></span>convolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::convolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pkernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolves an image with an arbitrary size convolution filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pkernel</td><td>kernel encoded as an image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">The kernel is multiplied with each area surrounding the current voxel
with wrapping to avoid image edge effects.
The convolution is threaded if compiled with OpenMP.
</pre> </dd></dl>

</div>
</div>
<a id="adc7a8b3e3bb82e5b64e47780ad3b41a0" name="adc7a8b3e3bb82e5b64e47780ad3b41a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7a8b3e3bb82e5b64e47780ad3b41a0">&#9670;&nbsp;</a></span>convolve_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::convolve_chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pkernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>nudata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a676633c5f0620a1a3e65fa427eb513f4" name="a676633c5f0620a1a3e65fa427eb513f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676633c5f0620a1a3e65fa427eb513f4">&#9670;&nbsp;</a></span>coordinates() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; Bimage::coordinates </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16063cd8e18671cad87e0fa63b5b3858" name="a16063cd8e18671cad87e0fa63b5b3858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16063cd8e18671cad87e0fa63b5b3858">&#9670;&nbsp;</a></span>coordinates() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::coordinates </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f822e981215b18e7ee27df213fce0e" name="ad1f822e981215b18e7ee27df213fce0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f822e981215b18e7ee27df213fce0e">&#9670;&nbsp;</a></span>coordinates() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::coordinates </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8db6a06e7407d98678c38eb4787cc059" name="a8db6a06e7407d98678c38eb4787cc059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db6a06e7407d98678c38eb4787cc059">&#9670;&nbsp;</a></span>coordinates() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::coordinates </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d95c9ec5072c183f3a8f46856ad3c21" name="a5d95c9ec5072c183f3a8f46856ad3c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d95c9ec5072c183f3a8f46856ad3c21">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the header information and data of an image into a new image structure. </p>
<dl class="section return"><dt>Returns</dt><dd>Bimage* copied image, NULL if copy failed. </dd></dl>

</div>
</div>
<a id="ae857443aef660818821614dbf350a334" name="ae857443aef660818821614dbf350a334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae857443aef660818821614dbf350a334">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::copy </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nu_nimg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the header information and data of an image into a new image structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nu_nimg</td><td>new number of images (if &lt; 1, keep the old number) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* copied image, NULL if copy failed. </dd></dl>

</div>
</div>
<a id="ae19b4936a6ffeab24d4522a005e06400" name="ae19b4936a6ffeab24d4522a005e06400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19b4936a6ffeab24d4522a005e06400">&#9670;&nbsp;</a></span>copy_header() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::copy_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f33c5b1b205f62ce1bd85fd5f9fee3a" name="a6f33c5b1b205f62ce1bd85fd5f9fee3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f33c5b1b205f62ce1bd85fd5f9fee3a">&#9670;&nbsp;</a></span>copy_header() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::copy_header </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nu_nimg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy an image structure into a new one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nu_nimg</td><td>new number of images (if &lt; 1, keep the old number) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* the new image structure, NULL if copy failed. <pre class="fragment">All information from an old image structure is copied into a new one.
This takes care of the internal arrays in the structure.
The data pointer is left to point to the original data.
</pre> </dd></dl>

</div>
</div>
<a id="aa60f07470d38a7a7c791741e14b81792" name="aa60f07470d38a7a7c791741e14b81792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60f07470d38a7a7c791741e14b81792">&#9670;&nbsp;</a></span>correct_background() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::correct_background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Corrects the background for each sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>foreground mask. </td></tr>
    <tr><td class="paramname">flag</td><td>flag to specify where to calculate the background: [0,3] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The background is taken as the average of the values outside the
circle or sphere enclosed by the image.
If the mask is specified, it is used to define the foreground of the 
image. The correction then includes the area outside the circle or 
sphere as well as the area where the mask is zero.
</pre> </dd></dl>

</div>
</div>
<a id="ae097d0c9a4d324888c4225f6dc64eff5" name="ae097d0c9a4d324888c4225f6dc64eff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae097d0c9a4d324888c4225f6dc64eff5">&#9670;&nbsp;</a></span>correct_background() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::correct_background </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Corrects the background for each sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>flag to specify where to calculate the background: [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">The background is taken as the average of the values outside the
circle or sphere enclosed by the image.
</pre> </dd></dl>

</div>
</div>
<a id="ab4c22f850dcdc8bef046cb78707ac808" name="ab4c22f850dcdc8bef046cb78707ac808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c22f850dcdc8bef046cb78707ac808">&#9670;&nbsp;</a></span>correct_background() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::correct_background </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Corrects the background for one sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">flag</td><td>flag to specify where to calculate the background: [0,3] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">The background is taken as the average of the values outside the
circle or sphere enclosed by the image.
</pre> </dd></dl>

</div>
</div>
<a id="aed4f644bac0ee94020a3143500301f73" name="aed4f644bac0ee94020a3143500301f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4f644bac0ee94020a3143500301f73">&#9670;&nbsp;</a></span>correlate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::correlate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates correlation coefficient between two images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>image to correlate with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double correlation coefficient, -1 if not run. <pre class="fragment">The correlation between two images is calculated and normalized as:
               sum((image1 - avg1)*(image2 - avg2))
    CC = -------------------------------------------------
         sqrt(sum(image1 - avg1)^2 * sum(image2 - avg2)^2)
.
Both images are converted to floating point.
Only the first image is used.
</pre> </dd></dl>

</div>
</div>
<a id="a89a24a64c2a46d4e7605f46ae21c6518" name="a89a24a64c2a46d4e7605f46ae21c6518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a24a64c2a46d4e7605f46ae21c6518">&#9670;&nbsp;</a></span>correlate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::correlate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a correlation coefficient between two images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
    <tr><td class="paramname">rmin</td><td>minimum radius (pixel units). </td></tr>
    <tr><td class="paramname">rmax</td><td>maximum radius (pixel units). </td></tr>
    <tr><td class="paramname">*pmask</td><td>mask (can be NULL). </td></tr>
    <tr><td class="paramname">flag</td><td>flag to modify second image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double correlation coefficient, -1 if error. <pre class="fragment">The correlation between two images is calculated and normalized as:
             sum((image1 - avg1)*(image2 - avg2))
    CC = -------------------------------------------------
         sqrt(sum(image1 - avg1)^2 * sum(image2 - avg2)^2)
</pre> </dd></dl>

</div>
</div>
<a id="a116466a5ea13f35a581948624a4697ce" name="a116466a5ea13f35a581948624a4697ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116466a5ea13f35a581948624a4697ce">&#9670;&nbsp;</a></span>correlate_annuli()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::correlate_annuli </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>polref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ann_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ann_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ang_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ang_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cc_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlate annuli of a polar image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*polref</td><td>reference image polar power spectrum transform. </td></tr>
    <tr><td class="paramname">ann_min</td><td>low resolution cutoff (in inverse pixels). </td></tr>
    <tr><td class="paramname">ann_max</td><td>high resolution cutoff (in inverse pixels). </td></tr>
    <tr><td class="paramname">ang_min</td><td>minimum angle to test for (radians). </td></tr>
    <tr><td class="paramname">ang_max</td><td>maximum angle to test for (radians). </td></tr>
    <tr><td class="paramname">planf</td><td>FFT forward plan. </td></tr>
    <tr><td class="paramname">planb</td><td>FFT backward plan. </td></tr>
    <tr><td class="paramname">&amp;cc_max</td><td>pointer to correlation coefficient for return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double angle. <pre class="fragment">The input images must be transformed polar images, with each annulus
corresponding to a row in the image.
The polar image annuli between the given limits are cross-correlated
one by one, and a sum of all annuli calculated, weighted by annulus index.
The maximum value in the annulus sum corresponds to the best fit angle.
Both image and mirror image are assessed, yielding a negative angle
when the mirror image gives a larger correlation.
FFTW library (www.fftw.org).
</pre> </dd></dl>

</div>
</div>
<a id="ab4398066bdddc4ac4723c27a3e57ce30" name="ab4398066bdddc4ac4723c27a3e57ce30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4398066bdddc4ac4723c27a3e57ce30">&#9670;&nbsp;</a></span>correlation_coefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::correlation_coefficient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a coefficient from a Fourier correlation transform given a shift. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td>real space shift. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double correlation coefficient. <pre class="fragment">The input image is a cross-correlation transform.
A brute force backtransform integration is done for the given shift to 
calculate the corresponding correlation coefficient.
</pre> </dd></dl>

</div>
</div>
<a id="a0f481c1c9810e140e206aae8cb243901" name="a0f481c1c9810e140e206aae8cb243901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f481c1c9810e140e206aae8cb243901">&#9670;&nbsp;</a></span>cross_correlate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::cross_correlate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66dd9d3e57b245ffbb8c6aaf071b48b2" name="a66dd9d3e57b245ffbb8c6aaf071b48b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66dd9d3e57b245ffbb8c6aaf071b48b2">&#9670;&nbsp;</a></span>cross_correlate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::cross_correlate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >write_img("pccp.mrc", pc, 0);</p>

</div>
</div>
<a id="a733932c8d5fe80fb2d9677e1052f53e7" name="a733932c8d5fe80fb2d9677e1052f53e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733932c8d5fe80fb2d9677e1052f53e7">&#9670;&nbsp;</a></span>cross_correlate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::cross_correlate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a cross-correlation map by Fast Fourier transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">*pmask</td><td>binary mask (only 0 and 1), NULL if not desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* cross-correlation image. <pre class="fragment">FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D real space data sets are 
packed into a complex data set and transformed forward. The transform
is unpacked before the first transform is multiplied with the complex 
conjugate of the second transform. This is then back-transformed to 
obtain the cross-correlation map in real space.
The low resolution limit can be 0, in which case no limits are applied.
The resultant cross-correlation image data type is floating point.
</pre> </dd></dl>

</div>
</div>
<a id="aee3980b2fbc7486c0b2e5d1f0f23a527" name="aee3980b2fbc7486c0b2e5d1f0f23a527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3980b2fbc7486c0b2e5d1f0f23a527">&#9670;&nbsp;</a></span>cross_correlate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::cross_correlate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a cross-correlation map by Fast Fourier transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">planf</td><td>forward transform plan. </td></tr>
    <tr><td class="paramname">planb</td><td>backward transform plan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* cross-correlation image. <pre class="fragment">FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D real space data sets are 
packed into a complex data set and transformed forward. The transform
is unpacked before the first transform is multiplied with the complex 
conjugate of the second transform. This is then back-transformed to 
obtain the cross-correlation map in real space.
Zero-valued data in the transforms are implicitly excluded.
The low resolution limit can be 0, in which case no limits are applied.
The resultant cross-correlation image data type is floating point.
</pre> </dd></dl>

</div>
</div>
<a id="a94c6007300a2ac6ee727bce03547aadb" name="a94c6007300a2ac6ee727bce03547aadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c6007300a2ac6ee727bce03547aadb">&#9670;&nbsp;</a></span>cross_correlate_fspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::cross_correlate_fspace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a cross-correlation map by Fast Fourier transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">shift_limit</td><td>maximum real space shift. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* cross-correlation image. <pre class="fragment">FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D real space data sets are 
packed into a complex data set and transformed forward. The transform
is unpacked before the first transform is multiplied with the complex 
conjugate of the second transform. This is then back-transformed to 
obtain the cross-correlation map in real space.
The low resolution limit can be 0, in which case no limits are applied.
The resultant cross-correlation image data type is floating point.
</pre> </dd></dl>

</div>
</div>
<a id="a7e0623b75a864ebcc25ee4cb13cd3249" name="a7e0623b75a864ebcc25ee4cb13cd3249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0623b75a864ebcc25ee4cb13cd3249">&#9670;&nbsp;</a></span>cross_correlate_two_way()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::cross_correlate_two_way </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a cross-correlation map by Fast Fourier transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">planf</td><td>FFT forward plan. </td></tr>
    <tr><td class="paramname">planb</td><td>FFT backward plan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* cross-correlation image. <pre class="fragment">FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D real space data sets are 
packed into a complex data set and transformed forward. The transform
is bandpass filtered to the given resolution limits and unpacked.
The two transforms are normalized, and multiplied in two ways:
    prod1 = data1 * data2.conjugate
    prod2 = data1 * data2
The second product represents a cross-correlation with a 180 degree 
rotation of the second image.
Both are back-transformed to obtain the two cross-correlation map in real space.
The one with the highest maximum is selected to return.
The resultant cross-correlation image data type is floating point.
The angle in the cross-correlation image is set to zero if the first
map is selected, otherwise it is set to PI.
</pre> </dd></dl>

</div>
</div>
<a id="a0ae039957d4ef654accb7a9d6533e207" name="a0ae039957d4ef654accb7a9d6533e207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae039957d4ef654accb7a9d6533e207">&#9670;&nbsp;</a></span>cross_correlate_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::cross_correlate_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a masked cross-correlation map by Fast Fourier transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
    <tr><td class="paramname">*pmask</td><td>binary mask (only 0 and 1), NULL if not desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* cross-correlation image. <pre class="fragment">FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D real space data sets are 
packed into a complex data set and transformed forward. The transform
is unpacked and masked with mask image before the first transform is
multiplied with the complex conjugate of the second transform. This is 
then back-transformed to obtain the cross-correlation map in real space.
The mask must be composed of 0 and 1, and is converted to floating point.
The mask can be omitted (NULL).
The resultant cross-correlation image data type is floating point.
</pre> </dd></dl>

</div>
</div>
<a id="abfe49c9cdf6885b620cf141fb8ef081d" name="abfe49c9cdf6885b620cf141fb8ef081d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe49c9cdf6885b620cf141fb8ef081d">&#9670;&nbsp;</a></span>cylinder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::cylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a cylinder within an image with a uniform value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>three vector center of cylinder. </td></tr>
    <tr><td class="paramname">radius</td><td>cylinder radius. </td></tr>
    <tr><td class="paramname">height</td><td>cylinder heigth. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of smoothing function. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">All voxels within a cylinder at a given location are set to a given fill value.
The height is along the z-direction.
The new data replaces the old data.
The default center is {0,0,0}.
</pre> </dd></dl>

</div>
</div>
<a id="a0a2ba8a5f6c80e5ac4e9b52a87e907f8" name="a0a2ba8a5f6c80e5ac4e9b52a87e907f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2ba8a5f6c80e5ac4e9b52a87e907f8">&#9670;&nbsp;</a></span>cylindrical_shells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::cylindrical_shells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an image with slices representing cylindrical shell projections. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The 3D image is converted so that the sections contain 2D projections
of cylindrical shells. The projection in slice i is defined for:
    i &gt;= sqrt(x^2 + y^2)
The first projection is placed at the z origin and radiates out into
both positive and negative directions.
Sampling in x and y is not changed.
The sampling must be isotropic.
</pre> </dd></dl>

</div>
</div>
<a id="a166ca3b55bdab6020603df0f06f53948" name="a166ca3b55bdab6020603df0f06f53948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166ca3b55bdab6020603df0f06f53948">&#9670;&nbsp;</a></span>data_alloc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * Bimage::data_alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a6de434ebeb11ba2ade23d9d463270a" name="a6a6de434ebeb11ba2ade23d9d463270a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6de434ebeb11ba2ade23d9d463270a">&#9670;&nbsp;</a></span>data_alloc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * Bimage::data_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a>&#160;</td>
          <td class="paramname"><em>ctype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate image data with size parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>data type. </td></tr>
    <tr><td class="paramname">ctype</td><td>compound type. </td></tr>
    <tr><td class="paramname">nx</td><td>x dimension. </td></tr>
    <tr><td class="paramname">ny</td><td>y dimension. </td></tr>
    <tr><td class="paramname">nz</td><td>z dimension. </td></tr>
    <tr><td class="paramname">nn</td><td>number of sub-images. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned char* pointer to data. <pre class="fragment">The image parameters are set and a new data block allocated.
</pre> </dd></dl>

</div>
</div>
<a id="a58ea567d0cdd61f54b15ada3663dfce1" name="a58ea567d0cdd61f54b15ada3663dfce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ea567d0cdd61f54b15ada3663dfce1">&#9670;&nbsp;</a></span>data_alloc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * Bimage::data_alloc </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nbytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate image data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbytes</td><td>number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned char* pointer to data. <pre class="fragment">Any old data block is deleted.
</pre> </dd></dl>

</div>
</div>
<a id="af21fcbb3113b902a3027f9c7a8a77ac5" name="af21fcbb3113b902a3027f9c7a8a77ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21fcbb3113b902a3027f9c7a8a77ac5">&#9670;&nbsp;</a></span>data_alloc_and_clear() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * Bimage::data_alloc_and_clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa80310f2ba9fc1adee9bc384daf0f546" name="aa80310f2ba9fc1adee9bc384daf0f546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80310f2ba9fc1adee9bc384daf0f546">&#9670;&nbsp;</a></span>data_alloc_and_clear() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * Bimage::data_alloc_and_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a>&#160;</td>
          <td class="paramname"><em>ctype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a557e656fd78fb72403170ef3da4f6391" name="a557e656fd78fb72403170ef3da4f6391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557e656fd78fb72403170ef3da4f6391">&#9670;&nbsp;</a></span>data_alloc_and_clear() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * Bimage::data_alloc_and_clear </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nbytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a997d17b3f9bbd3a5b13450b0379c1aa5" name="a997d17b3f9bbd3a5b13450b0379c1aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997d17b3f9bbd3a5b13450b0379c1aa5">&#9670;&nbsp;</a></span>data_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * Bimage::data_assign </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>nudata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign image data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*nudata</td><td>allocated data pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned char* pointer to data. <pre class="fragment">Note: The size of the data block must correspond to the image dimensions!
</pre> </dd></dl>

</div>
</div>
<a id="afde298560de4552e4abda21507882d29" name="afde298560de4552e4abda21507882d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde298560de4552e4abda21507882d29">&#9670;&nbsp;</a></span>data_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::data_delete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates the image data. </p>

</div>
</div>
<a id="aab570544ea8a468fc75005223bce4faf" name="aab570544ea8a468fc75005223bce4faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab570544ea8a468fc75005223bce4faf">&#9670;&nbsp;</a></span>data_offset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::data_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d42f4d6f9070c0ec55e68b78eb3c9f0" name="a2d42f4d6f9070c0ec55e68b78eb3c9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d42f4d6f9070c0ec55e68b78eb3c9f0">&#9670;&nbsp;</a></span>data_offset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::data_offset </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>doff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8692aa9f36d2bf5d4a729740e342b039" name="a8692aa9f36d2bf5d4a729740e342b039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8692aa9f36d2bf5d4a729740e342b039">&#9670;&nbsp;</a></span>data_pointer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * Bimage::data_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ce227603aa919e5a72b14d7120ca1ce" name="a5ce227603aa919e5a72b14d7120ca1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce227603aa919e5a72b14d7120ca1ce">&#9670;&nbsp;</a></span>data_pointer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * Bimage::data_pointer </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb4232f60f0d0582b7208845757a2c1a" name="afb4232f60f0d0582b7208845757a2c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4232f60f0d0582b7208845757a2c1a">&#9670;&nbsp;</a></span>data_pointer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::data_pointer </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d289504ed427397f78837e881dc6ca3" name="a3d289504ed427397f78837e881dc6ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d289504ed427397f78837e881dc6ca3">&#9670;&nbsp;</a></span>data_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::data_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f8daaa394b40c3d3fec19e544125e5c" name="a3f8daaa394b40c3d3fec19e544125e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8daaa394b40c3d3fec19e544125e5c">&#9670;&nbsp;</a></span>data_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> Bimage::data_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a682d0ecb697de9856110a4ad841fb70c" name="a682d0ecb697de9856110a4ad841fb70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682d0ecb697de9856110a4ad841fb70c">&#9670;&nbsp;</a></span>data_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::data_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a>&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5b8a851da4087a959b592c4645c755b" name="ab5b8a851da4087a959b592c4645c755b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b8a851da4087a959b592c4645c755b">&#9670;&nbsp;</a></span>data_type_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::data_type_bits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the datatype in bits. </p>
<dl class="section return"><dt>Returns</dt><dd>long data type size in bits. <pre class="fragment">The Bit type returns 1.
</pre> </dd></dl>

</div>
</div>
<a id="ac7b1bfcf9448a2a6ab4ae52ee7725a81" name="ac7b1bfcf9448a2a6ab4ae52ee7725a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b1bfcf9448a2a6ab4ae52ee7725a81">&#9670;&nbsp;</a></span>data_type_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::data_type_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum of a datatype. </p>
<dl class="section return"><dt>Returns</dt><dd>double maximum value. <pre class="fragment">This function is used for returning the maximum value
a data type can hold.
</pre> </dd></dl>

</div>
</div>
<a id="a96111e0fd5ff64a7e037dcba8235b823" name="a96111e0fd5ff64a7e037dcba8235b823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96111e0fd5ff64a7e037dcba8235b823">&#9670;&nbsp;</a></span>data_type_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::data_type_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum of a datatype. </p>
<dl class="section return"><dt>Returns</dt><dd>double minimum value. <pre class="fragment">This function is used for returning the minimum value
a data type can hold.
</pre> </dd></dl>

</div>
</div>
<a id="a7d72f814a078c88879693bbf71b54cf5" name="a7d72f814a078c88879693bbf71b54cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d72f814a078c88879693bbf71b54cf5">&#9670;&nbsp;</a></span>data_type_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::data_type_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the datatype in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>long data type size. <pre class="fragment">The Bit type returns 1.
</pre> </dd></dl>

</div>
</div>
<a id="a93ad6a3996ad556af36d215b4eb47904" name="a93ad6a3996ad556af36d215b4eb47904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ad6a3996ad556af36d215b4eb47904">&#9670;&nbsp;</a></span>data_type_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bstring.html">Bstring</a> Bimage::data_type_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string representation of a datatype. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_bstring.html">Bstring</a> string representation of a datatype. </dd></dl>

</div>
</div>
<a id="aa2b15e01e03d16b34aae26619cf99c61" name="aa2b15e01e03d16b34aae26619cf99c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b15e01e03d16b34aae26619cf99c61">&#9670;&nbsp;</a></span>default_origin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::default_origin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86e13cf2551e48c8d98c5bad3c3690f9" name="a86e13cf2551e48c8d98c5bad3c3690f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e13cf2551e48c8d98c5bad3c3690f9">&#9670;&nbsp;</a></span>defocus_scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::defocus_scale </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>df2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iCL2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a416e421f9c6a2043c34f223a9df49bef" name="a416e421f9c6a2043c34f223a9df49bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416e421f9c6a2043c34f223a9df49bef">&#9670;&nbsp;</a></span>delete_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::delete_images </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a>&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>retain</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retains or deletes sub-images from a multi-image structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>list of sub-images to retain or delete. </td></tr>
    <tr><td class="paramname">retain</td><td>0=delete list, 1=retain list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long error code (&lt;0 means failure) or number of sub-images remaining. <pre class="fragment">Sub-images specified in a list are either retained or deleted.
The new data replaces the old data.
</pre> </dd></dl>

</div>
</div>
<a id="ab423ab772f8f5370378c3ca39d89ffaf" name="ab423ab772f8f5370378c3ca39d89ffaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab423ab772f8f5370378c3ca39d89ffaf">&#9670;&nbsp;</a></span>density() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::density </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0df18d85c91d522f3f3c2d8ea56b1850" name="a0df18d85c91d522f3f3c2d8ea56b1850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df18d85c91d522f3f3c2d8ea56b1850">&#9670;&nbsp;</a></span>density() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::density </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the density in a sphere around a coordinate in an image. </p>
<dl class="section author"><dt>Author</dt><dd>Daniel Nemecek and Bernard Heymann </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image number. </td></tr>
    <tr><td class="paramname">coord</td><td>position of density in map (voxels). </td></tr>
    <tr><td class="paramname">radius</td><td>spherical radius. </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double average density. <pre class="fragment">The density origin is positioned on the component.
</pre> </dd></dl>

</div>
</div>
<a id="a1a729cd6b00a8a5031ca545921e5014b" name="a1a729cd6b00a8a5031ca545921e5014b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a729cd6b00a8a5031ca545921e5014b">&#9670;&nbsp;</a></span>distort_elliptically()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::distort_elliptically </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a tubular cylinder to an elliptical profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>angle of elliptical maximum. </td></tr>
    <tr><td class="paramname">shift</td><td>outward shift at elliptical maximum radius. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The density is shifted towards or away from the origin by a specific
amount and in a direction determined by an elliptical profile.
</pre> </dd></dl>

</div>
</div>
<a id="a34fcf4e33e69ef544b67855d7a64b8ea" name="a34fcf4e33e69ef544b67855d7a64b8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fcf4e33e69ef544b67855d7a64b8ea">&#9670;&nbsp;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides the first image by the second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>other image. </td></tr>
    <tr><td class="paramname">scale</td><td>density scale to apply to other image </td></tr>
    <tr><td class="paramname">shift</td><td>density shift to apply to other image. <pre class="fragment">The image is divided by the other with exceptions:
    image /= other*scale + shift
Both images are converted to floating point.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcc8a26a38fe1b41c707793d44bb37de" name="afcc8a26a38fe1b41c707793d44bb37de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc8a26a38fe1b41c707793d44bb37de">&#9670;&nbsp;</a></span>divide_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::divide_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides the first image by the first sub-image of the second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>other image. </td></tr>
    <tr><td class="paramname">scale</td><td>density scale to apply to other image </td></tr>
    <tr><td class="paramname">shift</td><td>density shift to apply to other image. <pre class="fragment">The image is divided by the other with exceptions:
    image /= other*scale + shift
Both images are converted to floating point.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab207c264e19d9a213331accd25de29a6" name="ab207c264e19d9a213331accd25de29a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab207c264e19d9a213331accd25de29a6">&#9670;&nbsp;</a></span>dyad_interpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::dyad_interpolate </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_flag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab3a7ec44e12c8449b6d6505e6b9938f" name="aab3a7ec44e12c8449b6d6505e6b9938f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3a7ec44e12c8449b6d6505e6b9938f">&#9670;&nbsp;</a></span>edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::edge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooths the image edge with a soft rectangular function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of edge: 0=rectangle, 1=oval, 2=cylinder </td></tr>
    <tr><td class="paramname">rect</td><td>three-value size of the area to be smoothed. </td></tr>
    <tr><td class="paramname">start</td><td>three-value start for smoothing. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of smoothing function. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>value of edge voxels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The edge of the image is smoothed with a function:
                    v_old(x,y,z) + fill*exp(1.618*dist/width)
    v_new(x,y,z) = ------------------------------------------
                           1 + exp(1.618*dist/width)
where   fill is the desired edge value.
        dist is the distance to the rectangular boundary defined by 
            the input size and start
        width is the gaussian width (softness)
With very small values of the gaussian width, the edge approaches a
step function.
With negative width values, the area filled is outside the shape.
</pre> </dd></dl>

</div>
</div>
<a id="a0ca127a5e81dc5a37da132f66c0747bf" name="a0ca127a5e81dc5a37da132f66c0747bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca127a5e81dc5a37da132f66c0747bf">&#9670;&nbsp;</a></span>edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::edge </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooths the image edge with a soft rectangular function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">type</td><td>type of edge: 0=rectangle, 1=oval, 2=cylinder </td></tr>
    <tr><td class="paramname">rect</td><td>three-value size of the area to be smoothed. </td></tr>
    <tr><td class="paramname">start</td><td>three-value start for smoothing. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of smoothing function. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>value of edge voxels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The edge of the image is smoothed with a function:
                    v_old(x,y,z) + fill*exp(1.618*dist/width)
    v_new(x,y,z) = ------------------------------------------
                           1 + exp(1.618*dist/width)
where   fill is the desired edge value.
        dist is the distance to the rectangular boundary defined by 
            the input size and start
        width is the gaussian width (softness)
With very small values of the gaussian width, the edge approaches a
step function.
With negative width values, the area filled is outside the shape.
</pre> </dd></dl>

</div>
</div>
<a id="a647a5820a81c3ed26344e4c5540446d8" name="a647a5820a81c3ed26344e4c5540446d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647a5820a81c3ed26344e4c5540446d8">&#9670;&nbsp;</a></span>edge_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::edge_mask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a mask with the edge approaching zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of edge: 0=rectangle, 1=oval, 2=cylinder </td></tr>
    <tr><td class="paramname">rect</td><td>three-value size of the area to be masked. </td></tr>
    <tr><td class="paramname">start</td><td>three-value start for mask. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of smoothing function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new soft mask. <pre class="fragment">The edge of the image is smoothed with a function:
                                1
    v_new(x,y,z) =  -------------------------
                    1 + exp(1.618*dist/width)
where   dist is the distance to the boundary defined by 
            the input size and start
        width is the gaussian width (softness)
With very small values of the gaussian width, the edge approaches a
step function.
With negative width values, the area filled is outside the shape.
</pre> </dd></dl>

</div>
</div>
<a id="ade5bcb6486e3258d8d7f4df3ab61081d" name="ade5bcb6486e3258d8d7f4df3ab61081d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5bcb6486e3258d8d7f4df3ab61081d">&#9670;&nbsp;</a></span>enlarge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::enlarge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enlarges an image by an inetger scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>three-value scale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">An image is enlarged by integer amounts.
The new data replaces the old data.
</pre> </dd></dl>

</div>
</div>
<a id="ab48733dde4aaf8c925278d983fb252fb" name="ab48733dde4aaf8c925278d983fb252fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48733dde4aaf8c925278d983fb252fb">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::erase </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae71f57ecd1286f7194495e506bb3b6cc" name="ae71f57ecd1286f7194495e506bb3b6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71f57ecd1286f7194495e506bb3b6cc">&#9670;&nbsp;</a></span>exponential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::exponential </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the exponential of the image data. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is first converted to floating point.
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a2703b464380e42f9a66433f04769da33" name="a2703b464380e42f9a66433f04769da33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2703b464380e42f9a66433f04769da33">&#9670;&nbsp;</a></span>extract() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a set of sub-images into new image structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>first sub-image to extract. </td></tr>
    <tr><td class="paramname">n2</td><td>last sub-image to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* the new image structure, NULL if copy failed. </dd></dl>

</div>
</div>
<a id="ad694d6b8be2285e48d93cf19933448bc" name="ad694d6b8be2285e48d93cf19933448bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad694d6b8be2285e48d93cf19933448bc">&#9670;&nbsp;</a></span>extract() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts one sub-image into new image structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* the new image structure, NULL if copy failed. </dd></dl>

</div>
</div>
<a id="ad202325a6b016bda9d3356c7a078fb7f" name="ad202325a6b016bda9d3356c7a078fb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad202325a6b016bda9d3356c7a078fb7f">&#9670;&nbsp;</a></span>extract() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1525f8c9e7b34b3c620f75ec01983bcc" name="a1525f8c9e7b34b3c620f75ec01983bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1525f8c9e7b34b3c620f75ec01983bcc">&#9670;&nbsp;</a></span>extract() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>ori</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a region of one sub-image into new image structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number to extract. </td></tr>
    <tr><td class="paramname">loc</td><td>extraction location. </td></tr>
    <tr><td class="paramname">size</td><td>extraction size. </td></tr>
    <tr><td class="paramname">ori</td><td>extraction origin. </td></tr>
    <tr><td class="paramname">mat</td><td>orientation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* the new image structure, NULL if copy failed. </dd></dl>

</div>
</div>
<a id="acb3370c44752d159fc360769c37be851" name="acb3370c44752d159fc360769c37be851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3370c44752d159fc360769c37be851">&#9670;&nbsp;</a></span>extract() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75becde8dfa02b97efe042a439ac4766" name="a75becde8dfa02b97efe042a439ac4766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75becde8dfa02b97efe042a439ac4766">&#9670;&nbsp;</a></span>extract() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a region of one sub-image into new image structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number to extract. </td></tr>
    <tr><td class="paramname">coords</td><td>extraction start. </td></tr>
    <tr><td class="paramname">size</td><td>extraction size. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* the new image structure, NULL if copy failed. </dd></dl>

</div>
</div>
<a id="a954793f4d58397221196ccb9c2ef1a67" name="a954793f4d58397221196ccb9c2ef1a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954793f4d58397221196ccb9c2ef1a67">&#9670;&nbsp;</a></span>extract_filament()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_filament </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>img_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nspline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>spline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a filament defined by a series of coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_num</td><td>image number from which to extract filament. </td></tr>
    <tr><td class="paramname">width</td><td>width of filament image to extract. </td></tr>
    <tr><td class="paramname">axis</td><td>helical axis alignment: x=1, y=2, z=3. </td></tr>
    <tr><td class="paramname">nspline</td><td>number of coordinates in spline curve. </td></tr>
    <tr><td class="paramname">*spline</td><td>spline curve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* one filament image. <pre class="fragment">A single filament is extracted and returned.
</pre> </dd></dl>

</div>
</div>
<a id="a892f52f8f20dc7804f1ad1b2c9680d36" name="a892f52f8f20dc7804f1ad1b2c9680d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892f52f8f20dc7804f1ad1b2c9680d36">&#9670;&nbsp;</a></span>extract_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_line </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a line from an image into a new image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number from which to extract. </td></tr>
    <tr><td class="paramname">start</td><td>3-vector start of line. </td></tr>
    <tr><td class="paramname">end</td><td>3-vector end of line. </td></tr>
    <tr><td class="paramname">width</td><td>width of integration perpendicular to line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* extracted line image (1D). <pre class="fragment">The line values extracted are the interpolated values along the vector
defined by start and end coordinates..
</pre> </dd></dl>

</div>
</div>
<a id="ab2528c48b7c82f19008a343ccfc42c7d" name="ab2528c48b7c82f19008a343ccfc42c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2528c48b7c82f19008a343ccfc42c7d">&#9670;&nbsp;</a></span>extract_magnify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_magnify </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>ext_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a region from an image to magnify. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number to extract. </td></tr>
    <tr><td class="paramname">center</td><td>center of region to magnify. </td></tr>
    <tr><td class="paramname">ext_size</td><td>size of region to magnify. </td></tr>
    <tr><td class="paramname">scale</td><td>dimensional scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* extracted slice for 2D and 3 slices for 3D. <pre class="fragment">Only the desired region is extracted from the original image and
resized based on the given scale argument.
The dynamic range is rescaled using the image display minimum and 
maximum:
    new_data = data*255/(max-min)
with truncation of the data below 0 and above 255.
Bit data are converted to 0 (black) and 255 (white).
RGB data are rescaled as for gray scale images.
Complex data types are converted to intensities.
</pre> </dd></dl>

</div>
</div>
<a id="a25a878694c06b1bd8f60792138f69ff1" name="a25a878694c06b1bd8f60792138f69ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a878694c06b1bd8f60792138f69ff1">&#9670;&nbsp;</a></span>extract_shell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_shell </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxrad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a shell from an image into a new image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number from which to extract, -1 indicates all images. </td></tr>
    <tr><td class="paramname">minrad</td><td>minimum shell radius. </td></tr>
    <tr><td class="paramname">maxrad</td><td>maximum shell radius. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* extracted image. <pre class="fragment">A single image (only one sub-image) is extracted from a given sub-image
in an image structure, starting at a specified point and with a 
specified size.
The old data is not affected.
Statistics for the extracted image are calculated.
</pre> </dd></dl>

</div>
</div>
<a id="a6ba5d23997bcbed499347362560988da" name="a6ba5d23997bcbed499347362560988da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba5d23997bcbed499347362560988da">&#9670;&nbsp;</a></span>extract_show()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_show </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aflag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a slice from an image to a 2D plane for display. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aflag</td><td>averaging flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* extracted slice. <pre class="fragment">Only the desired image slice is extracted from the original image and
resized based on the given scale argument.
The image, slice and scale values are encoded in the image structure.
The dynamic range is rescaled using the image display minimum and maximum:
    new_data = data*255/(max-min)
with truncation of the data below 0 and above 255.
Bit data are converted to 0 (black) and 255 (white).
RGB data are rescaled as for gray scale images.
Complex data types are converted to intensities.
</pre> </dd></dl>

</div>
</div>
<a id="a80a6e4158e822bc0580169327cd67b0c" name="a80a6e4158e822bc0580169327cd67b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a6e4158e822bc0580169327cd67b0c">&#9670;&nbsp;</a></span>extract_show_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::extract_show_chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pshow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aflag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89fb7c035e1a7dab3a3b1aa92ee821f8" name="a89fb7c035e1a7dab3a3b1aa92ee821f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fb7c035e1a7dab3a3b1aa92ee821f8">&#9670;&nbsp;</a></span>extract_slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_slice </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a given slice or slices from an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nz</td><td>slice number to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* extracted slice(s). <pre class="fragment">Only the desired slices are extracted from the original image.
The dynamic range is rescaled using the image display minimum and 
maximum:
    new_data = data*255/(max-min)
with truncation of the data below 0 and above 255.
Bit data are converted to 0 (black) and 255 (white).
RGB data are rescaled as for gray scale images.
Complex data types are converted to intensities.
</pre> </dd></dl>

</div>
</div>
<a id="a83d370c2c5b46f2e3efa77adf4ff50f0" name="a83d370c2c5b46f2e3efa77adf4ff50f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d370c2c5b46f2e3efa77adf4ff50f0">&#9670;&nbsp;</a></span>extract_tetrahedron()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_tetrahedron </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a tetrahedral part of the image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*tet</td><td>four 3-value vectors defining the tetrahedron. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">All voxels outside a tetrahedron defined by four points or vectors 
are set to a given fill value.
The new data replaces the old data.
</pre> </dd></dl>

</div>
</div>
<a id="a1764bd1bafd971269b576790b810767c" name="a1764bd1bafd971269b576790b810767c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1764bd1bafd971269b576790b810767c">&#9670;&nbsp;</a></span>extract_tile_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_tile_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>tile_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a stack of tiles at a specified position from an image into a new image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>coordinates for the tile origins. </td></tr>
    <tr><td class="paramname">tile_size</td><td>3-vector size of extracted image. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* p extracted stack of tiles. <pre class="fragment">A stack of tiles of specified size are extracted from all the sub-images
in an image structure, using given coordinates for the tiles.
The origins of the tiles are inserted into the sub-image origin fields.
The old data is not affected.
</pre> </dd></dl>

</div>
</div>
<a id="a97b708ae8cfb17999a439c1f5458dba9" name="a97b708ae8cfb17999a439c1f5458dba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b708ae8cfb17999a439c1f5458dba9">&#9670;&nbsp;</a></span>extract_tile_stacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> ** Bimage::extract_tile_stacks </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>tile_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts stacks of tiles at a specified positions from an image into an array of new images. </p>
<p >Extracts a set of tiles at specified positions from an image into a new image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>coordinates for the tile origins. </td></tr>
    <tr><td class="paramname">tile_size</td><td>3-vector size of extracted image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;Bimage*&gt; extracted stacks of tiles. <pre class="fragment">Stacks of tiles of specified size are extracted from all the sub-images
in an image structure, using given coordinates for the tiles.
The origins of the tiles are inserted into the sub-image origin fields.
The old data is not affected.
</pre> </dd></dl>

</div>
</div>
<a id="a3b36947546650566f8889ca3e5eb0e46" name="a3b36947546650566f8889ca3e5eb0e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b36947546650566f8889ca3e5eb0e46">&#9670;&nbsp;</a></span>extract_tiles() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_tiles </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>tile_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>step_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exceed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a set of tiles from an image into a new image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number from which to extract. </td></tr>
    <tr><td class="paramname">start</td><td>3-vector start for first tile to be extracted. </td></tr>
    <tr><td class="paramname">region</td><td>3-vector size of part of image to be extracted (0 = whole image). </td></tr>
    <tr><td class="paramname">tile_size</td><td>3-vector size of extracted image. </td></tr>
    <tr><td class="paramname">step_size</td><td>3-vector size of tile intervals. </td></tr>
    <tr><td class="paramname">exceed</td><td>flag to allow tiles to exceed the input image size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* extracted set of sub-images. <pre class="fragment">A set of tiles of specified size are extracted from a given sub-image
in an image structure, starting from a point and generating
as many tiles as would fit into the image size given. If the image size
given is zero, then the whole image is used. The origins of the tiles
are inserted into the sub-image origin fields.
The old data is not affected.
</pre> </dd></dl>

</div>
</div>
<a id="af74c7e919d334bed98157c96e68b5f72" name="af74c7e919d334bed98157c96e68b5f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74c7e919d334bed98157c96e68b5f72">&#9670;&nbsp;</a></span>extract_tiles() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_tiles </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>tile_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fraction</em> = <code>0.2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a set of tiles from an image into a new image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number from which to extract. </td></tr>
    <tr><td class="paramname">tile_size</td><td>3-vector size of extracted image. </td></tr>
    <tr><td class="paramname">fraction</td><td>overlap fraction to aim for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* extracted set of sub-images. <pre class="fragment">A set of tiles of specified size are extracted from a given sub-image
in an image structure. The tiles are located with overlap (~20% of tile width)
with the aim of covering the whole image but not exceeding it.
The origins of the tiles are inserted into the sub-image origin fields.
The old data is not affected.
</pre> </dd></dl>

</div>
</div>
<a id="a7bb5f538e628fb40542402e539b3d2c0" name="a7bb5f538e628fb40542402e539b3d2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb5f538e628fb40542402e539b3d2c0">&#9670;&nbsp;</a></span>extract_tiles() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_tiles </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>tile_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a set of tiles at specified positions from an image into a new image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number from which to extract, -1 indicates all images. </td></tr>
    <tr><td class="paramname">coords</td><td>coordinates for the tile origins. </td></tr>
    <tr><td class="paramname">tile_size</td><td>3-vector size of extracted image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* p extracted set of sub-images. <pre class="fragment">A set of tiles of specified size are extracted from a given sub-image 
in an image structure, using given coordinates for the tiles, which have
to fit into the image size. The origins of the tiles are inserted into 
the sub-image origin fields.
The old data is not affected.
</pre> </dd></dl>

</div>
</div>
<a id="a1bf79966f25b70ab6cf0d07445709c47" name="a1bf79966f25b70ab6cf0d07445709c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf79966f25b70ab6cf0d07445709c47">&#9670;&nbsp;</a></span>extract_wrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_wrap </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>ori</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a region of one sub-image into new image structure with wrapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number to extract. </td></tr>
    <tr><td class="paramname">loc</td><td>extraction location. </td></tr>
    <tr><td class="paramname">size</td><td>extraction size. </td></tr>
    <tr><td class="paramname">ori</td><td>extraction origin. </td></tr>
    <tr><td class="paramname">mat</td><td>orientation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* the new image structure, NULL if copy failed. </dd></dl>

</div>
</div>
<a id="af08d645ee9fca25c5968cf24383809b7" name="af08d645ee9fca25c5968cf24383809b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08d645ee9fca25c5968cf24383809b7">&#9670;&nbsp;</a></span>extract_wrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::extract_wrap </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad03e8e721a1d85ad7a40d4d03d3c0574" name="ad03e8e721a1d85ad7a40d4d03d3c0574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03e8e721a1d85ad7a40d4d03d3c0574">&#9670;&nbsp;</a></span>extrude_cross_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::extrude_cross_section </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>helix_rise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>helix_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extrudes a 2D cross section into a 3D continuous helix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>length in z. </td></tr>
    <tr><td class="paramname">helix_rise</td><td>helical subunit rise in angstrom. </td></tr>
    <tr><td class="paramname">helix_angle</td><td>helical subunit rotation in radians. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>value of edge voxels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The helical axis is at the origin and alongthe a axis.
</pre> </dd></dl>

</div>
</div>
<a id="ac40b2b2d919d6d3a3e3eda301d4e0fba" name="ac40b2b2d919d6d3a3e3eda301d4e0fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40b2b2d919d6d3a3e3eda301d4e0fba">&#9670;&nbsp;</a></span>fft() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a242a0713955bce07cc7b0f5904ff394f" name="a242a0713955bce07cc7b0f5904ff394f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242a0713955bce07cc7b0f5904ff394f">&#9670;&nbsp;</a></span>fft() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61cf819a81d9f5c3c4d82f5907e3fe67">fft_direction</a>&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast Fourier transforms an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>direction of transformation (FFTW_FORWARD or FFTW_BACKWARD) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">FFTW library (www.fftw.org).
A multi-image 1D, 2D and 3D data set is transformed forward or backward 
and rescaled by 1/sqrt(N).  The forward transformation has a negative 
signed exponent in the kernel and the backward transform a positive
sign. The transformation is done in place and the resultant data are 
returned within the original image structure.  For forward transforms, 
the resultant data type is complex float, while for backward transforms, 
it is Float.
</pre> </dd></dl>

</div>
</div>
<a id="a109041ab7adcf1134630008c736cd0a1" name="a109041ab7adcf1134630008c736cd0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109041ab7adcf1134630008c736cd0a1">&#9670;&nbsp;</a></span>fft() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61cf819a81d9f5c3c4d82f5907e3fe67">fft_direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>norm_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast Fourier transforms an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>direction of transformation (FFTW_FORWARD or FFTW_BACKWARD) </td></tr>
    <tr><td class="paramname">norm_flag</td><td>normalization: 0=none, 1=sqrtN, 2=N. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">FFTW library (www.fftw.org).
A multi-image 1D, 2D and 3D data set is transformed forward or backward 
and optionally rescaled by 1/sqrt(N) or N.  The forward transformation 
has a negative signed exponent in the kernel and the backward transform 
a positive sign. The transformation is done in place and the resultant 
data are returned within the original image structure.
For both directions the resultant image is complex.
</pre> </dd></dl>

</div>
</div>
<a id="adcdc6f06bec66f631c393b87ac2a742f" name="adcdc6f06bec66f631c393b87ac2a742f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdc6f06bec66f631c393b87ac2a742f">&#9670;&nbsp;</a></span>fft() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>norm_flag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast Fourier transforms an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Fourier transform plan. </td></tr>
    <tr><td class="paramname">norm_flag</td><td>normalization: 0=none, 1=sqrtN, 2=N. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">FFTW library (www.fftw.org).
A multi-image 1D, 2D and 3D data set is transformed forward or backward 
and optionally rescaled by 1/sqrt(N) or N.  The forward transformation 
has a negative signed exponent in the kernel and the backward transform 
a positive sign. The transformation is done in place and the resultant 
data are returned within the original image structure.
For both directions the resultant image is complex.
Requirement: The plan must be derived from the same size image.
</pre> </dd></dl>

</div>
</div>
<a id="ad83202ab557c3a6acc6f635d217146a6" name="ad83202ab557c3a6acc6f635d217146a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83202ab557c3a6acc6f635d217146a6">&#9670;&nbsp;</a></span>fft_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fft_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79448ddf4fd8e74bbfd846d7bb9b19e7" name="a79448ddf4fd8e74bbfd846d7bb9b19e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79448ddf4fd8e74bbfd846d7bb9b19e7">&#9670;&nbsp;</a></span>fft_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fft_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>norm_flag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d7eea09fdb8cca40c6778cd4aa4c49e" name="a3d7eea09fdb8cca40c6778cd4aa4c49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7eea09fdb8cca40c6778cd4aa4c49e">&#9670;&nbsp;</a></span>fft_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a> Bimage::fft_setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61cf819a81d9f5c3c4d82f5907e3fe67">fft_direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a plan for fast Fourier transforms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>direction of transformation (FFTW_FORWARD or FFTW_BACKWARD) </td></tr>
    <tr><td class="paramname">opt</td><td>optimization (0=FFTW_ESTIMATE, 1=FFTW_MEASURE, 2=FFTW_PATIENT, 3=FFTW_EXHAUSTIVE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fft_plan FFTW plan. <pre class="fragment">FFTW library (www.fftw.org).
The size and direction determines the plan.
Both FFTW versions 2 and 3 are supported.
</pre> </dd></dl>

</div>
</div>
<a id="ad37eb70146e2c6730f8757cb02eae628" name="ad37eb70146e2c6730f8757cb02eae628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37eb70146e2c6730f8757cb02eae628">&#9670;&nbsp;</a></span>filament_density()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::filament_density </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the density per pixel length of a filament. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>filament width (pixels). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* one dimensional image with line integrals. <pre class="fragment">The filament axis must be along the long axis (x or y).
The filament width must be about half of the image width.
The background is calculated for each line from the regions 
outside the width of the filament and subtracted from all
values in the line.
</pre> </dd></dl>

</div>
</div>
<a id="a3ba420d47cf61f7095470e8e9c2aeba9" name="a3ba420d47cf61f7095470e8e9c2aeba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba420d47cf61f7095470e8e9c2aeba9">&#9670;&nbsp;</a></span>filament_from_projections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::filament_from_projections </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstructs a filament from a set of projections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">flag</td><td>0=sequential, 1=random. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* reconstructed filament. <pre class="fragment">The views are set at equally spaced angles around the z-axis.
</pre> </dd></dl>

</div>
</div>
<a id="aa5ee26442c0bafb0b25476062545ebfe" name="aa5ee26442c0bafb0b25476062545ebfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ee26442c0bafb0b25476062545ebfe">&#9670;&nbsp;</a></span>filament_width()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::filament_width </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lim_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lim_hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the width of a filament. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>window size. </td></tr>
    <tr><td class="paramname">lim_lo</td><td>minimum filament width. </td></tr>
    <tr><td class="paramname">lim_hi</td><td>maximum filament width. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bplot* plot of filament widths. <pre class="fragment">The filament axis must be along the y axis.
</pre> </dd></dl>

</div>
</div>
<a id="a2ee3dc69a69e3588ae89d01e23e4b939" name="a2ee3dc69a69e3588ae89d01e23e4b939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee3dc69a69e3588ae89d01e23e4b939">&#9670;&nbsp;</a></span>file_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string &amp; Bimage::file_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2be9f3ca7d6cb23f7310f4152bb19362" name="a2be9f3ca7d6cb23f7310f4152bb19362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be9f3ca7d6cb23f7310f4152bb19362">&#9670;&nbsp;</a></span>file_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::file_name </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31c23502ddd87cbb33e533a97282effb" name="a31c23502ddd87cbb33e533a97282effb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c23502ddd87cbb33e533a97282effb">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::fill </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a010a69d94b27256f673831bec3ede99b" name="a010a69d94b27256f673831bec3ede99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010a69d94b27256f673831bec3ede99b">&#9670;&nbsp;</a></span>fill_gaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fill_gaps </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>step</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the voxels that are not calculated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>step increment for voxels with proper values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 if error. <pre class="fragment">The step size used to calculate sparse voxels is here used to determine
a kernel size for the filling operation. For each sparse voxel, all the
neighbors within the kernel are filled with the center value.
</pre> </dd></dl>

</div>
</div>
<a id="a17ae6d409fb5708f0393e8629699b8ec" name="a17ae6d409fb5708f0393e8629699b8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ae6d409fb5708f0393e8629699b8ec">&#9670;&nbsp;</a></span>fill_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_type_pointer.html">TypePointer</a> Bimage::fill_value </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5538ec2cf75dc526f2598f983b2823b" name="aa5538ec2cf75dc526f2598f983b2823b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5538ec2cf75dc526f2598f983b2823b">&#9670;&nbsp;</a></span>filter_average() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_average </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>kernel_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies an averaging filter to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel_size</td><td>length of kernel edge (typically 3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 if error. <pre class="fragment">A kernel of a given size is passed over the image and the average
value within the kernel assigned to the central voxel.
</pre> </dd></dl>

</div>
</div>
<a id="ab2921e0ee63f54e4254118a8ba407721" name="ab2921e0ee63f54e4254118a8ba407721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2921e0ee63f54e4254118a8ba407721">&#9670;&nbsp;</a></span>filter_average() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59222f093c517b163aeac959b3696fd3" name="a59222f093c517b163aeac959b3696fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59222f093c517b163aeac959b3696fd3">&#9670;&nbsp;</a></span>filter_bilateral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_bilateral </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kernel_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>kernel_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Denoise an image with combined gaussian distance and density difference kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigma1</td><td>sigma for distance weighting function. </td></tr>
    <tr><td class="paramname">sigma2</td><td>sigma for density difference weighting function. </td></tr>
    <tr><td class="paramname">kernel_type</td><td>kernel type for range filter. </td></tr>
    <tr><td class="paramname">kernel_radius</td><td>kernel radius. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The kernel is multiplied with each area surrounding the current voxel.
Kernel types:
    1.  Gaussian
    2.  Lorentzian
    3.  Tukey
</pre> </dd></dl>

</div>
</div>
<a id="a5c716602230bd440ec0f6afb129ed6ea" name="a5c716602230bd440ec0f6afb129ed6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c716602230bd440ec0f6afb129ed6ea">&#9670;&nbsp;</a></span>filter_bilateral_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_bilateral_chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pkernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kernel_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>nudata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc3dfa467026ffd2b1d6b5229756a028" name="acc3dfa467026ffd2b1d6b5229756a028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3dfa467026ffd2b1d6b5229756a028">&#9670;&nbsp;</a></span>filter_by_difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_by_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an anisotropic average within a kernel based on the local gradient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>image to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="a7b62e2269f9c7993c77349d583e9f300" name="a7b62e2269f9c7993c77349d583e9f300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b62e2269f9c7993c77349d583e9f300">&#9670;&nbsp;</a></span>filter_dog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_dog </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolves the image with a difference of gausians kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigma1</td><td>sigma for the inner gaussian. </td></tr>
    <tr><td class="paramname">sigma2</td><td>sigma for the outer gaussian. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. </dd></dl>

</div>
</div>
<a id="aa7bdc44f4581bd59d988cd52ea5d10a4" name="aa7bdc44f4581bd59d988cd52ea5d10a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bdc44f4581bd59d988cd52ea5d10a4">&#9670;&nbsp;</a></span>filter_extremes() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_extremes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters the extremes out of a micrograph image. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">Segmentation is used to identify large contiguous regions of high
and low values, and these regions are set to the average.
</pre> </dd></dl>

</div>
</div>
<a id="abcd3f470d765801f6061d67342a8b42b" name="abcd3f470d765801f6061d67342a8b42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd3f470d765801f6061d67342a8b42b">&#9670;&nbsp;</a></span>filter_extremes() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_extremes </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kernel</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters the extremes out of an image by replacing with adjacent averages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmin</td><td>minimum. </td></tr>
    <tr><td class="paramname">tmax</td><td>maximum. </td></tr>
    <tr><td class="paramname">kernel</td><td>kernel edge size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">Pixels smaller than the minimum or larger than the maximum are set to
the average within a defined kernel.
</pre> </dd></dl>

</div>
</div>
<a id="a68563296b57a2d9c25362546f8bf2e2e" name="a68563296b57a2d9c25362546f8bf2e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68563296b57a2d9c25362546f8bf2e2e">&#9670;&nbsp;</a></span>filter_extremes() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_extremes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mod_flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters the extremes out of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod_flag</td><td>modification flag (0=set to avg, 1=set to min_max). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">A histogram of an image is calculated.  The first minimum in the first
quarter of the histogram and the last minimum in the last quarter
are taken to define the small and large outliers.  Pixel outside
these minima are then either set to average or to minimum or maximum
(depending on the mod_flag argument) to remove the outliers.
</pre> </dd></dl>

</div>
</div>
<a id="a9e7a4ada245ecf07688a166af32e1b02" name="a9e7a4ada245ecf07688a166af32e1b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7a4ada245ecf07688a166af32e1b02">&#9670;&nbsp;</a></span>filter_gaussian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_gaussian </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a gaussian filter to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel_size</td><td>length of kernel edge. </td></tr>
    <tr><td class="paramname">sigma</td><td>gaussian decay. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 if error. <pre class="fragment">The image is comvolved with a Gaussian kernel.
If the sigma value is zero, it is set to a sixth of the kernel size.
</pre> </dd></dl>

</div>
</div>
<a id="a0961f0dd6376ab4cf6428e408e500cf2" name="a0961f0dd6376ab4cf6428e408e500cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0961f0dd6376ab4cf6428e408e500cf2">&#9670;&nbsp;</a></span>filter_ortho()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_ortho </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolves the image with an orthogonal kernel with wrapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of kernel: 0=gradient magnitude, 1=laplacian. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">The gradient kernel is:
    0  0  0    0 -1  0    0  0  0
    0 -1  0   -1  0  1    0  1  0
    0  0  0    0  1  0    0  0  0

The Laplacian filter kernel for a 3D volume is:
    0  0  0    0  1  0    0  0  0
    0  1  0    1 -6  1    0  1  0
    0  0  0    0  1  0    0  0  0
For 1D and 2D the central value is -2 and -4 respectively.
</pre> </dd></dl>

</div>
</div>
<a id="ab9bc11d57ce0c518f1945af4ee64d9eb" name="ab9bc11d57ce0c518f1945af4ee64d9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bc11d57ce0c518f1945af4ee64d9eb">&#9670;&nbsp;</a></span>filter_peak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::filter_peak </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>kernel_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the peaks in an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel_size</td><td>length of kernel edge (typically 3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 if error. <pre class="fragment">A kernel of a given size is passed over the image and if the central
voxel is the maximum, it is kept, otherwise it is set to background.
</pre> </dd></dl>

</div>
</div>
<a id="a207f8d8d30304d422524b843c7175bf3" name="a207f8d8d30304d422524b843c7175bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207f8d8d30304d422524b843c7175bf3">&#9670;&nbsp;</a></span>filter_rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_rank </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a median filter to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel_size</td><td>length of kernel edge (typically 3). </td></tr>
    <tr><td class="paramname">rank</td><td>which value in the kernel to retain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 if error. <pre class="fragment">A kernel of a given size is passed over the image and the median
value within the kernel assigned to the central voxel.
</pre> </dd></dl>

</div>
</div>
<a id="a54ca7c220c8b8a14d8501694ca2c70ee" name="a54ca7c220c8b8a14d8501694ca2c70ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ca7c220c8b8a14d8501694ca2c70ee">&#9670;&nbsp;</a></span>filter_rank_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_rank_chunk </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>nudata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4d4dbb6a5fd01ccb65c5ac871f210f7" name="ac4d4dbb6a5fd01ccb65c5ac871f210f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d4dbb6a5fd01ccb65c5ac871f210f7">&#9670;&nbsp;</a></span>filter_rolling_ball()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_rolling_ball </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a rolling ball filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>radius of rolling ball. </td></tr>
    <tr><td class="paramname">scale</td><td>density scale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="a4227a87d62a6c08de8a41b8040b86a34" name="a4227a87d62a6c08de8a41b8040b86a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4227a87d62a6c08de8a41b8040b86a34">&#9670;&nbsp;</a></span>filter_sinc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::filter_sinc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs an image with a sinc function. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">This filter compensates for trilinear interpolation during reconstruction.
The origin must be properly defined.
</pre> </dd></dl>

</div>
</div>
<a id="a662b99c550dfa6842da821bb9e2fe59f" name="a662b99c550dfa6842da821bb9e2fe59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662b99c550dfa6842da821bb9e2fe59f">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a>&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7447cd808d862a6f5cedf597ebc4bdbf" name="a7447cd808d862a6f5cedf597ebc4bdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7447cd808d862a6f5cedf597ebc4bdbf">&#9670;&nbsp;</a></span>find_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::find_center </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refine_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the center of mass of an image by cross-correlation with its inverse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>binary mask (only 0 and 1). </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">radius</td><td>search radius (if &lt; 1, default 1e30). </td></tr>
    <tr><td class="paramname">sigma</td><td>attenuation around radius. </td></tr>
    <tr><td class="paramname">refine_flag</td><td>set to refine shift to subpixel resolution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D data sets are transformed 
forward, the first transform multiplied by the complex conjugate of
the second transform, followed by backward transformation and 
rescaling by 1/(N*N). Data beyond the resolution set in the first 
image structure are not used. Therefore the correct setting 
of units and resolution in the image are required. Defaults for the 
units are usually 1 Angstrom/voxel and a zero resolution would
include the whole image (i.e., no resolution limitation).
A shift vector for each pair of images is calculated to
determine the cross-correlation peak to sub-pixel resolution.
Note: The first image is the reference and the shift returned is to
    transform the second to fit the first.
</pre> </dd></dl>

</div>
</div>
<a id="a5260d542a8919de15b8398dfd2f90c78" name="a5260d542a8919de15b8398dfd2f90c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5260d542a8919de15b8398dfd2f90c78">&#9670;&nbsp;</a></span>find_cyclic_point_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::find_cyclic_point_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binfac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the orientation for an image with a cyclic point group symmetry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>point group. </td></tr>
    <tr><td class="paramname">binfac</td><td>binning for faster searching (limited to 1,2,3). </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit in angstroms. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit in angstroms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double symmetry correlation coefficient. <pre class="fragment">The cyclic point group symmetry operation is applied to an image using
the reference symmetry axis, aslo the 2D rotation axis (default {0,0,1}). 
</pre> </dd></dl>

</div>
</div>
<a id="acaf92f8a5678c4bf76b6b1530dc228aa" name="acaf92f8a5678c4bf76b6b1530dc228aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf92f8a5678c4bf76b6b1530dc228aa">&#9670;&nbsp;</a></span>find_helix_parameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::find_helix_parameters </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the best helix parameters for helical map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle_start</td><td>start value for angle. </td></tr>
    <tr><td class="paramname">angle_end</td><td>end value for angle. </td></tr>
    <tr><td class="paramname">angle_step</td><td>step size for angle. </td></tr>
    <tr><td class="paramname">bin</td><td>bin image for faster searching (limited to 1,2,3). </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit in angstroms. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit in angstroms. </td></tr>
    <tr><td class="paramname">radius</td><td>radius for mask (voxels). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bplot* plot with search results. <pre class="fragment">An incremental search is done for the rotation angle, with the rise
inferred from the cross-correlation shift.
</pre> </dd></dl>

</div>
</div>
<a id="ac3c7c1606f1635f114b13ee6a0fa7441" name="ac3c7c1606f1635f114b13ee6a0fa7441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c7c1606f1635f114b13ee6a0fa7441">&#9670;&nbsp;</a></span>find_helix_parameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::find_helix_parameters </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rise_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rise_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rise_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the best helix parameters for helical map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rise_start</td><td>start value for rise. </td></tr>
    <tr><td class="paramname">rise_end</td><td>end value for rise. </td></tr>
    <tr><td class="paramname">rise_step</td><td>step size for rise. </td></tr>
    <tr><td class="paramname">angle_start</td><td>start value for angle. </td></tr>
    <tr><td class="paramname">angle_end</td><td>end value for angle. </td></tr>
    <tr><td class="paramname">angle_step</td><td>step size for angle. </td></tr>
    <tr><td class="paramname">bin</td><td>bin image for faster searching (limited to 1,2,3). </td></tr>
    <tr><td class="paramname">radius</td><td>radius for mask (voxels). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bplot* plot with search results. <pre class="fragment">An incremental search is done for the rise and rotation angle.
</pre> </dd></dl>

</div>
</div>
<a id="a2daa0d26e64c9e49ddb2a0cc14e8c2d0" name="a2daa0d26e64c9e49ddb2a0cc14e8c2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2daa0d26e64c9e49ddb2a0cc14e8c2d0">&#9670;&nbsp;</a></span>find_peak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::find_peak </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1e30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the peak in an image to the nearest voxel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>search radius (if &lt; 1, default 1e30). </td></tr>
    <tr><td class="paramname">sigma</td><td>attenuation around radius. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">An image is searched for the global maximum (typically used to find
the shift vector in a cross-correlation map).
The peak vectors returned are in actual pixel coordinates (no wrapping).
The location around which to search is taken from the image origins.
</pre> </dd></dl>

</div>
</div>
<a id="a4b849fa786ec2cf1d144ca94bf46f7f3" name="a4b849fa786ec2cf1d144ca94bf46f7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b849fa786ec2cf1d144ca94bf46f7f3">&#9670;&nbsp;</a></span>find_peaks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; * Bimage::find_peaks </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>excl_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>ncoor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>threshold_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>threshold_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pix_min</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pix_max</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the peaks in a cross-correlation map to find template matches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">excl_dist</td><td>exclusion distance between peaks. </td></tr>
    <tr><td class="paramname">&amp;ncoor</td><td>number of coordinates. </td></tr>
    <tr><td class="paramname">&amp;threshold_min</td><td>minimum threshold to choose peaks. </td></tr>
    <tr><td class="paramname">&amp;threshold_max</td><td>maximum threshold to choose peaks. </td></tr>
    <tr><td class="paramname">pix_min</td><td>minimum peak width. </td></tr>
    <tr><td class="paramname">pix_max</td><td>maximum peak width. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector3.html">Vector3&lt;double&gt;</a>* list of coordinates. <pre class="fragment">The map is searched in increments of the particle radius to identify
peaks above the threshold and within a box the size of the
particle radius. The identified peaks are further examined to eliminate 
ones that are too close to a higher scoring peak. The acceptable distance
between peaks is set to 1.8 times the particle radius.
</pre> </dd></dl>

</div>
</div>
<a id="a29d7ab7027984b63c96e3f9f6ba4ee7a" name="a29d7ab7027984b63c96e3f9f6ba4ee7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d7ab7027984b63c96e3f9f6ba4ee7a">&#9670;&nbsp;</a></span>find_peaks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::find_peaks </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>kernelsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds peaks in a map with periodic boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernelsize</td><td>size of kernel side (must be ≥3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* image with peaks. <pre class="fragment">A peak is defined as the local maximum within a specified kernel, where the
maximum is also larger than a given threshold. This assumes that the region
around a peak decreases monotonically on the scale length of the size of
the kernel. With kernel edge of 3 (+-1 in all directions), the values around
the peak shows a strict monotonicity with distance from the peak maximum.
The peak positions and values are returned in the new image.
</pre> </dd></dl>

</div>
</div>
<a id="a914355785c950b3e733936a999fb155b" name="a914355785c950b3e733936a999fb155b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914355785c950b3e733936a999fb155b">&#9670;&nbsp;</a></span>find_point_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::find_point_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binfac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the orientation for an image with a specific point group symmetry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>point group. </td></tr>
    <tr><td class="paramname">angle_step</td><td>angular step size for search. </td></tr>
    <tr><td class="paramname">binfac</td><td>binning for faster searching (limited to 1,2,3). </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit in angstroms. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit in angstroms. </td></tr>
    <tr><td class="paramname">flags</td><td>flag to search only for minor axes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double symmetry correlation coefficient. <pre class="fragment">The point group symmetry operations are applied to an image with an
orientation defined by the reference symmetry axis (default {0,0,1}). 
</pre> </dd></dl>

</div>
</div>
<a id="a73b98ed9bd3b989b31defd06c1eb027a" name="a73b98ed9bd3b989b31defd06c1eb027a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b98ed9bd3b989b31defd06c1eb027a">&#9670;&nbsp;</a></span>find_shift() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::find_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refine_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a cross-correlation map to find the shift for the pair of images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pref</td><td>reference image. </td></tr>
    <tr><td class="paramname">*pmask</td><td>binary mask (only 0 and 1). </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">radius</td><td>search radius (if &lt; 1, default 1e30). </td></tr>
    <tr><td class="paramname">sigma</td><td>attenuation around radius. </td></tr>
    <tr><td class="paramname">refine_flag</td><td>set to refine shift to subpixel resolution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D data sets are transformed 
forward, the first transform multiplied by the complex conjugate of
the second transform, followed by backward transformation and 
rescaling by 1/(N*N). Data beyond the resolution set in the first 
image structure are not used. Therefore the correct setting 
of units and resolution in the image are required. Defaults for the 
units are usually 1 Angstrom/voxel and a zero resolution would
include the whole image (i.e., no resolution limitation).
A shift vector for each pair of images is calculated to
determine the cross-correlation peak to sub-pixel resolution.
Note: The first image is the reference and the shift returned is to
    transform the second to fit the first.
</pre> </dd></dl>

</div>
</div>
<a id="a47921af3160535f94f3060a87524ad6a" name="a47921af3160535f94f3060a87524ad6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47921af3160535f94f3060a87524ad6a">&#9670;&nbsp;</a></span>find_shift() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::find_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refine_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0c36d9cb08f5525ff89f3c27ef1b763" name="ae0c36d9cb08f5525ff89f3c27ef1b763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c36d9cb08f5525ff89f3c27ef1b763">&#9670;&nbsp;</a></span>find_shift() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::find_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refine_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a cross-correlation map to find the shift for the pair of images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pref</td><td>reference image. </td></tr>
    <tr><td class="paramname">*pmask</td><td>binary mask (only 0 and 1). </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">radius</td><td>search radius (if &lt; 1, default 1e30). </td></tr>
    <tr><td class="paramname">sigma</td><td>attenuation around radius. </td></tr>
    <tr><td class="paramname">refine_flag</td><td>set to refine shift to subpixel resolution. </td></tr>
    <tr><td class="paramname">planf</td><td>forward Fourier transform plan. </td></tr>
    <tr><td class="paramname">planb</td><td>backward Fourier transform plan. </td></tr>
    <tr><td class="paramname">&amp;cc</td><td>correlation coefficient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector3.html">Vector3&lt;double&gt;</a> shift. <pre class="fragment">FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D data sets are transformed 
forward, the first transform multiplied by the complex conjugate of
the second transform, followed by backward transformation and 
rescaling by 1/(N*N). Data beyond the resolution set in the first 
image structure are not used. Therefore the correct setting 
of units and resolution in the image are required. Defaults for the 
units are usually 1 Angstrom/voxel and a zero resolution would
include the whole image (i.e., no resolution limitation).
A shift vector for each pair of images is calculated to
determine the cross-correlation peak to sub-pixel resolution.
Note: The first image is the reference and the shift returned is to
    transform the second to fit the first.

Only the first sub-image shift is calculated.
</pre> </dd></dl>

</div>
</div>
<a id="a574db68f6ca4c87c9854e1e4355c36ce" name="a574db68f6ca4c87c9854e1e4355c36ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574db68f6ca4c87c9854e1e4355c36ce">&#9670;&nbsp;</a></span>find_shift() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::find_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refine_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a cross-correlation map to find the shift for the pair of images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pref</td><td>reference image. </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">radius</td><td>search radius (if &lt; 1, default 1e30). </td></tr>
    <tr><td class="paramname">sigma</td><td>attenuation around radius. </td></tr>
    <tr><td class="paramname">refine_flag</td><td>set to refine shift to subpixel resolution. </td></tr>
    <tr><td class="paramname">planf</td><td>forward Fourier transform plan. </td></tr>
    <tr><td class="paramname">planb</td><td>backward Fourier transform plan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector3.html">Vector3&lt;double&gt;</a> shift. <pre class="fragment">FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D data sets are transformed 
forward, the first transform multiplied by the complex conjugate of
the second transform, followed by backward transformation and 
rescaling by 1/(N*N). Data beyond the resolution set in the first 
image structure are not used. Therefore the correct setting 
of units and resolution in the image are required. Defaults for the 
units are usually 1 Angstrom/voxel and a zero resolution would
include the whole image (i.e., no resolution limitation).
A shift vector for each pair of images is calculated to
determine the cross-correlation peak to sub-pixel resolution.
Note: The first image is the reference and the shift returned is to
    transform the second to fit the first.

Only the first sub-image shift is calculated.
</pre> </dd></dl>

</div>
</div>
<a id="af9c9aed8bf9257e2d04101cc548d20ca" name="af9c9aed8bf9257e2d04101cc548d20ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c9aed8bf9257e2d04101cc548d20ca">&#9670;&nbsp;</a></span>find_shift() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::find_shift </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lo_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a cross-correlation map to find the shift for the pair of images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image to align. </td></tr>
    <tr><td class="paramname">*pref</td><td>reference image. </td></tr>
    <tr><td class="paramname">*pmask</td><td>binary mask for cross-correlation (only 0 and 1). </td></tr>
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lo_res</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">shift_limit</td><td>search radius (if &lt; 1, default 1e30). </td></tr>
    <tr><td class="paramname">planf</td><td>forward Fourier transform plan. </td></tr>
    <tr><td class="paramname">planb</td><td>backward Fourier transform plan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double correlation coefficient. <pre class="fragment">The shift is returned as the origin of each sub-image relative to
the reference origin.
</pre> </dd></dl>

</div>
</div>
<a id="a6f896443c7d6dcfe0674232c5fa89684" name="a6f896443c7d6dcfe0674232c5fa89684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f896443c7d6dcfe0674232c5fa89684">&#9670;&nbsp;</a></span>find_shift_in_transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::find_shift_in_transform </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the shift by brute force backtransformation for selected shifts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift_limit</td><td>maximum real space shift. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector3.html">Vector3&lt;double&gt;</a> best shift. <pre class="fragment">The input image is a cross-correlation transform.
A brute force integration is done for the given shift to calculate
the corresponding correlation coefficient.
The correlation coefficient is return in the FOM field of the sub-image.
</pre> </dd></dl>

</div>
</div>
<a id="ad3de86725584217217b4ab919ef3dcdb" name="ad3de86725584217217b4ab919ef3dcdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3de86725584217217b4ab919ef3dcdb">&#9670;&nbsp;</a></span>find_shift_in_transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::find_shift_in_transform </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a325003555664ad5ab63d7313d15fd26e" name="a325003555664ad5ab63d7313d15fd26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325003555664ad5ab63d7313d15fd26e">&#9670;&nbsp;</a></span>find_symmetric_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::find_symmetric_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>ptemp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phi_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the view that on symmetrizing fits best to a symmetric template. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*ptemp</td><td>symmetric template. </td></tr>
    <tr><td class="paramname">&amp;sym</td><td>symmetry. </td></tr>
    <tr><td class="paramname">phi_step</td><td>phi angle step size (radians). </td></tr>
    <tr><td class="paramname">theta_step</td><td>theta angle step size (radians). </td></tr>
    <tr><td class="paramname">alpha_step</td><td>rotation angle step size (radians). </td></tr>
    <tr><td class="paramname">shift</td><td>shift to impose before symmetrization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* image rotated to the best view. <pre class="fragment">The orientation parameters, view vector, angle of rotation and origin,
of each image is packed into 3D reciprocal space.
An image is used in the reconstruction if its selection flag has been set.
The fill value is taken from image's background value.  
</pre> </dd></dl>

</div>
</div>
<a id="a78cdf739a9bc772b13b7a7ca95753dbd" name="a78cdf739a9bc772b13b7a7ca95753dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cdf739a9bc772b13b7a7ca95753dbd">&#9670;&nbsp;</a></span>find_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::find_template </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>ptemp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds one or more matches to a template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*ptemp</td><td>template image. </td></tr>
    <tr><td class="paramname">*pmask</td><td>reciprocal space mask. </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">bin</td><td>level of image binning. </td></tr>
    <tr><td class="paramname">planf</td><td>forward Fourier transform plan. </td></tr>
    <tr><td class="paramname">planb</td><td>backward Fourier transform plan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* cross-correlation map. <pre class="fragment">A template is cross-correlated with the input image including
bandpass filtering to target the size of the template particle.
</pre> </dd></dl>

</div>
</div>
<a id="a8be0b064eefaf517f0158b05a0d61bd1" name="a8be0b064eefaf517f0158b05a0d61bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be0b064eefaf517f0158b05a0d61bd1">&#9670;&nbsp;</a></span>fit_peak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::fit_peak </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fits an elliptic parabole to locate the position of the peak to sub-voxel resolution. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector3.html">Vector3&lt;double&gt;</a> shift from input origin. <pre class="fragment">The peak is expected to be near the middle of the image, close to the input origin.
The function fits a 10-parameter parabola to the image.
The shift is retrieved from the parameters by matrix inversion.
The refined peak returned is the offset from the input origin.
</pre> </dd></dl>

</div>
</div>
<a id="ad5c08defb61a7aa665e94d222ea88d08" name="ad5c08defb61a7aa665e94d222ea88d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c08defb61a7aa665e94d222ea88d08">&#9670;&nbsp;</a></span>fix_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::fix_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the replacement data type. </p>
<dl class="section return"><dt>Returns</dt><dd>DataType replacement data type. <pre class="fragment">An integer data type is switched between signed and unsigned.
</pre> </dd></dl>

</div>
</div>
<a id="a2fd16f09564f26841e4e0468ae3a232f" name="a2fd16f09564f26841e4e0468ae3a232f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd16f09564f26841e4e0468ae3a232f">&#9670;&nbsp;</a></span>fourier_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_bimage_8h.html#a01e0deba350901d769526633e868806f">FourierType</a> Bimage::fourier_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bc472566e81a653bf7659c2f26fd0e9" name="a2bc472566e81a653bf7659c2f26fd0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc472566e81a653bf7659c2f26fd0e9">&#9670;&nbsp;</a></span>fourier_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::fourier_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_bimage_8h.html#a01e0deba350901d769526633e868806f">FourierType</a>&#160;</td>
          <td class="paramname"><em>tf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b6c1ccff23519853d4e246d60e7c5c2" name="a6b6c1ccff23519853d4e246d60e7c5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6c1ccff23519853d4e246d60e7c5c2">&#9670;&nbsp;</a></span>friedel_apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::friedel_apply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies Friedel symmetry. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The Friedel-related voxels are converted to polar form and the 
in difference in amplitude and phase calculated (taking into account
the phases should differ by sign). The voxels are then set to the
average and its conjugate.
</pre> </dd></dl>

</div>
</div>
<a id="ad6e43e43ac9ae08e0a28564decbf278d" name="ad6e43e43ac9ae08e0a28564decbf278d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e43e43ac9ae08e0a28564decbf278d">&#9670;&nbsp;</a></span>friedel_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::friedel_check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks Friedel symmetry. </p>
<dl class="section return"><dt>Returns</dt><dd>double overall RMSD or residual. <pre class="fragment">The differences between the complex and polar forms of Friedel-related 
voxels are calculated and accumulated as squared sums weighted by their
average intensities. The residuals are then calculated as 
root-mean-square-deviations.
</pre> </dd></dl>

</div>
</div>
<a id="aae84c0a38fd631080656901ef9468f8d" name="aae84c0a38fd631080656901ef9468f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae84c0a38fd631080656901ef9468f8d">&#9670;&nbsp;</a></span>fsc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::fsc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_ratio</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2e604cb03f66a11a174eff259bb6f54" name="aa2e604cb03f66a11a174eff259bb6f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e604cb03f66a11a174eff259bb6f54">&#9670;&nbsp;</a></span>fsc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::fsc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_ratio</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53929c5258e3e6d2301375781bf3704b" name="a53929c5258e3e6d2301375781bf3704b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53929c5258e3e6d2301375781bf3704b">&#9670;&nbsp;</a></span>fsc_dpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::fsc_dpr </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_ratio</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an FSC and DPR curves from two images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">sampling_ratio</td><td>radial sampling ratio (1 for per voxel sampling). </td></tr>
    <tr><td class="paramname">flag</td><td>if 1 calculate only the FSC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bplot* FSC curve. <pre class="fragment">FRC: Fourier ring/shell correlation 
-----------------------------------
Saxton &amp; Baumeister (1982) J. Microscopy 127, 127-138 
de la Fraga et al. (1995) Ultramicroscopy 60, 385-391 
           sum(|F1|*|F2|) 
FRC/FSC = --------------------------------- 
          sqrt( sum(|F1|^2) * sum(|F2|^2) ) 
</pre> </dd></dl>

</div>
</div>
<a id="a5dad3f53957a2ae41c2665080274cbd7" name="a5dad3f53957a2ae41c2665080274cbd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dad3f53957a2ae41c2665080274cbd7">&#9670;&nbsp;</a></span>fsc_local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::fsc_local </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>vedge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>taper</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the local resolution at each masked voxel in a map. </p>
<dl class="section author"><dt>Author</dt><dd>Giovanni Cardone and Bernard Heymann </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
    <tr><td class="paramname">*pmask</td><td>mask. </td></tr>
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">*cutoff</td><td>correlation threshold(s). </td></tr>
    <tr><td class="paramname">mask_level</td><td>mask level index. </td></tr>
    <tr><td class="paramname">size</td><td>kernel size. </td></tr>
    <tr><td class="paramname">pad</td><td>padding factor. </td></tr>
    <tr><td class="paramname">vedge</td><td>edge size. </td></tr>
    <tr><td class="paramname">step</td><td>voxel step size. </td></tr>
    <tr><td class="paramname">taper</td><td>kernel tapering function. </td></tr>
    <tr><td class="paramname">fill</td><td>background fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* local resolution image. <pre class="fragment">For each voxel specified in the mask, within the edge limits, and at
the step size given, two kernels are extracted from the two input maps.
These kernels are then compared to determine the resolution based FSC.
The resultant resolution value is then written into a new map.
</pre> </dd></dl>

</div>
</div>
<a id="a8e64a59b52e430a10cee5540c0024940" name="a8e64a59b52e430a10cee5540c0024940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e64a59b52e430a10cee5540c0024940">&#9670;&nbsp;</a></span>fsc_shell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::fsc_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pad</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smooth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the resolution for each concentric shell in a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">*cutoff</td><td>correlation threshold(s). </td></tr>
    <tr><td class="paramname">thickness</td><td>shell thickness. </td></tr>
    <tr><td class="paramname">step</td><td>step size between shells. </td></tr>
    <tr><td class="paramname">minrad</td><td>minimum radius. </td></tr>
    <tr><td class="paramname">maxrad</td><td>maximum radius. </td></tr>
    <tr><td class="paramname">pad</td><td>padding factor. </td></tr>
    <tr><td class="paramname">smooth</td><td>flag for edge smooting. </td></tr>
    <tr><td class="paramname">fill</td><td>background fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* a 1D image containing the shell resolutions. </dd></dl>

</div>
</div>
<a id="aa75d027b66e4adb4ef2f31ebb14da778" name="aa75d027b66e4adb4ef2f31ebb14da778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75d027b66e4adb4ef2f31ebb14da778">&#9670;&nbsp;</a></span>fspace_2D_interpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_2D_interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_complex.html">Complex</a>&lt; float &gt;&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>part_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interp_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates a 2D image for packing ito a 3D reciprocal space volume. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cv</td><td>complex value from 2D transform. </td></tr>
    <tr><td class="paramname">m</td><td>location in 3D relative to origin. </td></tr>
    <tr><td class="paramname">part_weight</td><td>weight to assign to value (usually 1). </td></tr>
    <tr><td class="paramname">interp_type</td><td>interpolation type (0=nearest neighbor, 1=weighted nearest neigbor, 2=trilinear). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. </dd></dl>

</div>
</div>
<a id="af4f70203482c3025452fb5e9a097bde6" name="af4f70203482c3025452fb5e9a097bde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f70203482c3025452fb5e9a097bde6">&#9670;&nbsp;</a></span>fspace_amp_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_amp_one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all amplitudes to one. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">If the image is a not a Fourier transform, it is transformed, modified,
and backtransformed. If the image is a Fourier transform, it is just
modified. The resultant image is floating point for real space or
complex for reciprocal space.
</pre> </dd></dl>

</div>
</div>
<a id="a2f66579e3b1e53aec78ae09985ce824b" name="a2f66579e3b1e53aec78ae09985ce824b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f66579e3b1e53aec78ae09985ce824b">&#9670;&nbsp;</a></span>fspace_amp_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_amp_threshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters the amplitudes of the Fourier transform of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>Miminum amplitude to accept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered. The filtering sets all amplitudes below the given threshold
to zero. The resultant image is floating point for real space or
complex for reciprocal space.
</pre> </dd></dl>

</div>
</div>
<a id="ad4570a384d1683cfcc8e2b1c18c0bda8" name="ad4570a384d1683cfcc8e2b1c18c0bda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4570a384d1683cfcc8e2b1c18c0bda8">&#9670;&nbsp;</a></span>fspace_background()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_background </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the background for a Fourier transform. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. The background is taken to be the area outside Nyquest. </dd></dl>

</div>
</div>
<a id="a3a004d126c6b9441256e145226416293" name="a3a004d126c6b9441256e145226416293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a004d126c6b9441256e145226416293">&#9670;&nbsp;</a></span>fspace_bandpass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_bandpass </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a bandpass filter to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res_hi</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">res_lo</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of edge. </td></tr>
    <tr><td class="paramname">planf</td><td>forward Fourier transform plan. </td></tr>
    <tr><td class="paramname">planb</td><td>backward Fourier transform plan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered. The filtering sets all values with frequencies above the
given high resolution limit and below the given low resolution limit
to zero.
</pre> </dd></dl>

</div>
</div>
<a id="a64fc3ee68565a1a039b34145446295a2" name="a64fc3ee68565a1a039b34145446295a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fc3ee68565a1a039b34145446295a2">&#9670;&nbsp;</a></span>fspace_bandpass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_bandpass </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_lo</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a bandpass filter to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res_hi</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">res_lo</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered. The filtering sets all values with frequencies above the
given high resolution limit and below the given low resolution limit
to zero.
</pre> </dd></dl>

</div>
</div>
<a id="ad411c82b4d184c05045f3ecb4cbee83d" name="ad411c82b4d184c05045f3ecb4cbee83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad411c82b4d184c05045f3ecb4cbee83d">&#9670;&nbsp;</a></span>fspace_default_bands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; Bimage::fspace_default_bands </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up default frequency space bands to generate a mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res_lo</td><td>low resolution limit (angstrom). </td></tr>
    <tr><td class="paramname">res_hi</td><td>high resolution limit (angstrom). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt; array of band specifications. <pre class="fragment">The band argument is a list of pairs of values, each pair indicating
a resolution shell (in angstrom) and a flag indicating whether the 
following shells should be:
    0: excluded - also the high resolution limit
    1: included in the FOM
    -1: included in the cross-validation FOM
The high resolution limit for the mask is set in the image structure.
</pre> </dd></dl>

</div>
</div>
<a id="af9ea5aed3caede8ae6e6e223adf35093" name="af9ea5aed3caede8ae6e6e223adf35093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ea5aed3caede8ae6e6e223adf35093">&#9670;&nbsp;</a></span>fspace_fit_B_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::fspace_fit_B_factor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the overall B-factor of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res_hi</td><td>high resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double B-factor. <pre class="fragment">The input image must a real space image. A radial power spectrum
is calculated and fitted to the linearized version of the function:
    f^2 = scale * F^2 * exp(-B_factor/2 * s^2)
where:
    f:  scattering profile for carbon
    F:  radial average amplitude
    s:  reciprocal space distance
    scale:  arbitrary scale
The linear form of the function is:
    4*(log(f) - log(F)) = 2*log(scale) - B * s^2
</pre> </dd></dl>

</div>
</div>
<a id="a39127eceed3818eb3a0e1e59f0d329f3" name="a39127eceed3818eb3a0e1e59f0d329f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39127eceed3818eb3a0e1e59f0d329f3">&#9670;&nbsp;</a></span>fspace_frequency_filter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_frequency_filter </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a frequency filter to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>frequency or inverse frequency. </td></tr>
    <tr><td class="paramname">sigma</td><td>gaussian envelope width around frequency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered.
The filter imposes a guassian envelope at the given frequency.
If the frequency value is greater than one, it is assumed to be given
as the inverse.
</pre> </dd></dl>

</div>
</div>
<a id="a6e20382b67e69755e6db457043a0d396" name="a6e20382b67e69755e6db457043a0d396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e20382b67e69755e6db457043a0d396">&#9670;&nbsp;</a></span>fspace_frequency_filter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_frequency_filter </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a frequency filter to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>frequency or inverse frequency. </td></tr>
    <tr><td class="paramname">sigma</td><td>gaussian envelope width around frequency. </td></tr>
    <tr><td class="paramname">planf</td><td>forward Fourier transform plan. </td></tr>
    <tr><td class="paramname">planb</td><td>backward Fourier transform plan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered.
The filter imposes a guassian envelope at the given frequency.
If the frequency value is greater than one, it is assumed to be given
as the inverse.
</pre> </dd></dl>

</div>
</div>
<a id="a3cdd3fb2790fb3c739546f4c95462440" name="a3cdd3fb2790fb3c739546f4c95462440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdd3fb2790fb3c739546f4c95462440">&#9670;&nbsp;</a></span>fspace_gabor_filter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_gabor_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fsigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a Gabor filter to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>frequency or inverse frequency location. </td></tr>
    <tr><td class="paramname">fsigma</td><td>gaussian envelope width in the direction of the frequency vector. </td></tr>
    <tr><td class="paramname">psigma</td><td>gaussian envelope width perpendicular to the frequency vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered.
The filter imposes a guassian envelope at the given frequency location.
If the frequency vector size is greater than one, it is assumed to be given
as the inverse.
</pre> </dd></dl>

</div>
</div>
<a id="aece2172a647021b71693e1335a52ad4e" name="aece2172a647021b71693e1335a52ad4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece2172a647021b71693e1335a52ad4e">&#9670;&nbsp;</a></span>fspace_gabor_filter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_gabor_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fsigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a Gabor filter to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>frequency or inverse frequency direction location. </td></tr>
    <tr><td class="paramname">fsigma</td><td>gaussian envelope width in the direction of the frequency vector. </td></tr>
    <tr><td class="paramname">psigma</td><td>gaussian envelope width perpendicular to the frequency vector. </td></tr>
    <tr><td class="paramname">planf</td><td>forward Fourier transform plan. </td></tr>
    <tr><td class="paramname">planb</td><td>backward Fourier transform plan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered.
The filter imposes a guassian envelope at the given frequency location.
If the frequency vector size is greater than one, it is assumed to be given
as the inverse.
</pre> </dd></dl>

</div>
</div>
<a id="a4009dab9defb1ef39feb77371124422f" name="a4009dab9defb1ef39feb77371124422f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4009dab9defb1ef39feb77371124422f">&#9670;&nbsp;</a></span>fspace_gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::fspace_gradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>sigma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a image with orthogonal gradients encded in 3-value vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigma</td><td>Gaussian sigma values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is Fourier transformed if needed.
An anisotropic weight function is calculated at each voxel and applied to the transform.
</pre> </dd></dl>

</div>
</div>
<a id="a7cc08eed53836fe562577d3a19f24a50" name="a7cc08eed53836fe562577d3a19f24a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc08eed53836fe562577d3a19f24a50">&#9670;&nbsp;</a></span>fspace_interpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_complex.html">Complex</a>&lt; double &gt; Bimage::fspace_interpolate </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>img_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_s_i___kernel.html">FSI_Kernel</a> *&#160;</td>
          <td class="paramname"><em>kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the complex value at an image location by kernel-based interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_num</td><td>sub-image number. </td></tr>
    <tr><td class="paramname">m</td><td>location in image. </td></tr>
    <tr><td class="paramname">kernel</td><td>interpolation kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complex&lt;double&gt; interpolated value. The kernel lookup table must be precalculated. </dd></dl>

</div>
</div>
<a id="af2949fc9aeff65845b1c0e64f3cae467" name="af2949fc9aeff65845b1c0e64f3cae467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2949fc9aeff65845b1c0e64f3cae467">&#9670;&nbsp;</a></span>fspace_maximum_radius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::fspace_maximum_radius </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_ratio</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the maximum radius in frequency space from a given resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">sampling_ratio</td><td>frequency space sampling (default 1 pixel/sample). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long maximum radius. <pre class="fragment">The maximum radius is either the physical image size divided by the resolution,
or Nyquist frequency.
</pre> </dd></dl>

</div>
</div>
<a id="a06dc3d6c69b51aea7926b530e8f963ec" name="a06dc3d6c69b51aea7926b530e8f963ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06dc3d6c69b51aea7926b530e8f963ec">&#9670;&nbsp;</a></span>fspace_normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes an image's amplitudes. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="ad71a5271e9a56028d01378519f152970" name="ad71a5271e9a56028d01378519f152970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71a5271e9a56028d01378519f152970">&#9670;&nbsp;</a></span>fspace_normalize_radial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_normalize_radial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes an image's amplitudes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>reciprocal space mask (0 &amp; 1, indicating inclusion of structure factors). </td></tr>
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">flag</td><td>flag to calculate power (0) or amplitude (1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="ac1fa0fdcb205c13fd845e64285504be8" name="ac1fa0fdcb205c13fd845e64285504be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fa0fdcb205c13fd845e64285504be8">&#9670;&nbsp;</a></span>fspace_pack_2D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_pack_2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lo_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>part_weight</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interp_type</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packs a 2D Fourier transform into a 3D reciprocal space volume. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>2D particle image transform. </td></tr>
    <tr><td class="paramname">mat</td><td>rotation matrix. </td></tr>
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lo_res</td><td>low resolution limit (infinite if 0). </td></tr>
    <tr><td class="paramname">scale</td><td>scale of reconstruction and particle magnification. </td></tr>
    <tr><td class="paramname">part_weight</td><td>weight of particle (usually 1). </td></tr>
    <tr><td class="paramname">interp_type</td><td>interpolation type (0=nearest neighbor, 1=weighted nearest neigbor, 2=trilinear). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">The rotation matrix is used to determine the plane in reciprocal space
to which the 2D transform data is added. The map is assumed to be cubic
and the 2D transform square. The orientation parameters must be written
into the image structure. 
</pre> </dd></dl>

</div>
</div>
<a id="ab10fa82f152bee515c19971d2e8a1994" name="ab10fa82f152bee515c19971d2e8a1994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10fa82f152bee515c19971d2e8a1994">&#9670;&nbsp;</a></span>fspace_pack_2D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_pack_2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>asu_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lo_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>part_weight</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interp_type</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packs a 2D Fourier transform into a 3D reciprocal space volume. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>2D particle image transform. </td></tr>
    <tr><td class="paramname">asu_view</td><td>view of asymmetric unit. </td></tr>
    <tr><td class="paramname">*sym</td><td>point group symmetry. </td></tr>
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lo_res</td><td>low resolution limit (infinite if 0). </td></tr>
    <tr><td class="paramname">scale</td><td>scale of reconstruction and particle magnification. </td></tr>
    <tr><td class="paramname">part_weight</td><td>weight of particle (usually 1). </td></tr>
    <tr><td class="paramname">interp_type</td><td>interpolation type (0=nearest neighbor, 1=weighted nearest neigbor, 2=trilinear). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">The rotation matrix is used to determine the plane in reciprocal space
to which the 2D transform data is added. The map is assumed to be cubic
and the 2D transform square. The orientation parameters must be written
into the image structure.
</pre> </dd></dl>

</div>
</div>
<a id="a71b940c547ffc63a3295545992833de9" name="a71b940c547ffc63a3295545992833de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b940c547ffc63a3295545992833de9">&#9670;&nbsp;</a></span>fspace_pack_2D_into_central_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::fspace_pack_2D_into_central_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ft_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lo_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>matr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packs a 2D Fourier transform into a central section of a 3D reciprocal space volume. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>2D particle image transform. </td></tr>
    <tr><td class="paramname">ft_size</td><td>Fourier transform size. </td></tr>
    <tr><td class="paramname">scale</td><td>scale of reconstruction and particle magnification. </td></tr>
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lo_res</td><td>low resolution limit (infinite if 0). </td></tr>
    <tr><td class="paramname">matr</td><td>central section orientation matrix. </td></tr>
    <tr><td class="paramname">mat</td><td>image orientation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">The rotation matrix is used to determine the plane in reciprocal space
to which the 2D transform data is added in reference to the rotation
matrix of the central section. The map is assumed to be cubic
and the 2D transform square. The orientation parameters must be written
into the image structure. 
</pre> </dd></dl>
<p ><a class="el" href="class_vector3.html">Vector3&lt;double&gt;</a> vn(mat[2][0]/mat[2][2], mat[2][1]/mat[2][2], 0);</p>
<p >matr = matr.transpose();</p>
<p >m = mat * iv; m[2] = m.scalar(vn); m = matr * m;</p>

</div>
</div>
<a id="ab4adb193f4e57c5a3395cfe5da8a3682" name="ab4adb193f4e57c5a3395cfe5da8a3682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4adb193f4e57c5a3395cfe5da8a3682">&#9670;&nbsp;</a></span>fspace_pack_3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_pack_3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packs a 3D Fourier transform into a 3D reciprocal space volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>3D particle image transform. </td></tr>
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">threshold</td><td>threshold to exclude low intensities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">The image is added up to the high resolution limit and excluding
low intensities as defined by the threshold.
</pre> </dd></dl>

</div>
</div>
<a id="a3e641a765529eca00a388d3ccda2c5e9" name="a3e641a765529eca00a388d3ccda2c5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e641a765529eca00a388d3ccda2c5e9">&#9670;&nbsp;</a></span>fspace_positive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_positive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the image to positive definite. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. Scales the amplitudes to give a zero (DC) value of one. </dd></dl>

</div>
</div>
<a id="ac7365e14f761ca13be325fda8991d3ff" name="ac7365e14f761ca13be325fda8991d3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7365e14f761ca13be325fda8991d3ff">&#9670;&nbsp;</a></span>fspace_radial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; Bimage::fspace_radial </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the radial power spectrum from a Fourier transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image number. </td></tr>
    <tr><td class="paramname">maxrad</td><td>maximum radius (i.e., high resolution limit). </td></tr>
    <tr><td class="paramname">flag</td><td>flag to calculate power (0) or amplitude (1), and not normalize (2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double* radial power spectrum in the form of a 1D image.</dd></dl>
<p>A radial average of a 2D or 3D Fourier transform is calculated. An interpolative method is used where the value of a voxel is distributed between the two nearest radial annuli. The final sum in an annulus is normalized by the number of voxels contributing to the annulus sum. </p>

</div>
</div>
<a id="ae73ec86061ff431511f6c635c1695b87" name="ae73ec86061ff431511f6c635c1695b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73ec86061ff431511f6c635c1695b87">&#9670;&nbsp;</a></span>fspace_radial_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::fspace_radial_power </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_ratio</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the radial power spectrum from a Fourier transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">sampling_ratio</td><td>frequency space sampling (default 1 pixel/sample). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* radial power spectrum in the form of a 1D image. <pre class="fragment">A radial average of a 2D or 3D Fourier transform is calculated.  
An interpolative method is used where the value of 
a voxel is distributed between the two nearest radial annuli.
The final sum in an annulus is normalized by the number of voxels 
contributing to the annulus sum.
</pre> </dd></dl>

</div>
</div>
<a id="ac80930fd138c661a8728b3a8cb39b72d" name="ac80930fd138c661a8728b3a8cb39b72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80930fd138c661a8728b3a8cb39b72d">&#9670;&nbsp;</a></span>fspace_reconstruction_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::fspace_reconstruction_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all components to a reconstruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>frequency space reconstruction to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long 0. <pre class="fragment">The FOM block contains the sum of powers, the next image conatins the
weight sum, and the next image FOM block contains the sum of the
weight squared.
</pre> </dd></dl>

</div>
</div>
<a id="a4f975f6f05c471150640a20add0acd86" name="a4f975f6f05c471150640a20add0acd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f975f6f05c471150640a20add0acd86">&#9670;&nbsp;</a></span>fspace_reconstruction_snr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::fspace_reconstruction_snr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the SNR map. </p>
<dl class="section return"><dt>Returns</dt><dd>long coverage. <pre class="fragment">The FOM block contains the sum of powers, the next image conatins the
weight sum, and the next image FOM block contains the sum of the
weight squared.
</pre> </dd></dl>

</div>
</div>
<a id="a203259c67bbe3d31b46d9b9f3c923153" name="a203259c67bbe3d31b46d9b9f3c923153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203259c67bbe3d31b46d9b9f3c923153">&#9670;&nbsp;</a></span>fspace_reconstruction_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_reconstruction_stats </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_ratio</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates Fourier shell statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">sampling_ratio</td><td>frequency space sampling (default 1 pixel/sample). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The average FOM and number of FOM values in each resolution shell is determined.
</pre> </dd></dl>

</div>
</div>
<a id="a37d5c9685021e104bea5e61dd1b87f60" name="a37d5c9685021e104bea5e61dd1b87f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d5c9685021e104bea5e61dd1b87f60">&#9670;&nbsp;</a></span>fspace_reconstruction_weigh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::fspace_reconstruction_weigh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs a reconstruction. </p>
<dl class="section return"><dt>Returns</dt><dd>long coverage. <pre class="fragment">The FOM block contains the sum of powers, the next image conatins the
weight sum, and the next image FOM block contains the sum of the
weight squared.
</pre> </dd></dl>

</div>
</div>
<a id="a0f425f44f6e885acd68fd329d07edd63" name="a0f425f44f6e885acd68fd329d07edd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f425f44f6e885acd68fd329d07edd63">&#9670;&nbsp;</a></span>fspace_resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::fspace_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes an image in frequency space to avoid interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pref</td><td>reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* resized image. The image is first resized to approximate the real size of the reference map. </dd></dl>

</div>
</div>
<a id="a7bfe151a39d17ada82c7ca0ed64fd589" name="a7bfe151a39d17ada82c7ca0ed64fd589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfe151a39d17ada82c7ca0ed64fd589">&#9670;&nbsp;</a></span>fspace_resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_resize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_lo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes an image in frequency space to avoid interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>isotropic scaling. </td></tr>
    <tr><td class="paramname">res_hi</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">res_lo</td><td>low resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="a2c92e49362a8548a332108661bd83530" name="a2c92e49362a8548a332108661bd83530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c92e49362a8548a332108661bd83530">&#9670;&nbsp;</a></span>fspace_scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_scale </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b5d55edda2562384bd08fbb5935a0d8" name="a4b5d55edda2562384bd08fbb5935a0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5d55edda2562384bd08fbb5935a0d8">&#9670;&nbsp;</a></span>fspace_scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_scale </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a280a87db787ad7c6827de67227a6117c" name="a280a87db787ad7c6827de67227a6117c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280a87db787ad7c6827de67227a6117c">&#9670;&nbsp;</a></span>fspace_shift_sum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::fspace_shift_sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7da47417a7d1fea0cd6a02cbab87c702" name="a7da47417a7d1fea0cd6a02cbab87c702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da47417a7d1fea0cd6a02cbab87c702">&#9670;&nbsp;</a></span>fspace_sqrt_amp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_sqrt_amp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the amlitudes to their square roots. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="a63076c1fcbd277ad435729c33b5be82f" name="a63076c1fcbd277ad435729c33b5be82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63076c1fcbd277ad435729c33b5be82f">&#9670;&nbsp;</a></span>fspace_square_amp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_square_amp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the amlitudes to their squares. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="a08afff70db68ac0b93636087899d6992" name="a08afff70db68ac0b93636087899d6992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08afff70db68ac0b93636087899d6992">&#9670;&nbsp;</a></span>fspace_ssnr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::fspace_ssnr </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nimg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7cd9416f78181f8d911f70be238ba6c" name="aa7cd9416f78181f8d911f70be238ba6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cd9416f78181f8d911f70be238ba6c">&#9670;&nbsp;</a></span>fspace_subset_ssnr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::fspace_subset_ssnr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dbe36e9969106b1a0761da10681f30b" name="a1dbe36e9969106b1a0761da10681f30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbe36e9969106b1a0761da10681f30b">&#9670;&nbsp;</a></span>fspace_subset_sums()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::fspace_subset_sums </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7cb4ca59bac82d6f9bc9986d82a889c" name="aa7cb4ca59bac82d6f9bc9986d82a889c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cb4ca59bac82d6f9bc9986d82a889c">&#9670;&nbsp;</a></span>fspace_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::fspace_sum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf4c3dbc2ad222e9ff66a5a0c6e4f562" name="adf4c3dbc2ad222e9ff66a5a0c6e4f562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4c3dbc2ad222e9ff66a5a0c6e4f562">&#9670;&nbsp;</a></span>fspace_translate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_translate </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates an image in frequency space to avoid interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image to transform. </td></tr>
    <tr><td class="paramname">shift</td><td>3-value real space shift vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="a8bbfd40bd975c34e1ed4235e58af8dc1" name="a8bbfd40bd975c34e1ed4235e58af8dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbfd40bd975c34e1ed4235e58af8dc1">&#9670;&nbsp;</a></span>fspace_translate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates an image in frequency space to avoid interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td>3-value real space shift vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. </dd></dl>

</div>
</div>
<a id="ac56288e974c1a25f146ccd97eb44df38" name="ac56288e974c1a25f146ccd97eb44df38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56288e974c1a25f146ccd97eb44df38">&#9670;&nbsp;</a></span>fspace_weigh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs an image's amplitudes with the radial power spectrum of another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pref</td><td>reference image. </td></tr>
    <tr><td class="paramname">*pmask</td><td>reciprocal space mask (0 &amp; 1, indicating inclusion of structure factors). </td></tr>
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The two images must be of the same dimensions.
The radial power spectra of the two images are calculated
and used to calculate the ratio of the second to the first in each shell.
This ratio is then used to rescale the amplitudes of the first image.
</pre> </dd></dl>

</div>
</div>
<a id="a06f7fe843ce8b5018344741d0023a29e" name="a06f7fe843ce8b5018344741d0023a29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f7fe843ce8b5018344741d0023a29e">&#9670;&nbsp;</a></span>fspace_weigh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bf9851313f15f0e59a4b5c14ed4fc99" name="a2bf9851313f15f0e59a4b5c14ed4fc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf9851313f15f0e59a4b5c14ed4fc99">&#9670;&nbsp;</a></span>fspace_weigh_accumulated_dose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh_accumulated_dose </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>dose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs an image's amplitudes with the accumulated dose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dose</td><td>array containing accumulated dose and parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The amplitudes are weighed using:
1. with 2 parameters: the formula of Grant and Grigorieff (2015).
2. with 3 parameters: exponential decay.
</pre> </dd></dl>

</div>
</div>
<a id="a12f04e97a5999c7e83e130768c25d583" name="a12f04e97a5999c7e83e130768c25d583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f04e97a5999c7e83e130768c25d583">&#9670;&nbsp;</a></span>fspace_weigh_B_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh_B_factor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs an image's amplitudes with B-factor (gaussian) curve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td>B factor. </td></tr>
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is Fourier transformed and weighed with a gaussian curve:
    Fnew = F*exp(-B*s2/4)
</pre> </dd></dl>

</div>
</div>
<a id="a242ffe8b2a4bcc216ae00afb86daca1d" name="a242ffe8b2a4bcc216ae00afb86daca1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242ffe8b2a4bcc216ae00afb86daca1d">&#9670;&nbsp;</a></span>fspace_weigh_C_curve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh_C_curve </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs an image's amplitudes with the carbon scattering curve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is Fourier transformed and the radial power spectrum calculated.
The ratio between the C curve and the average amplitudes in each shell
is calculated and used to rescale the amplitudes of the image.
</pre> </dd></dl>

</div>
</div>
<a id="a2a5148c88a8ffafddb8fef3f10f29b2d" name="a2a5148c88a8ffafddb8fef3f10f29b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5148c88a8ffafddb8fef3f10f29b2d">&#9670;&nbsp;</a></span>fspace_weigh_dose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh_dose </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dose_per_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs an image's amplitudes with the accumulated dose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dose_per_frame</td><td>electron dose per frame. </td></tr>
    <tr><td class="paramname">flag</td><td>0=Grant, 1=exponential decay. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is Fourier transformed and the amplitudes weighed using 
the formula of Grant and Grigorieff (2015) or an exponential decay curve.
</pre> </dd></dl>

</div>
</div>
<a id="aede6de7cbd6febba8dcfde126a052c40" name="aede6de7cbd6febba8dcfde126a052c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede6de7cbd6febba8dcfde126a052c40">&#9670;&nbsp;</a></span>fspace_weigh_dose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh_dose </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dose_per_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>critdose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3729092a9a3df3b1c98ebe7ef91fdfa3" name="a3729092a9a3df3b1c98ebe7ef91fdfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3729092a9a3df3b1c98ebe7ef91fdfa3">&#9670;&nbsp;</a></span>fspace_weigh_FSC_curve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh_FSC_curve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td>
          <td class="paramname"><em>plot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs an image's amplitudes with a given FSC curve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*plot</td><td>FSC plot. </td></tr>
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is Fourier transformed and the radial power spectrum calculated.
The ratio between the square root of the FSC curve and the average 
amplitudes in each shell is calculated and used to rescale the amplitudes 
of the image.
</pre> </dd></dl>

</div>
</div>
<a id="a2204b62b851a229a9c2cb3489052ae88" name="a2204b62b851a229a9c2cb3489052ae88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2204b62b851a229a9c2cb3489052ae88">&#9670;&nbsp;</a></span>fspace_weigh_gaussian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh_gaussian </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dir</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs an image's amplitudes with an anisotropic Gaussian function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image index. </td></tr>
    <tr><td class="paramname">sigma</td><td>Gaussian sigma values. </td></tr>
    <tr><td class="paramname">dir</td><td>derivative direction: 0=none, 1=x, 2=y, 3=z. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image must be a complex Fourier transform.
An anisotropic weight function is calculated at each voxel and applied to the transform.
</pre> </dd></dl>

</div>
</div>
<a id="afda57b400f1708167f2c7e64a60eb78b" name="afda57b400f1708167f2c7e64a60eb78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda57b400f1708167f2c7e64a60eb78b">&#9670;&nbsp;</a></span>fspace_weigh_LoG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh_LoG </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs an image's amplitudes with a Laplacian-of-Gaussian function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">sigma</td><td>gaussian sigma. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is Fourier transformed and the radial power spectrum calculated.
The ratio between the C curve and the average amplitudes in each shell
is calculated and used to rescale the amplitudes of the image.
</pre> </dd></dl>

</div>
</div>
<a id="a73c972326ebd2d236ec0fcdbc4b0cc5a" name="a73c972326ebd2d236ec0fcdbc4b0cc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c972326ebd2d236ec0fcdbc4b0cc5a">&#9670;&nbsp;</a></span>fspace_weigh_ramp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh_ramp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs a transform with a ramp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">axis</td><td>tilt axis for single tilt series (radians). </td></tr>
    <tr><td class="paramname">planf</td><td>2D forward Fourier transform plan. </td></tr>
    <tr><td class="paramname">planb</td><td>2D backward Fourier transform plan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">Requirements:
    The data must be complex float and the FOM block must be allocated.
</pre> </dd></dl>

</div>
</div>
<a id="aac65275f18cb7d8ffa4e11acdc15e10d" name="aac65275f18cb7d8ffa4e11acdc15e10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac65275f18cb7d8ffa4e11acdc15e10d">&#9670;&nbsp;</a></span>fspace_weigh_ramp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh_ramp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs a transform with a ramp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">planf</td><td>2D forward Fourier transform plan. </td></tr>
    <tr><td class="paramname">planb</td><td>2D backward Fourier transform plan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">Requirements:
    The data must be complex float and the FOM block must be allocated.
</pre> </dd></dl>

</div>
</div>
<a id="ac7decddf1751331d158e46c8eaefef00" name="ac7decddf1751331d158e46c8eaefef00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7decddf1751331d158e46c8eaefef00">&#9670;&nbsp;</a></span>fspace_weigh_RPS_curve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::fspace_weigh_RPS_curve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bplot.html">Bplot</a> *&#160;</td>
          <td class="paramname"><em>plot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighs an image's amplitudes with a given RPS curve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*plot</td><td>RPS plot. </td></tr>
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is Fourier transformed and the radial power spectrum calculated.
The ratio between the square root of the RPS curve and the average 
amplitudes in each shell is calculated and used to rescale the amplitudes 
of the image.
</pre> </dd></dl>

</div>
</div>
<a id="a8b232571fb7ecd9f8304a39fc16a5fab" name="a8b232571fb7ecd9f8304a39fc16a5fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b232571fb7ecd9f8304a39fc16a5fab">&#9670;&nbsp;</a></span>gaussian_sphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::gaussian_sphere </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>amp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a gaussian sphere within an image with a uniform value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">center</td><td>center of sphere. </td></tr>
    <tr><td class="paramname">sigma</td><td>Gaussian sigma value. </td></tr>
    <tr><td class="paramname">amp</td><td>amplitude. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">All voxels within a sphere at a given location and with a given radius 
are increased by a given fill value.
The new data replaces the old data.
The default center is {0,0,0}.
</pre> </dd></dl>

</div>
</div>
<a id="a26b30eb05be0db04eb94f479bbd7703b" name="a26b30eb05be0db04eb94f479bbd7703b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b30eb05be0db04eb94f479bbd7703b">&#9670;&nbsp;</a></span>get() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a>&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints out header information associated with a tag string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3fe0a2bedf7cd2fa732e4af2fbcb8fe" name="aa3fe0a2bedf7cd2fa732e4af2fbcb8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fe0a2bedf7cd2fa732e4af2fbcb8fe">&#9670;&nbsp;</a></span>get() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::get </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the data value at the given coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image index. </td></tr>
    <tr><td class="paramname">xx</td><td>x coordinate. </td></tr>
    <tr><td class="paramname">yy</td><td>y coordinate. </td></tr>
    <tr><td class="paramname">zz</td><td>z coordinate. </td></tr>
    <tr><td class="paramname">cc</td><td>channel index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double value. <pre class="fragment">The elemental data value is returned in double precision.
</pre> </dd></dl>

</div>
</div>
<a id="aa9cbc0cc1004deca981a0b5b20850c20" name="aa9cbc0cc1004deca981a0b5b20850c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9cbc0cc1004deca981a0b5b20850c20">&#9670;&nbsp;</a></span>get() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::get </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the data value at the given coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image index. </td></tr>
    <tr><td class="paramname">vox</td><td>voxel coordinates. </td></tr>
    <tr><td class="paramname">cc</td><td>channel index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double value. <pre class="fragment">The elemental data value is returned in double precision.
</pre> </dd></dl>

</div>
</div>
<a id="a840e19a120e4a6fad753a72498e318e9" name="a840e19a120e4a6fad753a72498e318e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840e19a120e4a6fad753a72498e318e9">&#9670;&nbsp;</a></span>get_localtime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tm * Bimage::get_localtime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bdc58228bbe84e0c029c347d0c61c9f" name="a8bdc58228bbe84e0c029c347d0c61c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bdc58228bbe84e0c029c347d0c61c9f">&#9670;&nbsp;</a></span>get_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t Bimage::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54ca5f2052e28406522cd592d4a311e6" name="a54ca5f2052e28406522cd592d4a311e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ca5f2052e28406522cd592d4a311e6">&#9670;&nbsp;</a></span>gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::gradient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the central difference gradient image. </p>
<dl class="section return"><dt>Returns</dt><dd>Bimage* an image with 3-value gradient vectors. <pre class="fragment">The central differences are calculated in the three orthogonal
directions and written into 3-value vectors.
</pre> </dd></dl>

</div>
</div>
<a id="a68fe6231d0f7ea94af7f610a02827580" name="a68fe6231d0f7ea94af7f610a02827580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fe6231d0f7ea94af7f610a02827580">&#9670;&nbsp;</a></span>gradient3x3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::gradient3x3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the difference gradient image in a 3x3 kernel. </p>
<dl class="section return"><dt>Returns</dt><dd>Bimage* an image with 3-value gradient vectors. <pre class="fragment">The central differences are calculated in the three orthogonal
directions and written into 3-value vectors.
</pre> </dd></dl>

</div>
</div>
<a id="a92a98004da23cb718e3e039f2ae130f9" name="a92a98004da23cb718e3e039f2ae130f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a98004da23cb718e3e039f2ae130f9">&#9670;&nbsp;</a></span>gradient_correction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::gradient_correction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and corrects for a linear gradient across an image. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The linear gradient across an image is calculated as:
    density(x,y,z) = b0 + b1*x + b2*y + b3*z
The image is converted to floating point and corrected for the gradient.
</pre> </dd></dl>

</div>
</div>
<a id="a3e7e93591778f6edd9ac10c841202b58" name="a3e7e93591778f6edd9ac10c841202b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7e93591778f6edd9ac10c841202b58">&#9670;&nbsp;</a></span>graph_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_sgraph.html">GSgraph</a> Bimage::graph_segment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connect_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>complexity</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>min_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Graph-based segmentation of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>segmentation type: 1=threshold, 2=statistical region merging. </td></tr>
    <tr><td class="paramname">connect_type</td><td>connection type: 0=direct neighbors, 1=all neighbors. </td></tr>
    <tr><td class="paramname">complexity</td><td>a value determining the number of segments. </td></tr>
    <tr><td class="paramname">min_size</td><td>minimum segment size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_g_sgraph.html" title="Graph segmentation container.">GSgraph</a> graph with segment designations. <pre class="fragment">An array of edges between neighboring voxels is set up and sorted in
non-decreasing order. The voxels are then aggregated into regions based
on two selectable criteria:
simple      edge difference with adjustable threshold.
srm         statistical region merging.
Regions below a given cutoff size are merged.
Only the first sub-image is segmented.
</pre> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>R. Nock, F. Nielsen: Statistical Region Merging. IEEE Trans. Pattern Anal. Mach. Intell. 26(11): 1452-1458 (2004) </dd></dl>

</div>
</div>
<a id="a51056d0e235ae01a7ed58427a1c204ef" name="a51056d0e235ae01a7ed58427a1c204ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51056d0e235ae01a7ed58427a1c204ef">&#9670;&nbsp;</a></span>graph_segments_to_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::graph_segments_to_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_sgraph.html">GSgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converting a graph-based segmentation to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>graph segmentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* segmented image. </dd></dl>

</div>
</div>
<a id="aca8566ad6dc2ec1f6545904b0be3b463" name="aca8566ad6dc2ec1f6545904b0be3b463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8566ad6dc2ec1f6545904b0be3b463">&#9670;&nbsp;</a></span>graph_segments_to_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::graph_segments_to_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_sgraph.html">GSgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converting a graph-based segmentation to a multi-level mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>graph segmentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* segmented image. </dd></dl>

</div>
</div>
<a id="a092cc4d52f3a396c699f83dcbd4a2ad4" name="a092cc4d52f3a396c699f83dcbd4a2ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092cc4d52f3a396c699f83dcbd4a2ad4">&#9670;&nbsp;</a></span>graph_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_sgraph.html">GSgraph</a> Bimage::graph_setup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connect_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializing voxels and edges for graph-based segmentation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connect_type</td><td>connection type: 0=direct neighbors, 1=all neighbors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_g_sgraph.html" title="Graph segmentation container.">GSgraph</a> graph with segment designations. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>R. Nock, F. Nielsen: Statistical Region Merging. IEEE Trans. Pattern Anal. Mach. Intell. 26(11): 1452-1458 (2004)</dd></dl>
<p>Edges are set up with 6 or 26 neighbors. </p>

</div>
</div>
<a id="a9d6a9ea88106962dc7045dc5d21437e2" name="a9d6a9ea88106962dc7045dc5d21437e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6a9ea88106962dc7045dc5d21437e2">&#9670;&nbsp;</a></span>guess_compoundtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a> Bimage::guess_compoundtype </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89fe20c911fb2f64e13e285720a6f37c" name="a89fe20c911fb2f64e13e285720a6f37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fe20c911fb2f64e13e285720a6f37c">&#9670;&nbsp;</a></span>hanning_taper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::hanning_taper </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply Hanning taper window to the image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fill</td><td>value of edge voxels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">Along each dimension, the image is multiplied with a function:
    v_new(i) = fill + ( v_old(i) - fill )* 0.5 * ( 1 - cos( 2*PI*i/(n-1) )) i=0,...,n-1
where   fill is the desired edge value.
        n is the size of the image
</pre> </dd></dl>

</div>
</div>
<a id="a53f0e717f7eb6d7cbe3282a752872ca3" name="a53f0e717f7eb6d7cbe3282a752872ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f0e717f7eb6d7cbe3282a752872ca3">&#9670;&nbsp;</a></span>height()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::height </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a> *&#160;</td>
          <td class="paramname"><em>views</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a set of height images from a 3D density map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*views</td><td>linked list of views. </td></tr>
    <tr><td class="paramname">threshold</td><td>density threshold to consider as object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* 2D height images as sub-images. <pre class="fragment">A set of height images is calculated according to a list of views.
</pre> </dd></dl>

</div>
</div>
<a id="a7ce50ec5b49ecf11d7dca124c6a85b90" name="a7ce50ec5b49ecf11d7dca124c6a85b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce50ec5b49ecf11d7dca124c6a85b90">&#9670;&nbsp;</a></span>helical_cross_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::helical_cross_section </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>helix_rise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>helix_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a helical cross section from line transforms of a filament. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">helix_rise</td><td>helical subunit rise in angstrom. </td></tr>
    <tr><td class="paramname">helix_angle</td><td>helical subunit rotation in radians. </td></tr>
    <tr><td class="paramname">scale</td><td>scale of cross section. </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* 2D cross section image. <pre class="fragment">The filament image must be oriented with the helical axis coinciding with 
the y axis. Each row of pixels is transformed and written into a
2D transform based on an orientation calculated from given helical
parameters.
</pre> </dd></dl>

</div>
</div>
<a id="acf2838d721c0aacfa1d4368509813bb1" name="acf2838d721c0aacfa1d4368509813bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2838d721c0aacfa1d4368509813bb1">&#9670;&nbsp;</a></span>helix_interpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::helix_interpolate </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>helix_rise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>helix_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_flag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6080c797d3cb69253b985303271e080e" name="a6080c797d3cb69253b985303271e080e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6080c797d3cb69253b985303271e080e">&#9670;&nbsp;</a></span>helix_segment_correlation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::helix_segment_correlation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the correlation over rotation angles between helical segments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thickness</td><td>segment thickness. </td></tr>
    <tr><td class="paramname">angle_start</td><td>start value for angle. </td></tr>
    <tr><td class="paramname">angle_end</td><td>end value for angle. </td></tr>
    <tr><td class="paramname">angle_step</td><td>step size for angle. </td></tr>
    <tr><td class="paramname">bin</td><td>bin image for faster searching (limited to 1,2,3). </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit in angstroms. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit in angstroms. </td></tr>
    <tr><td class="paramname">radius</td><td>radius for mask (voxels). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bplot* plot with coefficients over all rotations results. <pre class="fragment">The image is split up into segments in the z direction. Every adjacent pair
of segments are cross-correlated over an angular range to find the best
rotation. The cross-correlation can be resolution-limited. The image may
also be masked beyond a radius and binned to speed up execution.
</pre> </dd></dl>

</div>
</div>
<a id="a2a9eb9c30f80919647fbcd1626f5c611" name="a2a9eb9c30f80919647fbcd1626f5c611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9eb9c30f80919647fbcd1626f5c611">&#9670;&nbsp;</a></span>helix_segment_correlation_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::helix_segment_correlation_one </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a006beeeff826f2c0cc1842f9b0a68ff2" name="a006beeeff826f2c0cc1842f9b0a68ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006beeeff826f2c0cc1842f9b0a68ff2">&#9670;&nbsp;</a></span>helix_symmetrize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::helix_symmetrize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>helix_rise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>helix_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dyad_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_flag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrizes an image given helical symmetry parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">helix_rise</td><td>rise per asymmetric unit (angstrom). </td></tr>
    <tr><td class="paramname">helix_angle</td><td>rotation angle per asymmetric unit (radians). </td></tr>
    <tr><td class="paramname">dyad_axis</td><td>dyad axis indicator: 2=dyad axis on x-axis, otherwise none. </td></tr>
    <tr><td class="paramname">zmin</td><td>mimimum z slice to include. </td></tr>
    <tr><td class="paramname">zmax</td><td>maximum z slice to include. </td></tr>
    <tr><td class="paramname">radius</td><td>radius to do symmetrizing over (pixels). </td></tr>
    <tr><td class="paramname">norm_flag</td><td>if 1, normalize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double R factor. <pre class="fragment">The data between the z limits are replicated along the helical axis
according to the helical rise and rotation to fill the new volume.
</pre> </dd></dl>

</div>
</div>
<a id="a6bde5665ebee734c283db7db9c99b74f" name="a6bde5665ebee734c283db7db9c99b74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bde5665ebee734c283db7db9c99b74f">&#9670;&nbsp;</a></span>histogram() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::histogram </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the histogram of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bins</td><td>number of bins in the histogram. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bplot* 0. <pre class="fragment">A histogram of an image is calculated with a given number of bins.
Multiple channels are output as successive one-dimensional arrays.
The image data is not affected.
The statistics for the input image must be correctly calculated.
If the postscript file name is given, a postscript plot is produced.
</pre> </dd></dl>

</div>
</div>
<a id="ab85f1d0fdde7701db60b1b62833ffefd" name="ab85f1d0fdde7701db60b1b62833ffefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85f1d0fdde7701db60b1b62833ffefd">&#9670;&nbsp;</a></span>histogram() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; long &gt; Bimage::histogram </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the histogram of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bins</td><td>number of bins in the histogram. </td></tr>
    <tr><td class="paramname">&amp;scale</td><td>scale. </td></tr>
    <tr><td class="paramname">&amp;offset</td><td>offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;long&gt; histogram. <pre class="fragment">A histogram of an image is calculated with a given number of bins.
Multiple channels are output as successive one-dimensional arrays.
The image data is not affected.
The statistics for the input image must be correctly calculated.
</pre> </dd></dl>

</div>
</div>
<a id="aa2eff813946f4af3af738ae4bfd4f0b9" name="aa2eff813946f4af3af738ae4bfd4f0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2eff813946f4af3af738ae4bfd4f0b9">&#9670;&nbsp;</a></span>histogram_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::histogram_counts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the peaks in a quantized image from the histogram. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>1=plot, 2=convert image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bplot* plot of fits. <pre class="fragment">A histogram of an image with quantized data is calculated.
The peaks are determined and the image converted.
</pre> </dd></dl>

</div>
</div>
<a id="a6d0ea79752667dd909d5becad0eec7ae" name="a6d0ea79752667dd909d5becad0eec7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0ea79752667dd909d5becad0eec7ae">&#9670;&nbsp;</a></span>histogram_gauss_fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; Bimage::histogram_gauss_fit </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ngauss</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fits a gaussian function to a histogram of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bins</td><td>number of bins in the histogram. </td></tr>
    <tr><td class="paramname">ngauss</td><td>number of gaussians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt; array with 3 values for each gaussian. <pre class="fragment">A histogram of an image is calculated with a given number of bins.
The return has (in order) the gaussian amplitude, the offset, and the sigma value.
</pre> </dd></dl>

</div>
</div>
<a id="aacf99ed74e096630cc1d98601ae73d6b" name="aacf99ed74e096630cc1d98601ae73d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf99ed74e096630cc1d98601ae73d6b">&#9670;&nbsp;</a></span>histogram_gauss_fit2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; Bimage::histogram_gauss_fit2 </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ngauss</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3183f34921b1302daac2ef214bd0fbf" name="ae3183f34921b1302daac2ef214bd0fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3183f34921b1302daac2ef214bd0fbf">&#9670;&nbsp;</a></span>histogram_gauss_plot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::histogram_gauss_plot </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ngauss</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fits a gaussian function to a histogram of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bins</td><td>number of bins in the histogram. </td></tr>
    <tr><td class="paramname">ngauss</td><td>number of gaussians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bplot* plot of the histogram and the gaussian fit. <pre class="fragment">A histogram of an image is calculated with a given number of bins.
</pre> </dd></dl>

</div>
</div>
<a id="aad7b63e6c18d1efbd0e152a9d88aaa47" name="aad7b63e6c18d1efbd0e152a9d88aaa47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7b63e6c18d1efbd0e152a9d88aaa47">&#9670;&nbsp;</a></span>histogram_minmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::histogram_minmax </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>tmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>tmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates minimum and maximum thresholds for truncation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;tmin</td><td>minumum threshold. </td></tr>
    <tr><td class="paramname">&amp;tmax</td><td>maxumum threshold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">A histogram of an image is calculated.  The first minimum in the first
quarter of the histogram and the last minimum in the last quarter
are taken to define the small and large outliers.
</pre> </dd></dl>

</div>
</div>
<a id="a24ee47d4e71e12e5d0572b3d57dbc048" name="a24ee47d4e71e12e5d0572b3d57dbc048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ee47d4e71e12e5d0572b3d57dbc048">&#9670;&nbsp;</a></span>histogram_multi_thresholds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; Bimage::histogram_multi_thresholds </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates multiple thresholds from a histogram. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bins</td><td>number bins in histogram. </td></tr>
    <tr><td class="paramname">number</td><td>number of clusters (one more than thresholds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt; thresholds. <pre class="fragment">Reference: PS.Liao, TS.Chen, and PC. Chung,
       Journal of Information Science and Engineering, vol 17, 713-727 (2001)
</pre> </dd></dl>

</div>
</div>
<a id="a17118ec3a626445c87adb236a8fd69ca" name="a17118ec3a626445c87adb236a8fd69ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17118ec3a626445c87adb236a8fd69ca">&#9670;&nbsp;</a></span>histogram_otsu_variance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::histogram_otsu_variance </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the inter-set variance of the bisection of a historgram using the method of Otsu. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bins</td><td>number bins in histogram. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double threshold. <pre class="fragment">Reference: NOBUYUKI OTSU, IEEE TRANSACTIONS ON SYSTEMS, MAN, AND CYBERNETICS, VOL. SMC-9, NO. 1, JANUARY 1979
</pre> </dd></dl>

</div>
</div>
<a id="a1ab66dfa88e4a41d2c23d6ce3dc50b1e" name="a1ab66dfa88e4a41d2c23d6ce3dc50b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab66dfa88e4a41d2c23d6ce3dc50b1e">&#9670;&nbsp;</a></span>histogram_poisson_fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::histogram_poisson_fit </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fits a poisson function to a histogram of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bins</td><td>number of bins in the histogram. </td></tr>
    <tr><td class="paramname">flag</td><td>1=plot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bplot* plot of the histogram and the poisson fit. <pre class="fragment">A histogram of an image is calculated with a given number of bins.
The histogram is fit to the Poisson function:
               lambda * exp(-lambda)
    f(x) = Amp ---------------------
                        x!
by first converting it to a linear form:
    ln(f(x)) = ln(Amp) + x*ln(lambda) - lambda - lgamma(x+1)
and then using the downhill simplex method to find the solution.
</pre> </dd></dl>

</div>
</div>
<a id="a6a5b897839510f5387f40489d9465941" name="a6a5b897839510f5387f40489d9465941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5b897839510f5387f40489d9465941">&#9670;&nbsp;</a></span>histomatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::histomatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fits two images by matching the histogram of the second to the first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
    <tr><td class="paramname">bins</td><td>number of bins in the histograms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 if error. <pre class="fragment">Both images are converted to floating point.
</pre> </dd></dl>

</div>
</div>
<a id="a41ac44ea27081b2cd7b3ccae2de8a082" name="a41ac44ea27081b2cd7b3ccae2de8a082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ac44ea27081b2cd7b3ccae2de8a082">&#9670;&nbsp;</a></span>identifier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bstring.html">Bstring</a> &amp; Bimage::identifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7bdc9cb92f3deebd4cd66188048fea6" name="ab7bdc9cb92f3deebd4cd66188048fea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bdc9cb92f3deebd4cd66188048fea6">&#9670;&nbsp;</a></span>identifier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::identifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a273fc6371ef29fae7e1150552334b262" name="a273fc6371ef29fae7e1150552334b262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273fc6371ef29fae7e1150552334b262">&#9670;&nbsp;</a></span>image_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::image_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5f3b612ae93528dca78ca1641e1f2b6" name="ac5f3b612ae93528dca78ca1641e1f2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f3b612ae93528dca78ca1641e1f2b6">&#9670;&nbsp;</a></span>images() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::images </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb76d8399487a3d520985726e25ae3a0" name="aeb76d8399487a3d520985726e25ae3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb76d8399487a3d520985726e25ae3a0">&#9670;&nbsp;</a></span>images() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::images </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb066a1d47146efdaf38df32adb0574a" name="acb066a1d47146efdaf38df32adb0574a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb066a1d47146efdaf38df32adb0574a">&#9670;&nbsp;</a></span>images_to_channels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::images_to_channels </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utilities_8h.html#a768a6f0a6fd7e9087ff7971abbcc3f36">CompoundType</a>&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a678987573053e7625c499abc35a7e817" name="a678987573053e7625c499abc35a7e817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678987573053e7625c499abc35a7e817">&#9670;&nbsp;</a></span>images_to_slices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::images_to_slices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the 2D images to slices in a 3D image. </p>
<dl class="section return"><dt>Returns</dt><dd>int error code (&lt;0 means failure). </dd></dl>

</div>
</div>
<a id="ae3d5f0fe96415e7d334ab657393b7f21" name="ae3d5f0fe96415e7d334ab657393b7f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d5f0fe96415e7d334ab657393b7f21">&#9670;&nbsp;</a></span>impose_superpixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::impose_superpixels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_bsuperpixel.html">Bsuperpixel</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>impose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose superpixel features onto an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>mask defining superpixels. </td></tr>
    <tr><td class="paramname">seg</td><td>array of superpixels. </td></tr>
    <tr><td class="paramname">impose</td><td>flag to select feature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 . <pre class="fragment">Features to select:
0   none
1   segment average
2   lowest neighboring segment
3   difference from lowest neighbor
4   higest neigboring segment
5   difference from highest neighbor
</pre> </dd></dl>

</div>
</div>
<a id="aa40279a9386d8c571cf573ec7f2c328f" name="aa40279a9386d8c571cf573ec7f2c328f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40279a9386d8c571cf573ec7f2c328f">&#9670;&nbsp;</a></span>index() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::index </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a760143d3cb8fd5d6e1245ecd215821a2" name="a760143d3cb8fd5d6e1245ecd215821a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760143d3cb8fd5d6e1245ecd215821a2">&#9670;&nbsp;</a></span>index() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::index </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ny</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ce1e553efbc68da56f446626a005142" name="a3ce1e553efbc68da56f446626a005142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce1e553efbc68da56f446626a005142">&#9670;&nbsp;</a></span>index() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::index </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6114a3346ee83eed50e799fd887c1302" name="a6114a3346ee83eed50e799fd887c1302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6114a3346ee83eed50e799fd887c1302">&#9670;&nbsp;</a></span>index() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::index </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83754238aa74181ac04e7effd55b1e5f" name="a83754238aa74181ac04e7effd55b1e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83754238aa74181ac04e7effd55b1e5f">&#9670;&nbsp;</a></span>index() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>vox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed40effbf49e57048e306d2df8f24177" name="aed40effbf49e57048e306d2df8f24177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed40effbf49e57048e306d2df8f24177">&#9670;&nbsp;</a></span>index() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::index </td>
          <td>(</td>
          <td class="paramtype">vector&lt; long &gt;&#160;</td>
          <td class="paramname"><em>vox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd88814c41f2c26ecdfef9febc8c1b42" name="abd88814c41f2c26ecdfef9febc8c1b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd88814c41f2c26ecdfef9febc8c1b42">&#9670;&nbsp;</a></span>index_wrap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::index_wrap </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44270f08caaa5aced16a390e07cc34d3" name="a44270f08caaa5aced16a390e07cc34d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44270f08caaa5aced16a390e07cc34d3">&#9670;&nbsp;</a></span>index_wrap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::index_wrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>coor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b5df5f5d1d2702085b6f2cc958fb5e8" name="a9b5df5f5d1d2702085b6f2cc958fb5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5df5f5d1d2702085b6f2cc958fb5e8">&#9670;&nbsp;</a></span>index_wrap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::index_wrap </td>
          <td>(</td>
          <td class="paramtype">vector&lt; long &gt;&#160;</td>
          <td class="paramname"><em>coor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad034e4aef862674587ca3e5f83d50a06" name="ad034e4aef862674587ca3e5f83d50a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad034e4aef862674587ca3e5f83d50a06">&#9670;&nbsp;</a></span>information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::information </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints out header information for an image. </p>
<dl class="section return"><dt>Returns</dt><dd>int error code (&lt;0 means failure). </dd></dl>

</div>
</div>
<a id="a42bc0d2d19d1c538cd9680c101d9a780" name="a42bc0d2d19d1c538cd9680c101d9a780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bc0d2d19d1c538cd9680c101d9a780">&#9670;&nbsp;</a></span>integer_interpolation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::integer_interpolation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>integer_factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a671612e813fa45a25abde953884831cc" name="a671612e813fa45a25abde953884831cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671612e813fa45a25abde953884831cc">&#9670;&nbsp;</a></span>integer_interpolation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::integer_interpolation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>integer_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>odd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates by an integer scale with a density-preserving overlapping kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">integer_factor</td><td>integer interpolation factor. </td></tr>
    <tr><td class="paramname">odd</td><td>flag to ensure the dimensions are odd. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">An image is interpolated by integer scaling (i.e., 2, 3, 4-fold or 
more) sometimes referred to as a form of binning.  A kernel is used
such that it overlaps with its neighbouring positions.  Voxels where
neighbouring kernel positions overlap contribute to 2, 4 or 8 new
voxels based on the number of overlapping kernel positions.  Only
the central voxel is unique to a kernel position.  The kernel is 
calculated as:
    w(i,j,k) = (1/s^2n)*(s-|s-1-i|)*(s-|s-1-j|)*(s-|s-1-k|)
where   s is the integer interpolation factor.
        n is the number of dimensions (1D, 2D or 3D).
The flag determines whether the dimensions are forced to be even or odd:
    0       No forcing
    1       x odd
    2       x even
    4       y odd
    8       y even
    16      z odd
    32      z even
    21      all odd
    42      all even
and any other combination.
</pre> </dd></dl>

</div>
</div>
<a id="aa7b16ff07227b448151d6b73c572451a" name="aa7b16ff07227b448151d6b73c572451a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b16ff07227b448151d6b73c572451a">&#9670;&nbsp;</a></span>intensities_phase_colored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::intensities_phase_colored </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a power spectrum with phases colored according to a color wheel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>amplitude scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* color power spectrum. <pre class="fragment">A polar data type image (such as a Fourier transform) is converted
to indicate the phases as colors. The primary colors are located
0 degrees (red), 120 degrees (green) and -120 degrees (blue). All
three color values are down-weighted based on the amplitude. The
weighting is calculated as:
    weight = amplitude/(average+2*standard_deviation)
The origin specified in the image is used to shift the phases.
The scale is multiplied with the amplitude and cut off at one
to give the user the ability to enhance the image.
Default:
    scale = 1/(average_amplitude + standard_deviation_of_amplitude) 
</pre> </dd></dl>

</div>
</div>
<a id="a1514d68d5b4b97a826bca033250c4926" name="a1514d68d5b4b97a826bca033250c4926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1514d68d5b4b97a826bca033250c4926">&#9670;&nbsp;</a></span>internal_volume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::internal_volume </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the internal volume of a shell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>threshold to define density. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* internal volume mask. </dd></dl>

</div>
</div>
<a id="a42d2caa457d42a0e1991e63ac4dcf82a" name="a42d2caa457d42a0e1991e63ac4dcf82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d2caa457d42a0e1991e63ac4dcf82a">&#9670;&nbsp;</a></span>internal_volume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::internal_volume </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask_out_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the internal volume of a shell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>threshold to define density. </td></tr>
    <tr><td class="paramname">mask_out_freq</td><td>mask output frequency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* internal volume mask. </dd></dl>

</div>
</div>
<a id="a846421e8a35109bb1f20dbe772ccc677" name="a846421e8a35109bb1f20dbe772ccc677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846421e8a35109bb1f20dbe772ccc677">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::interpolate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zz</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42ed6903b8c8e716f55c8bd7d884c9b0" name="a42ed6903b8c8e716f55c8bd7d884c9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ed6903b8c8e716f55c8bd7d884c9b0">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::interpolate </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zz</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates using a given location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>channel. </td></tr>
    <tr><td class="paramname">xx</td><td>x location. </td></tr>
    <tr><td class="paramname">yy</td><td>y location. </td></tr>
    <tr><td class="paramname">zz</td><td>z location. </td></tr>
    <tr><td class="paramname">nn</td><td>image number. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value if outside boundaries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double interpolated value. <pre class="fragment">Trilinear interpolation.
</pre> </dd></dl>

</div>
</div>
<a id="a3fb5f320d3082349fa4706966eb1af6c" name="a3fb5f320d3082349fa4706966eb1af6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb5f320d3082349fa4706966eb1af6c">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::interpolate </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2f7ba2720f2852ee89d471b885f03cb" name="aa2f7ba2720f2852ee89d471b885f03cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f7ba2720f2852ee89d471b885f03cb">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bdece81eeb52253229885c3911d4316" name="a5bdece81eeb52253229885c3911d4316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdece81eeb52253229885c3911d4316">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::interpolate </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7885caeffe8b1c90eaf9651fd575d749" name="a7885caeffe8b1c90eaf9651fd575d749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7885caeffe8b1c90eaf9651fd575d749">&#9670;&nbsp;</a></span>interpolate_gaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::interpolate_gaps </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>step</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate the voxels that are not calculated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>step increment for voxels with proper values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 if error. <pre class="fragment">Sparse voxels calculated on a regular grid with the given step size are 
used to fill intermediate voxels with linearly interpolated values.
</pre> </dd></dl>

</div>
</div>
<a id="a08401d5d8da91205f95925898575903b" name="a08401d5d8da91205f95925898575903b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08401d5d8da91205f95925898575903b">&#9670;&nbsp;</a></span>interpolate_wrap() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::interpolate_wrap </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zz</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af23dc8034036c8ac619601259ead7444" name="af23dc8034036c8ac619601259ead7444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23dc8034036c8ac619601259ead7444">&#9670;&nbsp;</a></span>interpolate_wrap() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::interpolate_wrap </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zz</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates using a given location with wrapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>channel. </td></tr>
    <tr><td class="paramname">xx</td><td>x location. </td></tr>
    <tr><td class="paramname">yy</td><td>y location. </td></tr>
    <tr><td class="paramname">zz</td><td>z location. </td></tr>
    <tr><td class="paramname">nn</td><td>image number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double interpolated value. <pre class="fragment">Trilinear interpolation with wrapping around periodic image boundaries.
</pre> </dd></dl>

</div>
</div>
<a id="accbcd90dfa5c60b281ab2efb975f2d38" name="accbcd90dfa5c60b281ab2efb975f2d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbcd90dfa5c60b281ab2efb975f2d38">&#9670;&nbsp;</a></span>interpolate_wrap() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::interpolate_wrap </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa621195acbabd5c81c769d0ca17e9041" name="aa621195acbabd5c81c769d0ca17e9041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa621195acbabd5c81c769d0ca17e9041">&#9670;&nbsp;</a></span>interpolate_wrap() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::interpolate_wrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75e17a1198d60941bc2a64a563d99622" name="a75e17a1198d60941bc2a64a563d99622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e17a1198d60941bc2a64a563d99622">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::inverse </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minval</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the inverse of the image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minval</td><td>the minimum absolute value considered not zero. <pre class="fragment">The inverse of every pixel is calculated.
If the minumum value is given as zero, zero pixels are retained.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59438cff519b5ec327b7ef909e761984" name="a59438cff519b5ec327b7ef909e761984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59438cff519b5ec327b7ef909e761984">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts the data in the image. </p>
<pre class="fragment">The Bit data type is negated.
An unsigned data type is subtracted from its type maximum.
A signed data type is negated.
</pre> 
</div>
</div>
<a id="a32603276232d08670b1f5f119d2b2614" name="a32603276232d08670b1f5f119d2b2614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32603276232d08670b1f5f119d2b2614">&#9670;&nbsp;</a></span>kernel_average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::kernel_average </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the highest value in a kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>index in multi-image. </td></tr>
    <tr><td class="paramname">ksize</td><td>kernel edge half size. </td></tr>
    <tr><td class="paramname">tmin</td><td>miminum to exclude. </td></tr>
    <tr><td class="paramname">tmax</td><td>maximum to exclude </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double average value. </dd></dl>

</div>
</div>
<a id="ae44123b34d0f20e1835482d0a0fe8f86" name="ae44123b34d0f20e1835482d0a0fe8f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44123b34d0f20e1835482d0a0fe8f86">&#9670;&nbsp;</a></span>kernel_gaussian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::kernel_gaussian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a gaussian kernel image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigma</td><td>gaussian width. </td></tr>
    <tr><td class="paramname">max</td><td>kernel maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="afda84951be659557e7466205b3fc7083" name="afda84951be659557e7466205b3fc7083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda84951be659557e7466205b3fc7083">&#9670;&nbsp;</a></span>kernel_high() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; Bimage::kernel_high </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a5b6325e3f6000b183f0fd3e7ae45eb" name="a6a5b6325e3f6000b183f0fd3e7ae45eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5b6325e3f6000b183f0fd3e7ae45eb">&#9670;&nbsp;</a></span>kernel_high() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; Bimage::kernel_high </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a90d4551d4e5fca005dffca66707ac232" name="a90d4551d4e5fca005dffca66707ac232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d4551d4e5fca005dffca66707ac232">&#9670;&nbsp;</a></span>kernel_laplacian_of_gaussian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::kernel_laplacian_of_gaussian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a laplacian-of-gaussian kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigma</td><td>gaussian width. </td></tr>
    <tr><td class="paramname">max</td><td>kernel maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* kernel image. </dd></dl>

</div>
</div>
<a id="acc5f4b1aec37e466c44649fe8bd3c573" name="acc5f4b1aec37e466c44649fe8bd3c573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5f4b1aec37e466c44649fe8bd3c573">&#9670;&nbsp;</a></span>kernel_low() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; Bimage::kernel_low </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac41728de6a18ce9515cd35d4b15093d7" name="ac41728de6a18ce9515cd35d4b15093d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41728de6a18ce9515cd35d4b15093d7">&#9670;&nbsp;</a></span>kernel_low() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; Bimage::kernel_low </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f902f05afe1d97fd1e90a25aecc4532" name="a8f902f05afe1d97fd1e90a25aecc4532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f902f05afe1d97fd1e90a25aecc4532">&#9670;&nbsp;</a></span>kernel_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::kernel_max </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the highest value in a kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>index in multi-image. </td></tr>
    <tr><td class="paramname">ksize</td><td>kernel edge half size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long index of highest value. </dd></dl>

</div>
</div>
<a id="acc44e2b417abe30a685105ab38662a77" name="acc44e2b417abe30a685105ab38662a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc44e2b417abe30a685105ab38662a77">&#9670;&nbsp;</a></span>kernel_max_neigbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::kernel_max_neigbor </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the highest value in a kernel excluding the central voxel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>index in multi-image. </td></tr>
    <tr><td class="paramname">ksize</td><td>kernel edge half size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long index of highest value. </dd></dl>

</div>
</div>
<a id="ae2082eb0532625c9807b85c1052921c6" name="ae2082eb0532625c9807b85c1052921c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2082eb0532625c9807b85c1052921c6">&#9670;&nbsp;</a></span>kernel_max_wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::kernel_max_wrap </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the highest value in a kernel with wrapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>index in multi-image. </td></tr>
    <tr><td class="paramname">ksize</td><td>kernel edge half size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long index of highest value. </dd></dl>

</div>
</div>
<a id="a8b90b99ccc3c50f979020d2f8cf5fb97" name="a8b90b99ccc3c50f979020d2f8cf5fb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b90b99ccc3c50f979020d2f8cf5fb97">&#9670;&nbsp;</a></span>kernel_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::kernel_min </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the highest value in a kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>index in multi-image. </td></tr>
    <tr><td class="paramname">ksize</td><td>kernel edge half size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long index of highest value. </dd></dl>

</div>
</div>
<a id="aa07e31eaeb062dd119fd4cfbced83ad7" name="aa07e31eaeb062dd119fd4cfbced83ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07e31eaeb062dd119fd4cfbced83ad7">&#9670;&nbsp;</a></span>kernel_neighbor_average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::kernel_neighbor_average </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the highest value in a kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>index in multi-image. </td></tr>
    <tr><td class="paramname">ksize</td><td>kernel edge half size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double average value. </dd></dl>

</div>
</div>
<a id="aca34b56eec25e8568c1264ec3c1b2234" name="aca34b56eec25e8568c1264ec3c1b2234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca34b56eec25e8568c1264ec3c1b2234">&#9670;&nbsp;</a></span>kernel_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">multimap&lt; double, long &gt; Bimage::kernel_order </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orders the values in a kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>index in multi-image. </td></tr>
    <tr><td class="paramname">ksize</td><td>kernel edge half size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>multimap&lt;double,long&gt; index of highest value. </dd></dl>

</div>
</div>
<a id="a6517dc1d9d1234580ff7de7cba084325" name="a6517dc1d9d1234580ff7de7cba084325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6517dc1d9d1234580ff7de7cba084325">&#9670;&nbsp;</a></span>kernel_order_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">multimap&lt; double, long &gt; Bimage::kernel_order_neighbors </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orders the neigbor values in a kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>index in multi-image. </td></tr>
    <tr><td class="paramname">ksize</td><td>kernel edge half size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>multimap&lt;double,long&gt; index of highest value. </dd></dl>

</div>
</div>
<a id="ae3805a269db97bedf75fea6100a28a09" name="ae3805a269db97bedf75fea6100a28a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3805a269db97bedf75fea6100a28a09">&#9670;&nbsp;</a></span>kmeans_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::kmeans_segment </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nregion</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ratio</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segments an image based on K-means. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nregion</td><td>number of regions. </td></tr>
    <tr><td class="paramname">max_iter</td><td>maximum number of iterations. </td></tr>
    <tr><td class="paramname">ratio</td><td>balance between density and distance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* segmentation mask. <pre class="fragment">The metric to choose region membership is based on the minimum of:
    d = |&lt;c&gt;-c|/s + r|&lt;v&gt;-v|
for:
    c:      coordinates
    &lt;c&gt;:    region average coordinates.
    s:      image size.
    v:      density.
    &lt;v&gt;:    region average density.
    r:      ratio.
</pre> </dd></dl>

</div>
</div>
<a id="afe834cee6404653d7cce3ba2dd3783a4" name="afe834cee6404653d7cce3ba2dd3783a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe834cee6404653d7cce3ba2dd3783a4">&#9670;&nbsp;</a></span>label() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string &amp; Bimage::label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aafe7685945a1b8b18efa7e8759fd8b02" name="aafe7685945a1b8b18efa7e8759fd8b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe7685945a1b8b18efa7e8759fd8b02">&#9670;&nbsp;</a></span>label() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::label </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee6dd952940fd6084b5e8a4674e708b2" name="aee6dd952940fd6084b5e8a4674e708b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6dd952940fd6084b5e8a4674e708b2">&#9670;&nbsp;</a></span>largest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::largest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the largest of each pixel from two images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>other image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8266d26a479d99b845c7125e4efab7f1" name="a8266d26a479d99b845c7125e4efab7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8266d26a479d99b845c7125e4efab7f1">&#9670;&nbsp;</a></span>level_mask_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::level_mask_extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts all the regions associated with a multi-level mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>multi-level mask map. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>value of edge voxels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* image with excised regions. <pre class="fragment">The feature index is found in a feature map and the corresponding voxels
in the density maps are extracted.
</pre> </dd></dl>

</div>
</div>
<a id="ad6e31bfb7410474d13a52648e8d6a3c8" name="ad6e31bfb7410474d13a52648e8d6a3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e31bfb7410474d13a52648e8d6a3c8">&#9670;&nbsp;</a></span>level_masked_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::level_masked_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Caclulates statistics for all the regions defined by a multi-level mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>multi-level mask map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The input data is replaced by the average for each region.
A linked image is created to hold the variance for each region.
</pre> </dd></dl>

</div>
</div>
<a id="a7bc85fb79cd16369c7fa58ee7cb9a8c4" name="a7bc85fb79cd16369c7fa58ee7cb9a8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc85fb79cd16369c7fa58ee7cb9a8c4">&#9670;&nbsp;</a></span>levelmask_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::levelmask_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>add_level</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bilevel mask to a level mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmask</td><td>bilevel mask to add. </td></tr>
    <tr><td class="paramname">add_level</td><td>the level index to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of selected regions. <pre class="fragment">Where the bilevel mask is one, the level mask is set to given level value.
</pre> </dd></dl>

</div>
</div>
<a id="adc844206e18c734ce3dc13bf775754b0" name="adc844206e18c734ce3dc13bf775754b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc844206e18c734ce3dc13bf775754b0">&#9670;&nbsp;</a></span>levelmask_asymmetric_units()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::levelmask_asymmetric_units </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a multi-level mask to indicate asymmetric units. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*sym</td><td>symmetry structure. </td></tr>
    <tr><td class="paramname">index</td><td>asu index (&lt;1 means all). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* multi-level mask. <pre class="fragment">A reference view for each point group is generated such that it is
located close to the center of the canonical asymmetric unit.
A set of symmetry-related reference views are then generated from 
the original reference.
The distance of each voxel is then calculated to each reference
view, and assigned to asymmetric unit with the closest reference view.
If the given index is larger than one, a mask is generated only for the
asymmetric unit with that index. 
</pre> </dd></dl>

</div>
</div>
<a id="aa1a2be8e3d04b368f3bfd57256809719" name="aa1a2be8e3d04b368f3bfd57256809719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a2be8e3d04b368f3bfd57256809719">&#9670;&nbsp;</a></span>levelmask_average_region_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::levelmask_average_region_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the average size of regions in a level mask. </p>
<dl class="section return"><dt>Returns</dt><dd>double average feature size. </dd></dl>

</div>
</div>
<a id="af17d6f37ff5cbbdcde7620f05141678e" name="af17d6f37ff5cbbdcde7620f05141678e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17d6f37ff5cbbdcde7620f05141678e">&#9670;&nbsp;</a></span>levelmask_clean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::levelmask_clean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes empty levels from a multi-level mask. </p>
<dl class="section return"><dt>Returns</dt><dd>long 0. <pre class="fragment">The mask is converted to an integer mask.
</pre> </dd></dl>

</div>
</div>
<a id="a9b050b7abd5bbe9ba1b22ea6f6c55c22" name="a9b050b7abd5bbe9ba1b22ea6f6c55c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b050b7abd5bbe9ba1b22ea6f6c55c22">&#9670;&nbsp;</a></span>levelmask_collapse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::levelmask_collapse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapse a multi-level mask to a binary mask. </p>
<dl class="section return"><dt>Returns</dt><dd>long number of voxels retained. <pre class="fragment">All non-zero segments are converted to ones.
</pre> </dd></dl>

</div>
</div>
<a id="a001d55537c8ef53c9a8db4e4db51550b" name="a001d55537c8ef53c9a8db4e4db51550b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001d55537c8ef53c9a8db4e4db51550b">&#9670;&nbsp;</a></span>levelmask_color_by_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::levelmask_color_by_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Color a multi-level mask based on the volumes of regions. </p>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new colored image. </dd></dl>

</div>
</div>
<a id="a86476781a80154c519dd0ddf5962ec43" name="a86476781a80154c519dd0ddf5962ec43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86476781a80154c519dd0ddf5962ec43">&#9670;&nbsp;</a></span>levelmask_colorize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::levelmask_colorize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Colorizes a multi-level mask with random color assignments. </p>
<dl class="section return"><dt>Returns</dt><dd>long number of levels. <pre class="fragment">A lookup table (LUT) is calculated for the range of gray-scale values
and random colors assigned to each value.
The image is then converted to RGB using the LUT.
</pre> </dd></dl>

</div>
</div>
<a id="ad7f3b28f7dcabcf950bed87b5c43fe68" name="ad7f3b28f7dcabcf950bed87b5c43fe68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f3b28f7dcabcf950bed87b5c43fe68">&#9670;&nbsp;</a></span>levelmask_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::levelmask_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a> &amp;&#160;</td>
          <td class="paramname"><em>select_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines the selected levels in a multi-level mask and renumber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;select_list</td><td>comma_separated list of levels to select. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of voxels retained. <pre class="fragment">The new data replaces the old data.
The result is a multi-level mask where the selected levels are combined into one.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="abfa93c8bce1563c143cbc32bd8c024c3" name="abfa93c8bce1563c143cbc32bd8c024c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa93c8bce1563c143cbc32bd8c024c3">&#9670;&nbsp;</a></span>levelmask_dilate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::levelmask_dilate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dilates a level mask. </p>
<dl class="section return"><dt>Returns</dt><dd>long 0. <pre class="fragment">Traditional 3^dim kernel dilation.  Any pixel with a value of 1 turns 
all of its neighbors to a value of 1.
</pre> </dd></dl>

</div>
</div>
<a id="a3b8f8a71d29892880177dba00493a97b" name="a3b8f8a71d29892880177dba00493a97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8f8a71d29892880177dba00493a97b">&#9670;&nbsp;</a></span>levelmask_dilate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::levelmask_dilate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>times</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dilates a level mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">times</td><td>number of dilation operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long 0. <pre class="fragment">Traditional 3^dim kernel dilation.  Any pixel with a value of 1 turns 
all of its neighbors to a value of 1.
</pre> </dd></dl>

</div>
</div>
<a id="a8f4b48837a8edb33dd4003ed717d03e1" name="a8f4b48837a8edb33dd4003ed717d03e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4b48837a8edb33dd4003ed717d03e1">&#9670;&nbsp;</a></span>levelmask_region_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::levelmask_region_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a mask to reflect region sizes. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="a00376e3fe457712ab10246026c478c89" name="a00376e3fe457712ab10246026c478c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00376e3fe457712ab10246026c478c89">&#9670;&nbsp;</a></span>levelmask_select() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::levelmask_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects regions overlapping a mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmask</td><td>overlap template mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of selected regions. <pre class="fragment">The input mask can be of any form. All non-zero parts of this mask is used.
</pre> </dd></dl>

</div>
</div>
<a id="a4c503a8bad6d5188959ef2102372c805" name="a4c503a8bad6d5188959ef2102372c805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c503a8bad6d5188959ef2102372c805">&#9670;&nbsp;</a></span>levelmask_select() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::levelmask_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a> &amp;&#160;</td>
          <td class="paramname"><em>select_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retains the selected levels in a multi-level mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;select_list</td><td>comma_separated list of levels to select. </td></tr>
    <tr><td class="paramname">flag</td><td>0=binary mask, 1=multi-level mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of voxels retained. <pre class="fragment">The new data replaces the old data.
The result is either a binary mask (flag=0) or a multi-level mask where
the level indices changed to reflect the new range of selected levels (flag=1).
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a0c655e6d6031423e7028b3d163c0a264" name="a0c655e6d6031423e7028b3d163c0a264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c655e6d6031423e7028b3d163c0a264">&#9670;&nbsp;</a></span>levelmask_select() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::levelmask_select </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>voxel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retains the selected levels in a multi-level mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number. </td></tr>
    <tr><td class="paramname">voxel</td><td>voxel with level to select. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of voxels retained. <pre class="fragment">The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a42c3d811f32bcb221a5692271fd2e4df" name="a42c3d811f32bcb221a5692271fd2e4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c3d811f32bcb221a5692271fd2e4df">&#9670;&nbsp;</a></span>levelmask_size_histogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::levelmask_size_histogram </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Color a multi-level mask based on the volumes of regions. </p>
<dl class="section return"><dt>Returns</dt><dd>Bplot* region size histogram. </dd></dl>

</div>
</div>
<a id="a152515cc985bb3785ae95e258381c211" name="a152515cc985bb3785ae95e258381c211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152515cc985bb3785ae95e258381c211">&#9670;&nbsp;</a></span>levelmask_switch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::levelmask_switch </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches two segments in a multi-level mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index1</td><td>first index. </td></tr>
    <tr><td class="paramname">index2</td><td>second index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of levels. <pre class="fragment">If the two indices are not found, the mask is not modified.
</pre> </dd></dl>

</div>
</div>
<a id="afd966c254c4470cdf8a9e1d9254e0438" name="afd966c254c4470cdf8a9e1d9254e0438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd966c254c4470cdf8a9e1d9254e0438">&#9670;&nbsp;</a></span>levelmask_symmetrize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::levelmask_symmetrize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symetrizes a multi-level mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>point group symmetry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long maximum level index. </dd></dl>

</div>
</div>
<a id="a10a2c7e875d850bfd0dbc3e46b9ea998" name="a10a2c7e875d850bfd0dbc3e46b9ea998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a2c7e875d850bfd0dbc3e46b9ea998">&#9670;&nbsp;</a></span>limit_levels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::limit_levels </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nlevels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a full gray scale image to a limited level image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlevels</td><td>number of levels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The dynamic range of the image is decreased to a given number of gray
scale levels.
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a9d059625d3892b2a07da71d3e8b400a9" name="a9d059625d3892b2a07da71d3e8b400a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d059625d3892b2a07da71d3e8b400a9">&#9670;&nbsp;</a></span>line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a line in an image and fills it with a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>three-value start of line. </td></tr>
    <tr><td class="paramname">end</td><td>three-value end of line. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of smoothing function. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The edge of the area is smoothed with a function:
                    v_old(x,y,z) + fill*exp(1.618*dist/width)
    v_new(x,y,z) = ------------------------------------------
                           1 + exp(1.618*dist/width)
where   fill is the constant fill value.
        dist is the distance to the rectangular boundary defined by
            the input size and start
        width is the gaussian width (softness)
With very small values of the gaussian width, the edge approaches a
step function.
</pre> </dd></dl>

</div>
</div>
<a id="a7bdfaa89652d965acbf3a94cb87501b8" name="a7bdfaa89652d965acbf3a94cb87501b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bdfaa89652d965acbf3a94cb87501b8">&#9670;&nbsp;</a></span>line_powerspectra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::line_powerspectra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the 1D power spectrum of each line in an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>fft plan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">Each line is transformed to a power spectrum in place.
</pre> </dd></dl>

</div>
</div>
<a id="a3cd968fadff01e5b7cb98bc61c5bb16c" name="a3cd968fadff01e5b7cb98bc61c5bb16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd968fadff01e5b7cb98bc61c5bb16c">&#9670;&nbsp;</a></span>linear_fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::linear_fit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_exclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear least squares fit of two images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
    <tr><td class="paramname">*pmask</td><td>mask to limit calculation to a certain region. </td></tr>
    <tr><td class="paramname">max_exclude</td><td>maximum percentage of outlying points to exclude. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double first R factor. <pre class="fragment">The data blocks from two images are fit by a simple linear least squares
regression algorithm with exclusion of a percentage of outliers:
    image2 = intercept + slope * image1
The first image is modified to return the difference:
    difference = intercept + slope * image1 - image2
The residual returned is:
    R = sqrt(sum(difference^2) / sum((image2-avg2)^2))
Note: A linear fit is not symmetric with respect to the two input
data sets - the order of the input images determine the output.
The two data blocks must have the same size and are converted to
floating point.
</pre> </dd></dl>

</div>
</div>
<a id="a5a9fe1dc8d2129d9407528f6f65eeb02" name="a5a9fe1dc8d2129d9407528f6f65eeb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9fe1dc8d2129d9407528f6f65eeb02">&#9670;&nbsp;</a></span>local_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::local_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>resmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>vedge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a local resolution filter to a map. </p>
<dl class="section author"><dt>Author</dt><dd>Giovanni Cardone and Bernard Heymann </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>mask of areas to generate. </td></tr>
    <tr><td class="paramname">mask_level</td><td>mask level. </td></tr>
    <tr><td class="paramname">*resmap</td><td>local resolution map. </td></tr>
    <tr><td class="paramname">size</td><td>kernel size. </td></tr>
    <tr><td class="paramname">vedge</td><td>edge size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* filtered image, NULL on error. <pre class="fragment">At each voxel, a kernel/small box is extracted and lowpass filtered
to the resolution limit for that voxel in the local resolution map.
A mask may be used to limit the region of application.
</pre> </dd></dl>

</div>
</div>
<a id="a6e71e8fb84408cc791660173295d23d9" name="a6e71e8fb84408cc791660173295d23d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e71e8fb84408cc791660173295d23d9">&#9670;&nbsp;</a></span>logarithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::logarithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the logarithm of the image data. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is first converted to floating point, or intensities
for complex data. The logarithm is calculated to place the minmum at
zero and scale it to the standard deviation:
                data - min
    new_data = log ------------- + 1
                   std
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a7e52a939175e002908692140c372213d" name="a7e52a939175e002908692140c372213d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e52a939175e002908692140c372213d">&#9670;&nbsp;</a></span>mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Masks an image. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Payne </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>binary mask. </td></tr>
    <tr><td class="paramname">fill</td><td>value to use where mask is zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long 0. <pre class="fragment">If the mask value for that pixel is 0, the image pixel is changed
to the fill value.  Otherwise it is left alone.
</pre> </dd></dl>

</div>
</div>
<a id="abf9e6d8253c07d69800a8eb4a349a81b" name="abf9e6d8253c07d69800a8eb4a349a81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9e6d8253c07d69800a8eb4a349a81b">&#9670;&nbsp;</a></span>mask_by_conditional_thresholds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::mask_by_conditional_thresholds </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mask based on a conditional hierarchy of thresholds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>array of gray scale levels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* unsigned char mask. <pre class="fragment">A multi-level mask is generated using the given threshold values.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a3d369e4ff6b9dafa6f4e7c3cc624cc8d" name="a3d369e4ff6b9dafa6f4e7c3cc624cc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d369e4ff6b9dafa6f4e7c3cc624cc8d">&#9670;&nbsp;</a></span>mask_by_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::mask_by_threshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mask based on an image at a given threshold. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Payne &amp; Bernard Heymann </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>gray scale level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* unsigned char mask. <pre class="fragment">A binary mask is generated using the given threshold.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a680ab2f328a430aa2419e8f99a7171ca" name="a680ab2f328a430aa2419e8f99a7171ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680ab2f328a430aa2419e8f99a7171ca">&#9670;&nbsp;</a></span>mask_by_thresholds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::mask_by_thresholds </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mask based on an image at given thresholds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>array of gray scale levels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* unsigned char mask. <pre class="fragment">A multi-level mask is generated using the given threshold values.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a2fc50476f618586e13c5d2ba99a3a4d5" name="a2fc50476f618586e13c5d2ba99a3a4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc50476f618586e13c5d2ba99a3a4d5">&#9670;&nbsp;</a></span>mask_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_close </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a binary mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">times</td><td>the number of times to dilate and erode the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long masked voxels. <pre class="fragment">Closing a mask is a dilation followed by an erosion.
</pre> </dd></dl>

</div>
</div>
<a id="a93d63999cd5d4250dcd81210958cac78" name="a93d63999cd5d4250dcd81210958cac78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d63999cd5d4250dcd81210958cac78">&#9670;&nbsp;</a></span>mask_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines two masks with different operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second mask. </td></tr>
    <tr><td class="paramname">operation</td><td>combining operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* unsigned char mask. <pre class="fragment">The input images are assumed to be a masks of 0's and 1's and are
modified according to the operation requested:
    0   val1 = val2
    1   val1 = val1 and val2
    2   val1 = val1 or  val2
    3   val1 = val1 xor val2
where val1 and val2 are the data in the two images. 
Image statistics of the first image are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="af36613b563af19c946ca869f076bf634" name="af36613b563af19c946ca869f076bf634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36613b563af19c946ca869f076bf634">&#9670;&nbsp;</a></span>mask_dilate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_dilate </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dilates a binary mask. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Payne &amp; Bernard Heymann </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">times</td><td>the number of times to dilate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long masked voxels. <pre class="fragment">Traditional 3^dim kernel dilation.  Any pixel with a value of 1 turns 
all of its neighbors to a value of 1.
</pre> </dd></dl>

</div>
</div>
<a id="a6e4f025da30842a514cb858e8054cc53" name="a6e4f025da30842a514cb858e8054cc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4f025da30842a514cb858e8054cc53">&#9670;&nbsp;</a></span>mask_dilate_erode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_dilate_erode </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dilates or erodes a binary mask. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Payne &amp; Bernard Heymann </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>0=erode, 1=dilate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long masked voxels. <pre class="fragment">Traditional 3^dim kernel dilation.  Any pixel with a value of 1 turns 
all of its neighbors to a value of 1.
</pre> </dd></dl>

</div>
</div>
<a id="a902d3c93fd01cff5be2cf247ab42c437" name="a902d3c93fd01cff5be2cf247ab42c437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902d3c93fd01cff5be2cf247ab42c437">&#9670;&nbsp;</a></span>mask_erode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_erode </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erodes a binary mask. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Payne &amp; Bernard Heymann </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">times</td><td>the number of times to erode the mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long masked voxels. <pre class="fragment">Traditional 3^dim kernel erosion.  If all the neighboring pixels have
value of 1, then that pixel is left at 1. Otherwise it is changed to 0.
</pre> </dd></dl>

</div>
</div>
<a id="a19c294d3382038ecc8c54bccfd4583d3" name="a19c294d3382038ecc8c54bccfd4583d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c294d3382038ecc8c54bccfd4583d3">&#9670;&nbsp;</a></span>mask_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::mask_extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zeroes everything outside the mask and return the excised feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* excised feature. <pre class="fragment">The mask must be the same size as the image.
</pre> </dd></dl>

</div>
</div>
<a id="ac82fd40b41c01945499551804754d76b" name="ac82fd40b41c01945499551804754d76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82fd40b41c01945499551804754d76b">&#9670;&nbsp;</a></span>mask_fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>voxel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills an empty part of a mask indicated by the given voxel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voxel</td><td>point from which to fill the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long masked voxels. </dd></dl>

</div>
</div>
<a id="ab103c7cb8674784b51c313026b294cde" name="ab103c7cb8674784b51c313026b294cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab103c7cb8674784b51c313026b294cde">&#9670;&nbsp;</a></span>mask_fspace_banded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::mask_fspace_banded </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>band</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate reciprocal space mask based on a specification of bands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;band</td><td>array of number pairs, each a shell and value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The band argument is a list of pairs of values, each pair indicating
a resolution shell (in angstrom) and a flag indicating whether the 
following shells should be:
    0: excluded - also the high resolution limit
    1: included in the FOM
    -1: included in the cross-validation FOM
The high resolution limit for the mask is set in the image structure.
</pre> </dd></dl>

</div>
</div>
<a id="a9b263c23f182cd36c93e7de6dc0741e5" name="a9b263c23f182cd36c93e7de6dc0741e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b263c23f182cd36c93e7de6dc0741e5">&#9670;&nbsp;</a></span>mask_fspace_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::mask_fspace_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes a reciprocal space mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>new mask size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector3.html">Vector3&lt;double&gt;</a> scale. <pre class="fragment">The mask is assumed to be centered at (0,0,0).
The image is resized by inserting or removing
rows or columns in the middle of the data set.
</pre> </dd></dl>

</div>
</div>
<a id="a47d213b882cd62b6ddd30592a8b9df45" name="a47d213b882cd62b6ddd30592a8b9df45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d213b882cd62b6ddd30592a8b9df45">&#9670;&nbsp;</a></span>mask_interface_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Bimage::mask_interface_matrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>img_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the interfaces between regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_num</td><td>sub-image number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_matrix.html">Matrix</a> interface matrix. <pre class="fragment">The mask must be an integer image.
An interface matrix is calculated to count the number of connected
voxels between every pair of regions.
Each value i in a row j gives the number of voxels of the region j that
are adjacent to one or more voxels in region i.
Row 0 and column 0 are excluded from the calculation.
</pre> </dd></dl>

</div>
</div>
<a id="a8a53e32389be9d324c6a5020c0d46478" name="a8a53e32389be9d324c6a5020c0d46478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a53e32389be9d324c6a5020c0d46478">&#9670;&nbsp;</a></span>mask_invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts a mask. </p>
<dl class="section return"><dt>Returns</dt><dd>long number of mask voxels. <pre class="fragment">The mask is assumed to be in range [0,1].
    new_mask = 1 - old_mask.
Image statistics of the mask are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a032c319d4fb989ec7da3c9088c17a987" name="a032c319d4fb989ec7da3c9088c17a987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032c319d4fb989ec7da3c9088c17a987">&#9670;&nbsp;</a></span>mask_merge_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_merge_delete </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>min_if</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the interfaces between regions and deletes/merges small ones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_size</td><td>minimum size to accept regions, small ones are deleted/merged. </td></tr>
    <tr><td class="paramname">min_if</td><td>minimum interface size to consider a small region connected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long 0. <pre class="fragment">The mask is converted to an integer mask.
An interface matrix is calculated to count the number of connected
voxels between every pair of regions.
Regions that are smaller than the minimum size are either deleted or
merged with other regions.
If the maximum interface size for a small region is less than the minimum
specified, the region is deleted, otherwise, it is added to that
neighboring region with which it shares the biggest interface.
</pre> </dd></dl>

</div>
</div>
<a id="a81e19d75253d301436865e742712abe5" name="a81e19d75253d301436865e742712abe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e19d75253d301436865e742712abe5">&#9670;&nbsp;</a></span>mask_missing_cone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_missing_cone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>ori</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mis_ang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mask with a missing cone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ori</td><td>image origin. </td></tr>
    <tr><td class="paramname">mis_ang</td><td>cone angle from xy plane. </td></tr>
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of mask voxels. <pre class="fragment">The given image is used to generate a binary mask of the same size.
If the input origin is {0,0,0}, the origin in the image is used as 
the center for the missing part.
</pre> </dd></dl>

</div>
</div>
<a id="a1b60c0e93b7ed7fd9141fcf89edd24f6" name="a1b60c0e93b7ed7fd9141fcf89edd24f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b60c0e93b7ed7fd9141fcf89edd24f6">&#9670;&nbsp;</a></span>mask_missing_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_missing_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>ori</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a> &amp;&#160;</td>
          <td class="paramname"><em>mis_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a missing mask from an example image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ori</td><td>image origin. </td></tr>
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">mis_type</td><td>missing region type: wedge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of mask voxels. <pre class="fragment">The given image is used to generate a binary mask of the same size.
If the input origin is {0,0,0}, the origin in the image is used as 
the center for the missing part.
</pre> </dd></dl>

</div>
</div>
<a id="a90602f4654cd1d2479828eddf096ddb3" name="a90602f4654cd1d2479828eddf096ddb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90602f4654cd1d2479828eddf096ddb3">&#9670;&nbsp;</a></span>mask_missing_pyramid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_missing_pyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>ori</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_axis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_neg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_neg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mask with a missing pyramid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ori</td><td>image origin. </td></tr>
    <tr><td class="paramname">tilt_axis1</td><td>tilt axis angle 1. </td></tr>
    <tr><td class="paramname">tilt_axis2</td><td>tilt axis angle 2. </td></tr>
    <tr><td class="paramname">tilt_neg1</td><td>negative tilt angle for axis 1. </td></tr>
    <tr><td class="paramname">tilt_pos1</td><td>positive tilt angle for axis 1. </td></tr>
    <tr><td class="paramname">tilt_neg2</td><td>negative tilt angle for axis 2. </td></tr>
    <tr><td class="paramname">tilt_pos2</td><td>positive tilt angle for axis 2. </td></tr>
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of mask voxels. <pre class="fragment">The given image is used to generate a binary mask of the same size.
If the input origin is {0,0,0}, the origin in the image is used as 
the center for the missing part.
</pre> </dd></dl>

</div>
</div>
<a id="acb39a8ba9b2b27d51721e89af40582a5" name="acb39a8ba9b2b27d51721e89af40582a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb39a8ba9b2b27d51721e89af40582a5">&#9670;&nbsp;</a></span>mask_missing_wedge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_missing_wedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>ori</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_neg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mask with a missing wedge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ori</td><td>image origin. </td></tr>
    <tr><td class="paramname">tilt_axis</td><td>tilt axis angle. </td></tr>
    <tr><td class="paramname">tilt_neg</td><td>negative tilt angle. </td></tr>
    <tr><td class="paramname">tilt_pos</td><td>positive tilt angle. </td></tr>
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of mask voxels. <pre class="fragment">The given image is used to generate a binary mask of the same size.
If the input origin is {0,0,0}, the origin in the image is used as 
the center for the missing part.
</pre> </dd></dl>

</div>
</div>
<a id="aaa3e82bba9f9618a7bb03ccdd3a2a223" name="aaa3e82bba9f9618a7bb03ccdd3a2a223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3e82bba9f9618a7bb03ccdd3a2a223">&#9670;&nbsp;</a></span>mask_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_open </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a binary mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">times</td><td>the number of times to erode and dilate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long masked voxels. <pre class="fragment">Opening a mask is an erosion followed by a dilation.
</pre> </dd></dl>

</div>
</div>
<a id="a90d83b3bde0fc65afea592336ea84424" name="a90d83b3bde0fc65afea592336ea84424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d83b3bde0fc65afea592336ea84424">&#9670;&nbsp;</a></span>mask_pack_plane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_pack_plane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hi_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packs a 2D mask into a 3D reciprocal space volume. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>affine orientation matrix. </td></tr>
    <tr><td class="paramname">hi_res</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">scale</td><td>scale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long 0. <pre class="fragment">The rotation matrix is used to determine the plane in reciprocal space
to set as one.
Both the high resolution limit and the scale must correspond to the 
associated reconstruction.
</pre> </dd></dl>

</div>
</div>
<a id="acca2b4d4df22975e0790da09f03d6b13" name="acca2b4d4df22975e0790da09f03d6b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca2b4d4df22975e0790da09f03d6b13">&#9670;&nbsp;</a></span>mask_plane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_plane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mask on one side of a plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>any point on plane. </td></tr>
    <tr><td class="paramname">normal</td><td>plane normal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long 0. <pre class="fragment">The given image is used to generate a binary mask of the same size.
</pre> </dd></dl>

</div>
</div>
<a id="a2b23d253a27fc9adead69d5f94f16ec7" name="a2b23d253a27fc9adead69d5f94f16ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b23d253a27fc9adead69d5f94f16ec7">&#9670;&nbsp;</a></span>mask_rectangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_rectangle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rect_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mask along an axis within a 2D image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>length along axis (pixels). </td></tr>
    <tr><td class="paramname">width</td><td>width perpendicular to axis (pixels). </td></tr>
    <tr><td class="paramname">rect_angle</td><td>angle from x-axis (radians). </td></tr>
    <tr><td class="paramname">wrap</td><td>flag to wrap around boundaries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long 0. <pre class="fragment">The input image is assumed to be a mask of 0's and 1's and is modified
according to the operation requested.
Only an axis in the xy plane is used, generating a rectangular mask
of given length and width around the axis, with its center at the
origins given in the image structure.
</pre> </dd></dl>

</div>
</div>
<a id="a94451f98c91c97bf0dee26b0b2a7deab" name="a94451f98c91c97bf0dee26b0b2a7deab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94451f98c91c97bf0dee26b0b2a7deab">&#9670;&nbsp;</a></span>mask_region_interfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_region_interfaces </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reg_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the whole interface matrix or interfaces for one region only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg_num</td><td>region to report for (&lt;0 whole interface matrix). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long 0. <pre class="fragment">The mask is converted to an integer mask.
An interface matrix is calculated to count the number of connected
voxels between every pair of regions.
</pre> </dd></dl>

</div>
</div>
<a id="ab7a554846aee83da6a7c471ca3ae8636" name="ab7a554846aee83da6a7c471ca3ae8636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a554846aee83da6a7c471ca3ae8636">&#9670;&nbsp;</a></span>mask_shell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1da94077a3d1099442e779a338873d3" name="aa1da94077a3d1099442e779a338873d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1da94077a3d1099442e779a338873d3">&#9670;&nbsp;</a></span>mask_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_split </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>voxels_per_level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a mask to a multilevel mask with a given number of voxels per level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voxels_per_level</td><td>number of voxels per level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of voxels retained. <pre class="fragment">The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="af6366dbd7f4291754ee084a5a47aed4e" name="af6366dbd7f4291754ee084a5a47aed4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6366dbd7f4291754ee084a5a47aed4e">&#9670;&nbsp;</a></span>mask_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates statistics for a mask. </p>
<dl class="section return"><dt>Returns</dt><dd>long voxels in positive levels. <pre class="fragment">The mask can be any type, but the regions in the mask are rounded to
the nearest integer for counting statistics.
</pre> </dd></dl>

</div>
</div>
<a id="a836137ddada36d9ee07e0c778597470c" name="a836137ddada36d9ee07e0c778597470c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836137ddada36d9ee07e0c778597470c">&#9670;&nbsp;</a></span>mask_symmetrize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::mask_symmetrize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symetrizes a mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>point group symmetry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long maximum level index. </dd></dl>

</div>
</div>
<a id="ad49ed68863064bb22ca6dc210a712f66" name="ad49ed68863064bb22ca6dc210a712f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49ed68863064bb22ca6dc210a712f66">&#9670;&nbsp;</a></span>mass_at_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::mass_at_threshold </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>img_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the mass from the density threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_num</td><td>sub-image number (first = 0). </td></tr>
    <tr><td class="paramname">threshold</td><td>density threshold. </td></tr>
    <tr><td class="paramname">rho</td><td>protein density in Da/A3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double threshold. <pre class="fragment">An image is assumed to have density represented by higher (white) values.
</pre> </dd></dl>

</div>
</div>
<a id="a6b9526b2fed89d032614d58b597db290" name="a6b9526b2fed89d032614d58b597db290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9526b2fed89d032614d58b597db290">&#9670;&nbsp;</a></span>mass_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::mass_threshold </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>img_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mol_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the density threshold associated with a particular molecular weight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_num</td><td>sub-image number (first = 0,). </td></tr>
    <tr><td class="paramname">mol_weight</td><td>molecular weight. </td></tr>
    <tr><td class="paramname">rho</td><td>protein density in Da/A3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float threshold. <pre class="fragment">A threshold value is determined which contour a density such that
it corresponds to 100% of the given molecular weight.
An image is assumed to have density represented by higher (white) values.
</pre> </dd></dl>

</div>
</div>
<a id="ab8ceb4eeff446c3ed0cc5b937cab227c" name="ab8ceb4eeff446c3ed0cc5b937cab227c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ceb4eeff446c3ed0cc5b937cab227c">&#9670;&nbsp;</a></span>max_in_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::max_in_kernel </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ksize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad56cad9380fe0b08593627bbc7f8d795" name="ad56cad9380fe0b08593627bbc7f8d795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56cad9380fe0b08593627bbc7f8d795">&#9670;&nbsp;</a></span>maximum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::maximum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28e3f6e31813aa176f38b1a18e2d800c" name="a28e3f6e31813aa176f38b1a18e2d800c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e3f6e31813aa176f38b1a18e2d800c">&#9670;&nbsp;</a></span>maximum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::maximum </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8043e568eb8132fa03ada899c4ac25fb" name="a8043e568eb8132fa03ada899c4ac25fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8043e568eb8132fa03ada899c4ac25fb">&#9670;&nbsp;</a></span>maximum_included_radius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::maximum_included_radius </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the radius of the enclosed sphere or circle. </p>
<dl class="section return"><dt>Returns</dt><dd>double radius of largest sphere that will fit in an image. <pre class="fragment">Returns the radius of the largest sphere or circle that will fit
inside a three- or two-dimensional image, respectively, or the 
midpoint of a one-dimensional image.
Assumes that the x, y, and z dimensions are the number of data points
in those respective directions, and that the length (in pixels)
of the respective dimensions is x, y, or z minus one.  The minimum 
length is two times the radius of the largest sphere that will fit 
inside the image.
</pre> </dd></dl>

</div>
</div>
<a id="add1b04d31f25a73455f662662193c9ac" name="add1b04d31f25a73455f662662193c9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1b04d31f25a73455f662662193c9ac">&#9670;&nbsp;</a></span>median_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::median_bin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binning</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bins by an integer size, selecting the kernel median. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binning</td><td>integer bin factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">An image is binned by an integer size, square in 2D and cubic in 3D.
</pre> </dd></dl>

</div>
</div>
<a id="a03a84149ddcfe364e0687f485939274e" name="a03a84149ddcfe364e0687f485939274e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a84149ddcfe364e0687f485939274e">&#9670;&nbsp;</a></span>merge_amplitudes_and_phases() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::merge_amplitudes_and_phases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the amplitudes from one map with the phases of another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pamp</td><td>amplitude image (simple or complex). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double RMSD of amplitudes. <pre class="fragment">The amplitude image can be a floating point image or a complex image.
The phase image must be complex and its amplitudes are replaced by
the values from the amplitude image.
No statistics are calculated.
</pre> </dd></dl>

</div>
</div>
<a id="a0c0ac2e1677fe947f84234716aba5e50" name="a0c0ac2e1677fe947f84234716aba5e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0ac2e1677fe947f84234716aba5e50">&#9670;&nbsp;</a></span>merge_amplitudes_and_phases() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::merge_amplitudes_and_phases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_lo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keeps selected phases and replaces amplitudes and other phases from a reference transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pref</td><td>reference Fourier transform. </td></tr>
    <tr><td class="paramname">res_hi</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">res_lo</td><td>low resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double RMSD of amplitudes. <pre class="fragment">The input transform is considered to be modified in some way (such as solvent flattening).
Only the phases in the specified resolution shell are kept, while all
the other phases and amplitudes within the high resolution limit is
retrieved from the reference transform.
No statistics are calculated.
</pre> </dd></dl>

</div>
</div>
<a id="a4d2f9330ca3541625f7a55d6e4ed94ca" name="a4d2f9330ca3541625f7a55d6e4ed94ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2f9330ca3541625f7a55d6e4ed94ca">&#9670;&nbsp;</a></span>meta_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_svalue.html">JSvalue</a> &amp; Bimage::meta_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6882144669b3c67abb55e76d4623a40b" name="a6882144669b3c67abb55e76d4623a40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6882144669b3c67abb55e76d4623a40b">&#9670;&nbsp;</a></span>meta_data_retain_one_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::meta_data_retain_one_image </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>img_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all sub-image records from the meta data except one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_num</td><td>sub-image number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a772035b309aa215414b94b3e1f991920" name="a772035b309aa215414b94b3e1f991920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772035b309aa215414b94b3e1f991920">&#9670;&nbsp;</a></span>meta_data_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::meta_data_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update metadata from the sub-image information. </p>
<pre class="fragment">The sub-image information is encoded in the metadata in JSON format.
</pre> 
</div>
</div>
<a id="a33db3f86c385dc4b3d8738d0ad0c59a3" name="a33db3f86c385dc4b3d8738d0ad0c59a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33db3f86c385dc4b3d8738d0ad0c59a3">&#9670;&nbsp;</a></span>minimum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::minimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dc7ace6085b582d96077515becacf8f" name="a9dc7ace6085b582d96077515becacf8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc7ace6085b582d96077515becacf8f">&#9670;&nbsp;</a></span>minimum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::minimum </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accac475d79e9c3cc1c6ebdc6f0148d69" name="accac475d79e9c3cc1c6ebdc6f0148d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accac475d79e9c3cc1c6ebdc6f0148d69">&#9670;&nbsp;</a></span>mirror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::mirror </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts/mirrors each image through its origin. </p>
<dl class="section return"><dt>Returns</dt><dd>int number of images. <pre class="fragment">Each image in a Bimage structure is inverted.
</pre> </dd></dl>

</div>
</div>
<a id="a4f3d8867cba26161c0d95971a8714496" name="a4f3d8867cba26161c0d95971a8714496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3d8867cba26161c0d95971a8714496">&#9670;&nbsp;</a></span>moments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::moments </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>max_order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints out moments for all sub-images. </p>
<dl class="section return"><dt>Returns</dt><dd>int error code (&lt;0 means failure). </dd></dl>

</div>
</div>
<a id="a0fae7890cf81c93fa08a4234d426e72d" name="a0fae7890cf81c93fa08a4234d426e72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fae7890cf81c93fa08a4234d426e72d">&#9670;&nbsp;</a></span>moments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::moments </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>max_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints out moments for one sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_order</td><td>maximum order. </td></tr>
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code (&lt;0 means failure). </dd></dl>

</div>
</div>
<a id="a3de7d9fd87a5c93d12ae9e9366e33b7a" name="a3de7d9fd87a5c93d12ae9e9366e33b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de7d9fd87a5c93d12ae9e9366e33b7a">&#9670;&nbsp;</a></span>montage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::montage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rearranges an image into a montage of 2D slices for display. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cols</td><td>columns in montage. </td></tr>
    <tr><td class="paramname">rows</td><td>rows in montage. </td></tr>
    <tr><td class="paramname">first</td><td>first slice in montage. </td></tr>
    <tr><td class="paramname">skip</td><td>number of slices to skip. </td></tr>
    <tr><td class="paramname">flip</td><td>flip the order of panels on: 1=x axis, 2=y axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* montaged image. <pre class="fragment">The slices of a 3D image are packed into a 2D montage.
The background value for the image is used for empty regions.
</pre> </dd></dl>

</div>
</div>
<a id="abc3633f91294bf9cd72154da5aa885b4" name="abc3633f91294bf9cd72154da5aa885b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3633f91294bf9cd72154da5aa885b4">&#9670;&nbsp;</a></span>moving_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::moving_sum </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a moving sum of the sub-images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>number of successive images to sum. </td></tr>
    <tr><td class="paramname">step</td><td>intervals between windows. </td></tr>
    <tr><td class="paramname">flag</td><td>if set, calculate average. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* moving sum/average image. <pre class="fragment">Each successive subset of sub-images of size set by the window parameter are summed.
Where the window extends beyond the limits for the number of images,
the summation is just over the existing images.
The number of images depends on the step size.
</pre> </dd></dl>

</div>
</div>
<a id="a7f4694a4f5f907752135c39d67fb02eb" name="a7f4694a4f5f907752135c39d67fb02eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4694a4f5f907752135c39d67fb02eb">&#9670;&nbsp;</a></span>multi_channel_to_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::multi_channel_to_complex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A multi-channel image is converted to a set of complex images. </p>
<pre class="fragment">The input image channels are written into the real part of the complex image.
</pre> 
</div>
</div>
<a id="a546a12884111b3559dd39393b33344e7" name="a546a12884111b3559dd39393b33344e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546a12884111b3559dd39393b33344e7">&#9670;&nbsp;</a></span>multiply() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies all sub-images with the first sub-image of the other image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>image multiplier. <pre class="fragment">The other image is multiplied with the first.
Both images are converted to floating point.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06577441795cc23f8f149d453167f4f4" name="a06577441795cc23f8f149d453167f4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06577441795cc23f8f149d453167f4f4">&#9670;&nbsp;</a></span>multiply() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies an image with another image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>image multiplier. </td></tr>
    <tr><td class="paramname">scale</td><td>density scale to other image </td></tr>
    <tr><td class="paramname">shift</td><td>density shift to other image. <pre class="fragment">Requirement: The images must have the same size.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f53c71f2d4540295de067659d4d3e26" name="a8f53c71f2d4540295de067659d4d3e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f53c71f2d4540295de067659d4d3e26">&#9670;&nbsp;</a></span>multiply() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::multiply </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies an image with a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>constant multiplier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3852c4e4ecd306c5d6abc09f3d78f7f" name="ad3852c4e4ecd306c5d6abc09f3d78f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3852c4e4ecd306c5d6abc09f3d78f7f">&#9670;&nbsp;</a></span>multiply() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::multiply </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_complex.html">Complex</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>cv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62301788f8dd6bb54f498908100c6144" name="a62301788f8dd6bb54f498908100c6144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62301788f8dd6bb54f498908100c6144">&#9670;&nbsp;</a></span>multiply() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::multiply </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies a sub-image with another image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image to multiply. </td></tr>
    <tr><td class="paramname">*p</td><td>image multiplier. <pre class="fragment">Requirement: The images must have the same size.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba8ca57c4383b415ab312f8be4fcf309" name="aba8ca57c4383b415ab312f8be4fcf309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8ca57c4383b415ab312f8be4fcf309">&#9670;&nbsp;</a></span>multiply() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::multiply </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies a sub-image with a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">v</td><td>constant multiplier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec5451bc9105d457fb967a025bd0c0cd" name="aec5451bc9105d457fb967a025bd0c0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5451bc9105d457fb967a025bd0c0cd">&#9670;&nbsp;</a></span>nad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::nad </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>zw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Denoises a 3D density map by non-linear anisotropic diffusion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>time step size, 0 &lt; ht &lt;= 0.25. </td></tr>
    <tr><td class="paramname">zw</td><td>slab size for piece-wise denoising. </td></tr>
    <tr><td class="paramname">lambda</td><td>lamda parameter for EED. </td></tr>
    <tr><td class="paramname">C</td><td>coherence parameter for CED. </td></tr>
    <tr><td class="paramname">alpha</td><td>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new image. <pre class="fragment">The diffusion tensor is calculated with the aim of enhancing edges (EED)
or planes (CED).
</pre> </dd></dl>

</div>
</div>
<a id="a2ec6da2aebaf06f411b5a98f2ecedae9" name="a2ec6da2aebaf06f411b5a98f2ecedae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec6da2aebaf06f411b5a98f2ecedae9">&#9670;&nbsp;</a></span>nad_2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::nad_2D </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Denoises a 2D image by non-linear anisotropic diffusion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>time step size, 0 &lt; ht &lt;= 0.25. </td></tr>
    <tr><td class="paramname">lambda</td><td>lamda parameter for EED. </td></tr>
    <tr><td class="paramname">C</td><td>coherence parameter for CED. </td></tr>
    <tr><td class="paramname">alpha</td><td>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new image. <pre class="fragment">The diffusion tensor is calculated with the aim of enhancing edges (EED)
or planes (CED).
</pre> </dd></dl>

</div>
</div>
<a id="ada19a7de518b9a3ae873b75729c8f74a" name="ada19a7de518b9a3ae873b75729c8f74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada19a7de518b9a3ae873b75729c8f74a">&#9670;&nbsp;</a></span>noise_gaussian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::noise_gaussian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ravg</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rstd</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an image with a gaussian random distribution of densities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ravg</td><td>average. </td></tr>
    <tr><td class="paramname">rstd</td><td>standard deviation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">An image with a given datatype, number of subimages, and size is
generated with densities with a gaussian distribution with a given
average and standard deviation:
    density = average + std_dev*sqrt(-2*log(random_value))*
                    cos(2*PI*random_value);
where random_value is between 0 and 1.
The output image is floating point.
Statistics are calculated before returning.
</pre> </dd></dl>

</div>
</div>
<a id="a2b440a133368904a12132742c4c8c07d" name="a2b440a133368904a12132742c4c8c07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b440a133368904a12132742c4c8c07d">&#9670;&nbsp;</a></span>noise_logistical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::noise_logistical </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ravg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rstd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an image with a gaussian random distribution of densities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ravg</td><td>average. </td></tr>
    <tr><td class="paramname">rstd</td><td>standard deviation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">An image with a given datatype, number of subimages, and size is
generated with densities with a logistical differential distribution 
with a given average and standard deviation:
    density = average + (std_dev/golden)*ln(1/random_value - 1)
where random_value is between 0 and 1 and:
    golden  = (sqrt(5) + 1)/2
The output image is floating point.
Statistics are calculated before returning.
</pre> Reference: Press W.H. et al (1992) Numerical Recipes in C. </dd></dl>

</div>
</div>
<a id="adc4e6a903ad879bba330eb40f419d8ac" name="adc4e6a903ad879bba330eb40f419d8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4e6a903ad879bba330eb40f419d8ac">&#9670;&nbsp;</a></span>noise_poisson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::noise_poisson </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ravg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an image with a poisson random distribution of densities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ravg</td><td>average. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">Algorithm taken from Numerical Recipes in C.
The poisson distribution is given for j = 0,1,... by:
            avg^j * exp(-avg)
    P(j) = -----------------
                   j!
Note that only positive integer values are defined for j and sum(P(j)) = 1.
An array of floating point numbers is generated with a poisson 
distribution with a given average. The standard deviation is:
    std = sqrt(avg)
If the average &lt;= 0, the function exits.
Statistics are calculated before returning.
</pre> Reference: Press W.H. et al (1992) Numerical Recipes in C. </dd></dl>

</div>
</div>
<a id="a0be1dd59316cc9ba6cb3af8a2cd7364f" name="a0be1dd59316cc9ba6cb3af8a2cd7364f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be1dd59316cc9ba6cb3af8a2cd7364f">&#9670;&nbsp;</a></span>noise_spectral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::noise_spectral </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a noise map with a defined spectral decay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>spectral decay. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">Uniform random phases are generated and the amplitudes are set to:
    amp = s^(-alpha/2).
</pre> </dd></dl>

</div>
</div>
<a id="a8789a73a0157946672911c639e820126" name="a8789a73a0157946672911c639e820126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8789a73a0157946672911c639e820126">&#9670;&nbsp;</a></span>noise_uniform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::noise_uniform </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an image with a uniform random distribution of densities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rmin</td><td>minimum density value. </td></tr>
    <tr><td class="paramname">rmax</td><td>maximum density value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">An image with a given datatype, number of subimages, and size is
generated with densities distributed uniformly in the range of the
given minimum and maximum:
    density = random_value*(max - min) + min
where random_value is between 0 and 1.
The average and standard deviation are:
    average = (max + min)/2
    standard deviation = 0.5*sqrt(1/3)*(max - min).
The output image is floating point.
Statistics are calculated before returning.
</pre> </dd></dl>

</div>
</div>
<a id="a9b6cf645edf16da07022babcacf20692" name="a9b6cf645edf16da07022babcacf20692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6cf645edf16da07022babcacf20692">&#9670;&nbsp;</a></span>normalize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::normalize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>average</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes a set of images to a desired average and standard deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">average</td><td>desired average. </td></tr>
    <tr><td class="paramname">stdev</td><td>desired standard deviation (if 0, use defaults). </td></tr>
    <tr><td class="paramname">norm_type</td><td>type of determining the effective average and standard deviation: 0=simple, 1=Gaussian, 2=Poisson. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The effective average and standard deviation for each image is obtained
in one of three ways:
    0.      The simple avergae and standard devaition for the image.
    1.      Gaussian fit of the histogram.
    2.      Poisson fit of the histogram.
A histogram of an image is calculated with a given number of bins.
The histogram is fit to a Gaussian or Poisson function with exclusion of a
small number of bins in the histogram (defined as outliers).
The effective average and standard deviation are used to 
rescale the data for each image.
</pre> </dd></dl>

</div>
</div>
<a id="add3eb1f754594a556d8a2d43a074b91a" name="add3eb1f754594a556d8a2d43a074b91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3eb1f754594a556d8a2d43a074b91a">&#9670;&nbsp;</a></span>normalize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::normalize </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>imgnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>average</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes a sub-image to a desired average and standard deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imgnum</td><td>sub-image number. </td></tr>
    <tr><td class="paramname">average</td><td>desired average. </td></tr>
    <tr><td class="paramname">stdev</td><td>desired standard deviation (if 0, use defaults). </td></tr>
    <tr><td class="paramname">norm_type</td><td>type of determining the effective average and standard deviation: 0=simple, 1=Gaussian, 2=Poisson. </td></tr>
    <tr><td class="paramname">bins</td><td>number of histogram bins required to fit distributions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The effective average and standard deviation for each image is obtained
in one of three ways:
    0.      The simple avergae and standard devaition for the image.
    1.      Gaussian fit of the histogram.
    2.      Poisson fit of the histogram.
A histogram of an image is calculated with a given number of bins.
The histogram is fit to a Gaussian or Poisson function with exclusion of a
small number of bins in the histogram (defined as outliers).
The effective average and standard deviation are used to 
rescale the data for each image.
</pre> </dd></dl>

</div>
</div>
<a id="a0d99849ef19cf0e3af2adeb2182ed0a2" name="a0d99849ef19cf0e3af2adeb2182ed0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d99849ef19cf0e3af2adeb2182ed0a2">&#9670;&nbsp;</a></span>normalize_local() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::normalize_local </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>kernel_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes by subtracting local average and dividing by local standard deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel_size</td><td>size of kernel edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The local average and standard deviation within a kernel is calculated 
and used to normalize the image.
The convolution is threaded if compiled with GCD or OpenMP.
</pre> </dd></dl>

</div>
</div>
<a id="a673b8d495c7e50207c95034787cae2b6" name="a673b8d495c7e50207c95034787cae2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673b8d495c7e50207c95034787cae2b6">&#9670;&nbsp;</a></span>normalize_local() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::normalize_local </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>kernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes by subtracting local average and dividing by local standard deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel</td><td>size of kernel edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The local average and standard deviation within a kernel is calculated 
and used to normalize the image.
The convolution is threaded if compiled with GCD or OpenMP.
</pre> </dd></dl>

</div>
</div>
<a id="a80baea1fc2db2bac3aa5837f7396c0d4" name="a80baea1fc2db2bac3aa5837f7396c0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80baea1fc2db2bac3aa5837f7396c0d4">&#9670;&nbsp;</a></span>one_color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::one_color </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a gray-scale image to a single color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>color selection (0=red, 1=green, 2=blue). </td></tr>
    <tr><td class="paramname">cmin</td><td>lower grayscale boundary. </td></tr>
    <tr><td class="paramname">cmax</td><td>upper grayscale boundary. </td></tr>
    <tr><td class="paramname">flag</td><td>sets the type of conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">A grayscale image is converted to a selected color between the given minimum and maximum.
The flag parameter bit:
    bit 1       calculate a subtractive color range.
    bit 2       keep the ranges beyond the minimum and maximum as gray
</pre> </dd></dl>

</div>
</div>
<a id="aad018ca33d662271a36e48fbf559240d" name="aad018ca33d662271a36e48fbf559240d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad018ca33d662271a36e48fbf559240d">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds two images together, adjusting for size difference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;p</td><td>image to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* summed image, NULL on error. <pre class="fragment">The second image is added to the first:
    image1 = image1 + image2*scale + shift
The resultant image size is the bigger of the two.
</pre> </dd></dl>

</div>
</div>
<a id="a04b048e81f60b70ed447b2f320fd2a84" name="a04b048e81f60b70ed447b2f320fd2a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b048e81f60b70ed447b2f320fd2a84">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> &amp; Bimage::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_bimage.html">Bimage</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns an image. </p>
<pre class="fragment">The internal copy function is called.
</pre> 
</div>
</div>
<a id="ae7e22c15acc26a18a01f9ffe932dc7dd" name="ae7e22c15acc26a18a01f9ffe932dc7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e22c15acc26a18a01f9ffe932dc7dd">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::operator[] </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the data value at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double value. <pre class="fragment">The elemental data value is returned in double precision.
</pre> </dd></dl>

</div>
</div>
<a id="aeba0b9cd4a35c4bde1e08cf50c0c951a" name="aeba0b9cd4a35c4bde1e08cf50c0c951a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba0b9cd4a35c4bde1e08cf50c0c951a">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_svalue.html">JSvalue</a> &amp; Bimage::operator[] </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c6011cf7fd6d019afb2c0025e949d30" name="a9c6011cf7fd6d019afb2c0025e949d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6011cf7fd6d019afb2c0025e949d30">&#9670;&nbsp;</a></span>orient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::orient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a> *&#160;</td>
          <td class="paramname"><em>views</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates multiple copies oriented according to views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">views</td><td>orientations for new images. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new set of images. <pre class="fragment">Each image in a Bimage structure is rotated to the corresponding view.
</pre> </dd></dl>

</div>
</div>
<a id="abbbc219bc9f6b027e29563617a756bbd" name="abbbc219bc9f6b027e29563617a756bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbc219bc9f6b027e29563617a756bbd">&#9670;&nbsp;</a></span>origin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::origin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>oy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>oz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26f0c689d93792813cd398f42b0eeabf" name="a26f0c689d93792813cd398f42b0eeabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f0c689d93792813cd398f42b0eeabf">&#9670;&nbsp;</a></span>origin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::origin </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>oy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>oz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98e0a30cc0f50a48a0cb5e6301a51ea0" name="a98e0a30cc0f50a48a0cb5e6301a51ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e0a30cc0f50a48a0cb5e6301a51ea0">&#9670;&nbsp;</a></span>origin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::origin </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af34a10d6c3278ff9f9aeafd0eef4e55c" name="af34a10d6c3278ff9f9aeafd0eef4e55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34a10d6c3278ff9f9aeafd0eef4e55c">&#9670;&nbsp;</a></span>origin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::origin </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>ori</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1395858573fc8bc13d5d1ab966f09625" name="a1395858573fc8bc13d5d1ab966f09625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1395858573fc8bc13d5d1ab966f09625">&#9670;&nbsp;</a></span>origin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::origin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b38a7622f63be6254386f29aee89d57" name="a0b38a7622f63be6254386f29aee89d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b38a7622f63be6254386f29aee89d57">&#9670;&nbsp;</a></span>origin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::origin </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a355e6600b5f741910cb5ddfbd3b561f6" name="a355e6600b5f741910cb5ddfbd3b561f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355e6600b5f741910cb5ddfbd3b561f6">&#9670;&nbsp;</a></span>orthogonal_slices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::orthogonal_slices </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>voxel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>ext_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts orthogonal views around a voxel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number to extract. </td></tr>
    <tr><td class="paramname">voxel</td><td>voxel of intersection. </td></tr>
    <tr><td class="paramname">ext_size</td><td>size of slices to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* extracted slice for 2D and 3 slices for 3D. <pre class="fragment">Only the desired region is extracted from the original image.
The fill value is taken from the image background.
</pre> </dd></dl>

</div>
</div>
<a id="a89cdfb0e8c07177ab797bfacd8cf7136" name="a89cdfb0e8c07177ab797bfacd8cf7136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cdfb0e8c07177ab797bfacd8cf7136">&#9670;&nbsp;</a></span>otsu_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::otsu_threshold </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the threshold from a histogram according to Otsu. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bins</td><td>number bins in histogram. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double threshold. <pre class="fragment">Reference: NOBUYUKI OTSU, IEEE TRANSACTIONS ON SYSTEMS, MAN, AND CYBERNETICS, VOL. SMC-9, NO. 1, JANUARY 1979
</pre> </dd></dl>

</div>
</div>
<a id="a8a1320da7a667791d7caf69d8de5f334" name="a8a1320da7a667791d7caf69d8de5f334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1320da7a667791d7caf69d8de5f334">&#9670;&nbsp;</a></span>otsu_variance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; Bimage::otsu_variance </td>
          <td>(</td>
          <td class="paramtype">vector&lt; long &gt;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the inter-set variance of the bisection of a historgram using the method of Otsu. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>histogram. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt; variance. <pre class="fragment">Reference: NOBUYUKI OTSU, IEEE TRANSACTIONS ON SYSTEMS, MAN, AND CYBERNETICS, VOL. SMC-9, NO. 1, JANUARY 1979
</pre> </dd></dl>

</div>
</div>
<a id="aac6a00076ac48cd4a17d3aa9504ba5ed" name="aac6a00076ac48cd4a17d3aa9504ba5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6a00076ac48cd4a17d3aa9504ba5ed">&#9670;&nbsp;</a></span>pack_transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::pack_transform </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>img_select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_bimage_8h.html#a01e0deba350901d769526633e868806f">FourierType</a>&#160;</td>
          <td class="paramname"><em>tf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d0d22533e811d43ee246eae948bb5a8" name="a3d0d22533e811d43ee246eae948bb5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0d22533e811d43ee246eae948bb5a8">&#9670;&nbsp;</a></span>pack_transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::pack_transform </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_bimage_8h.html#a01e0deba350901d769526633e868806f">FourierType</a>&#160;</td>
          <td class="paramname"><em>tf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fdf88c178b8f32dafefe99468a543c6" name="a4fdf88c178b8f32dafefe99468a543c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdf88c178b8f32dafefe99468a543c6">&#9670;&nbsp;</a></span>pack_two_in_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::pack_two_in_complex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packs two real images into one complex image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* the new complex image, NULL on error. <pre class="fragment">Two real space images are packed into the real and imaginary parts
of a new data block with conversion from the original non-complex type.
The header values of the first image are adopted for the new image.
No statistics are calculated.
</pre> </dd></dl>

</div>
</div>
<a id="a130d1713a0034d563b93034b05680768" name="a130d1713a0034d563b93034b05680768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130d1713a0034d563b93034b05680768">&#9670;&nbsp;</a></span>pad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::pad </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pads an image to a new size with a given fill value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>new size. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>value to use when padding the image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is enlarged with padding only on one side in each
dimension with an input size greater than one.
The data type is preserved.
</pre> </dd></dl>

</div>
</div>
<a id="a8f7768e1c67e5fcb2a57d36878003b93" name="a8f7768e1c67e5fcb2a57d36878003b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7768e1c67e5fcb2a57d36878003b93">&#9670;&nbsp;</a></span>pad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::pad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pads an image to a new size with a given fill value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>new size. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>value to use when padding the image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0.</dd></dl>
<p>The image is enlarged with padding only on one side in each dimension with an input size greater than one. The data type is preserved. </p>

</div>
</div>
<a id="a211fe34d03f455a6da9ffae457618b29" name="a211fe34d03f455a6da9ffae457618b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211fe34d03f455a6da9ffae457618b29">&#9670;&nbsp;</a></span>pad_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::pad_copy </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pads an image to a new size with a given fill value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>new size. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>value to use when padding the image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* resized image. <pre class="fragment">The image is enlarged with padding only on one side in each
dimension with an input size greater than one.
The data type is preserved.
</pre> </dd></dl>

</div>
</div>
<a id="a2a7d060153f985a71eb45ce5dd52ed5a" name="a2a7d060153f985a71eb45ce5dd52ed5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7d060153f985a71eb45ce5dd52ed5a">&#9670;&nbsp;</a></span>pad_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::pad_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pads an image to a new size with a given fill value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>new size. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>value to use when padding the image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* resized image.</dd></dl>
<p>The image is enlarged with padding only on one side in each dimension with an input size greater than one. The data type is preserved. </p>

</div>
</div>
<a id="a9875a6beebd6b73bb2c63bb6714b78db" name="a9875a6beebd6b73bb2c63bb6714b78db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9875a6beebd6b73bb2c63bb6714b78db">&#9670;&nbsp;</a></span>page_size() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; Bimage::page_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a2a0a9e54ad670ae18e36cf0c2ad397" name="a6a2a0a9e54ad670ae18e36cf0c2ad397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2a0a9e54ad670ae18e36cf0c2ad397">&#9670;&nbsp;</a></span>page_size() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::page_size </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f4598b33854f980fbc035ad2745380e" name="a9f4598b33854f980fbc035ad2745380e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4598b33854f980fbc035ad2745380e">&#9670;&nbsp;</a></span>page_size() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::page_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acde654e87de96fccb0b430c9ac1c7693" name="acde654e87de96fccb0b430c9ac1c7693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde654e87de96fccb0b430c9ac1c7693">&#9670;&nbsp;</a></span>page_size() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::page_size </td>
          <td>(</td>
          <td class="paramtype">vector&lt; long &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a200da2cfe749e4702e39b95e3128355f" name="a200da2cfe749e4702e39b95e3128355f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200da2cfe749e4702e39b95e3128355f">&#9670;&nbsp;</a></span>peak_sigma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::peak_sigma </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>coor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>kernel_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a sigma value for a cross-correlation peak. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">coor</td><td>coordinates in the image. </td></tr>
    <tr><td class="paramname">kernel_size</td><td>kernel size to fit the gaussian. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double sigma value. <pre class="fragment">The peak is assumed to be close to a gaussian.
The sigma is calculated for each kernel location and averaged:
    sigma = sqrt(rad^2/2(ln(vmax)-ln(v)))
</pre> </dd></dl>

</div>
</div>
<a id="aaf5664a095dcb822b3236ccfcc2b7165" name="aaf5664a095dcb822b3236ccfcc2b7165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5664a095dcb822b3236ccfcc2b7165">&#9670;&nbsp;</a></span>percentiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::percentiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the percentiles from the histogram of an image. </p>
<dl class="section return"><dt>Returns</dt><dd>Bplot* plot of the percentiles. <pre class="fragment">A histogram of an image is calculated with 10000 bins.
The percentiles are calculated from the running sum of the histogram
and returned in a plot.
</pre> </dd></dl>

</div>
</div>
<a id="a3af3c37bff79cfdec5c4ab443d00a3b7" name="a3af3c37bff79cfdec5c4ab443d00a3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af3c37bff79cfdec5c4ab443d00a3b7">&#9670;&nbsp;</a></span>periodic_averaging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::periodic_averaging </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an average within a periodic frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>size of periodic frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new image. </dd></dl>

</div>
</div>
<a id="a3f15772a51c0eb1d502fe03d423fba69" name="a3f15772a51c0eb1d502fe03d423fba69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f15772a51c0eb1d502fe03d423fba69">&#9670;&nbsp;</a></span>phase_colour_wheel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::phase_colour_wheel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a phase color wheel. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is filled with a color wheel where the location (x,y) 
is converted to polar form:
    a = arctan(y/x)
    r = sqrt(x^2+y^2)
The color is a function of the angle a and saturation is a function
of the distance from the origin.
</pre> </dd></dl>

</div>
</div>
<a id="acfe39f90afbe00c91da38a7536dc6fb8" name="acfe39f90afbe00c91da38a7536dc6fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe39f90afbe00c91da38a7536dc6fb8">&#9670;&nbsp;</a></span>phase_difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::phase_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_lo</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the cosine of the phase difference between two images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>real space reference image. </td></tr>
    <tr><td class="paramname">type</td><td>0=phase angle, 1=cos(phase angle), 2=scale by amplitude product </td></tr>
    <tr><td class="paramname">res_hi</td><td>upper resolution limit. </td></tr>
    <tr><td class="paramname">res_lo</td><td>lower resolution limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* phase difference image. <pre class="fragment">Both images are Fourier transformed and the cosine of the phase
difference calculated.
</pre> </dd></dl>

</div>
</div>
<a id="a5afda6e89e9c754d281e416fd0a64a1e" name="a5afda6e89e9c754d281e416fd0a64a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afda6e89e9c754d281e416fd0a64a1e">&#9670;&nbsp;</a></span>phase_flip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::phase_flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flips the phases of an image based on a phase difference map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pd</td><td>reciprocal space phase difference map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="a634b527816eb889e18c2b945cbee91f9" name="a634b527816eb889e18c2b945cbee91f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634b527816eb889e18c2b945cbee91f9">&#9670;&nbsp;</a></span>phase_shift() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::phase_shift </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Phase shifts a complex sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image to transform. </td></tr>
    <tr><td class="paramname">shift</td><td>three-value real space shift vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">A real space translation with wrapping is equivalent to phase shifting
in reciprocal space.
</pre> </dd></dl>

</div>
</div>
<a id="a3d1e6fe27d9a3cabcf908748000ede94" name="a3d1e6fe27d9a3cabcf908748000ede94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1e6fe27d9a3cabcf908748000ede94">&#9670;&nbsp;</a></span>phase_shift() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::phase_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Phase shifts a complex image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td>three-value real space shift vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">A real space translation with wrapping is equivalent to phase shifting
in reciprocal space.
</pre> </dd></dl>

</div>
</div>
<a id="aacdc9509fb8666efb3b60141d95aa36d" name="aacdc9509fb8666efb3b60141d95aa36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdc9509fb8666efb3b60141d95aa36d">&#9670;&nbsp;</a></span>phase_shift_to_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::phase_shift_to_center </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Phase shifts a set of reflections to the nominal center of the image origin. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">A real space translation with wrapping is equivalent to phase shifting
in reciprocal space. The phases are shifted based on the embedded
sub-image origins.
</pre> </dd></dl>

</div>
</div>
<a id="a19989b5365083532862811255c06b538" name="a19989b5365083532862811255c06b538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19989b5365083532862811255c06b538">&#9670;&nbsp;</a></span>phase_shift_to_origin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::phase_shift_to_origin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Phase shifts a set of reflections to the image origin. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">A real space translation with wrapping is equivalent to phase shifting
in reciprocal space. The phases are shifted based on the embedded
sub-image origins.
</pre> </dd></dl>

</div>
</div>
<a id="af1d647152e38cede66380147e1bcf1ca" name="af1d647152e38cede66380147e1bcf1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d647152e38cede66380147e1bcf1ca">&#9670;&nbsp;</a></span>place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::place </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>operation</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a small image into a large image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">*p</td><td>image to place. </td></tr>
    <tr><td class="paramname">loc</td><td>location in large image of small image origin. </td></tr>
    <tr><td class="paramname">radius</td><td>radial mask to transfer small image. </td></tr>
    <tr><td class="paramname">scale</td><td>density scale to apply to second image. </td></tr>
    <tr><td class="paramname">shift</td><td>density shift to apply to second image. </td></tr>
    <tr><td class="paramname">operation</td><td>operation to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 if error. <pre class="fragment">The small image is placed with its origin at given origin in the large image.
The second image is scaled and shifted before placing into the first:
    image1 = image1 + image2*scale + shift
Both images are converted to floating point.
The operation can be selected:
    0   simple addition.
    1   replace if smaller.
    2   replace if larger.
Requirement: Both images must have the same pixel size.
</pre> </dd></dl>

</div>
</div>
<a id="a1435a37676ede35fc90a5414851a0c41" name="a1435a37676ede35fc90a5414851a0c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1435a37676ede35fc90a5414851a0c41">&#9670;&nbsp;</a></span>place_central_part()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::place_central_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packs a tile into a new composite image, retaining only the central part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>image = tiles. </td></tr>
    <tr><td class="paramname">nn</td><td>tile image (can be a sub-image). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The overlaps between tiles are divided between the neighboring tiles.
The tile placement is in the sub-image origins.
</pre> </dd></dl>

</div>
</div>
<a id="a9011e8d831cdcc0327736162163abd17" name="a9011e8d831cdcc0327736162163abd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9011e8d831cdcc0327736162163abd17">&#9670;&nbsp;</a></span>place_with_addition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::place_with_addition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packs a tile into a new composite image with addition within overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>image = tiles. </td></tr>
    <tr><td class="paramname">nn</td><td>tile image (can be a sub-image). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The tiles are added to the image.
The contributions at each voxel are counted in a linked image.
The tile placement is in the sub-image origins.
</pre> </dd></dl>

</div>
</div>
<a id="a421ea2ee53d684fb3a5c54f46a0e8b2a" name="a421ea2ee53d684fb3a5c54f46a0e8b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421ea2ee53d684fb3a5c54f46a0e8b2a">&#9670;&nbsp;</a></span>place_with_overlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::place_with_overlap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packs a tile into a new composite image with weighted overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>image = tiles. </td></tr>
    <tr><td class="paramname">nn</td><td>tile image (can be a sub-image). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The overlaps between tiles are filled in with a weighted average based
on a linear transition from one to the other.
The tile placement is in the sub-image origins.
</pre> </dd></dl>

</div>
</div>
<a id="a43916985ee29b7482e3d0bbcd97b68b7" name="a43916985ee29b7482e3d0bbcd97b68b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43916985ee29b7482e3d0bbcd97b68b7">&#9670;&nbsp;</a></span>plot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::plot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a one-dimensional image into a plot. </p>
<dl class="section return"><dt>Returns</dt><dd>Bplot* plot structure.</dd></dl>
<p>Each image generates one plot with each channel converted to a curve. </p>

</div>
</div>
<a id="a870a8b94b0a187b9020eb97a01c98962" name="a870a8b94b0a187b9020eb97a01c98962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870a8b94b0a187b9020eb97a01c98962">&#9670;&nbsp;</a></span>poisson_statistics_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::poisson_statistics_check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the statistics conform to a Poisson distribution. </p>
<dl class="section return"><dt>Returns</dt><dd>double variance-to-average scale. <pre class="fragment">A warning is issued when the variance/average differs more than 5% from one.
</pre> </dd></dl>

</div>
</div>
<a id="a426b883cb5948d3d72776e8dab1370be" name="a426b883cb5948d3d72776e8dab1370be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426b883cb5948d3d72776e8dab1370be">&#9670;&nbsp;</a></span>polar_power_spectrum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::polar_power_spectrum </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>num_angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the polar power spectrum of a 2D transform amplitude or intensity image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">num_angle</td><td>number of angles to use for interpolation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* polar power spectrum. <pre class="fragment">The length of each annulus is number of angles times the radial offset.
The samples on each annulus are calculated by bilinear interpolation.
The maximum annulus calculated depends on the resolution limit specified
in the input image.
</pre> </dd></dl>

</div>
</div>
<a id="a013af83454914211aea16cea113711a5" name="a013af83454914211aea16cea113711a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013af83454914211aea16cea113711a5">&#9670;&nbsp;</a></span>polar_transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::polar_transform </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ann_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ann_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dann</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>zmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>zmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>zinc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an image with cylindrical coordinates by integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nangles</td><td>number of angles in each annulus. </td></tr>
    <tr><td class="paramname">ann_min</td><td>minimum annulus (pixels). </td></tr>
    <tr><td class="paramname">ann_max</td><td>maximum annulus (pixels). </td></tr>
    <tr><td class="paramname">dann</td><td>width of annulus (pixels). </td></tr>
    <tr><td class="paramname">zmin</td><td>minimum z (pixels). </td></tr>
    <tr><td class="paramname">zmax</td><td>maximum z (pixels). </td></tr>
    <tr><td class="paramname">zinc</td><td>increment in z (pixels). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* cylindrical image. <pre class="fragment">The image is converted to cylindrical form by integrating blocks 
    with a defined annular width and thickness in z at each angle. 
The resultant image contains lines corresponding to integrated blocks
    covering 360° of angle.
The sampling must be isotropic.
The origins within the sub-image structures are used.
The interpolation routine actually calculates the old cartesian 
coordinates for each set of cylindrical coordinates.
</pre> </dd></dl>

</div>
</div>
<a id="afe8d4e28cfbfe3c22d340b7e1d20fb77" name="afe8d4e28cfbfe3c22d340b7e1d20fb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8d4e28cfbfe3c22d340b7e1d20fb77">&#9670;&nbsp;</a></span>power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::power </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the power of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>power value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a073293aef6831dbcd752ec0b6335e55e" name="a073293aef6831dbcd752ec0b6335e55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073293aef6831dbcd752ec0b6335e55e">&#9670;&nbsp;</a></span>power_spectrum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::power_spectrum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a power spectrum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>1=norm, 2=avg, 4=shift, 8=log. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">All the sub-images are Fourier transformed.
The flags variable controls options base don which bits are set:
    1   normalize image before transformation
    2   average all power spectra
    4   shift the origin to the center
    8   calculate the logarithm of the power spectrum
</pre> </dd></dl>

</div>
</div>
<a id="a3f3d62db989c0a47443622038e615fb4" name="a3f3d62db989c0a47443622038e615fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3d62db989c0a47443622038e615fb4">&#9670;&nbsp;</a></span>powerspectrum_isotropy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; Bimage::powerspectrum_isotropy </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hires</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a measure of anisotropy in a poer spectrum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>sub-image number. </td></tr>
    <tr><td class="paramname">&amp;lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">&amp;hires</td><td>high resolution limit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt; 3-vlaue vector: power average and deviation and maximum power angle. The power between the indicated resolution shells are averaged for each angle and fitted to an equation for anisotropy: P = Pavg + Pdev*cos(2(a-phi)) where phi is the direction of maximum power. </dd></dl>

</div>
</div>
<a id="a62da7cb39c8509a277d4b60a0ad2eac7" name="a62da7cb39c8509a277d4b60a0ad2eac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62da7cb39c8509a277d4b60a0ad2eac7">&#9670;&nbsp;</a></span>powerspectrum_tiled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::powerspectrum_tiled </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>img_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>tile_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares a tiled power spectrum from an image for determining CTF parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_num</td><td>sub-image to transform. </td></tr>
    <tr><td class="paramname">tile_size</td><td>tile size (if (0,0,0) don't tile). </td></tr>
    <tr><td class="paramname">flags</td><td>1=norm, 2=avg, 4=shift, 8=log. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* power spectrum. <pre class="fragment">A large single image (a micrograph) is converted to a number of tiles
packed into a multi-image structure.
All the sub-images are Fourier transformed and the power spectra calculated.
The flag indicates if the images are normalized, averaged, shifted and
the logarithm calculated
</pre> </dd></dl>

</div>
</div>
<a id="ad0dd5e4008605164e43d404e3d82e02e" name="ad0dd5e4008605164e43d404e3d82e02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dd5e4008605164e43d404e3d82e02e">&#9670;&nbsp;</a></span>powerspectrum_tiled_and_tilted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::powerspectrum_tiled_and_tilted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>tile_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defocus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iCL2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares a tiled powerspectrum from a tilted image for determining CTF parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile_size</td><td>tile size (if (0,0,0) don't tile). </td></tr>
    <tr><td class="paramname">tilt_axis</td><td>tilt axis angle (in radians). </td></tr>
    <tr><td class="paramname">tilt_angle</td><td>tilt angle (in radians). </td></tr>
    <tr><td class="paramname">tilt_offset</td><td>offset perpendicular to tilt axis (in pixels). </td></tr>
    <tr><td class="paramname">defocus</td><td>average defocus to adjust for change in focus. </td></tr>
    <tr><td class="paramname">iCL2</td><td>inverse of product of spherical aberration and wavelenght squared. </td></tr>
    <tr><td class="paramname">flags</td><td>1=norm, 2=avg, 4=shift, 8=log, 16=add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* power spectrum. <pre class="fragment">A large single image (a micrograph) is converted to a number of tiles
packed into a multi-image structure.
All the sub-images are Fourier transformed and the power spectra calculated.
The power spectra are scaled based on the tilt and average defocus of the image.
The flag indicates if the images are normalized, averaged, shifted and
the logarithm calculated
</pre> </dd></dl>

</div>
</div>
<a id="a71ae17085d0e29552f960c53090b19fe" name="a71ae17085d0e29552f960c53090b19fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ae17085d0e29552f960c53090b19fe">&#9670;&nbsp;</a></span>powerspectrum_tilt_axis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::powerspectrum_tilt_axis </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>img_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>tile_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares a tiled powerspectrum from a tilted image for determining CTF parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_num</td><td>sub-image to transform. </td></tr>
    <tr><td class="paramname">tile_size</td><td>tile size (if (0,0,0) don't tile). </td></tr>
    <tr><td class="paramname">tilt_axis</td><td>tilt axis angle (in radians). </td></tr>
    <tr><td class="paramname">tilt_offset</td><td>offset perpendicular to tilt axis (in pixels). </td></tr>
    <tr><td class="paramname">flags</td><td>1=norm, 2=avg, 4=shift, 8=log. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* power spectrum. <pre class="fragment">A large single image (a micrograph) is converted to a number of tiles
along the tilt axis packed into a multi-image structure.
All the sub-images are Fourier transformed and the power spectra calculated.
The flag indicates if the images are normalized, averaged, shifted and
the logarithm calculated
</pre> </dd></dl>

</div>
</div>
<a id="ae4c0fe6b37b552146256828cb6f17624" name="ae4c0fe6b37b552146256828cb6f17624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c0fe6b37b552146256828cb6f17624">&#9670;&nbsp;</a></span>powerspectrum_tilted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::powerspectrum_tilted </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>img_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>tile_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defocus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iCL2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares a tiled powerspectrum from a tilted image for determining CTF parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_num</td><td>sub-image to transform. </td></tr>
    <tr><td class="paramname">tile_size</td><td>tile size (if (0,0,0) don't tile). </td></tr>
    <tr><td class="paramname">tilt_axis</td><td>tilt axis angle (in radians). </td></tr>
    <tr><td class="paramname">tilt_angle</td><td>tilt angle (in radians). </td></tr>
    <tr><td class="paramname">defocus</td><td>average defocus to adjust for change in focus. </td></tr>
    <tr><td class="paramname">iCL2</td><td>inverse of product of spherical aberration and wavelenght squared. </td></tr>
    <tr><td class="paramname">flags</td><td>1=norm, 2=avg, 4=shift, 8=log. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* power spectrum. <pre class="fragment">A large single image (a micrograph) is converted to a number of tiles
packed into a multi-image structure.
All the sub-images are Fourier transformed and the power spectra calculated.
The power spectra are scaled based on the tilt and average defocus of the image.
The flag indicates if the images are normalized, averaged, shifted and
the logarithm calculated
</pre> </dd></dl>

</div>
</div>
<a id="abed27819fb8388ae6954898e8c5aeea9" name="abed27819fb8388ae6954898e8c5aeea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed27819fb8388ae6954898e8c5aeea9">&#9670;&nbsp;</a></span>pps_angular_correlation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; Bimage::pps_angular_correlation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9881cc5ba252117b04982537fcade7ec" name="a9881cc5ba252117b04982537fcade7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9881cc5ba252117b04982537fcade7ec">&#9670;&nbsp;</a></span>progressive_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::progressive_sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Progressive sum of the sub-images. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">Each sub-image is summed with all previous sub-images.
</pre> </dd></dl>

</div>
</div>
<a id="a4afcc68b536924539893afa7797d9ff0" name="a4afcc68b536924539893afa7797d9ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afcc68b536924539893afa7797d9ff0">&#9670;&nbsp;</a></span>project() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::project </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects a 3D image to a 2D image down one of the three major axes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>axis of projection. </td></tr>
    <tr><td class="paramname">flags</td><td>1=scale projection, 2=minimum, 4=maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* projection image (floating point). <pre class="fragment">The sums of the z-planes are accumulated into a new floating point data 
block.  This block is then rescaled and converted back to the original 
data type.
The new data replaces the old data.
</pre> </dd></dl>

</div>
</div>
<a id="a32bf9144645aff8e54e84a345e5170bf" name="a32bf9144645aff8e54e84a345e5170bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bf9144645aff8e54e84a345e5170bf">&#9670;&nbsp;</a></span>project() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_s_i___kernel.html">FSI_Kernel</a> *&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wavelength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a set of projections as central sections from a 3D fourier transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*view</td><td>linked list of views. </td></tr>
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">*kernel</td><td>frequency space interpolation kernel. </td></tr>
    <tr><td class="paramname">wavelength</td><td>for Ewald sphere projection, default zero, ± for front or back curvature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* projections as sub-images. <pre class="fragment">The map is Fourier transformed and shifted to its phase origin.
For each view, a central section is calculated using reciprocal space interpolation.
All the projections are phase shifted to a central origin and back-transformed.
</pre> </dd></dl>

</div>
</div>
<a id="ab27d43f0379945a6d3fc67f8bfd7d895" name="ab27d43f0379945a6d3fc67f8bfd7d895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27d43f0379945a6d3fc67f8bfd7d895">&#9670;&nbsp;</a></span>project() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_flag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a set of projections from a 3D density map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*view</td><td>linked list of views. </td></tr>
    <tr><td class="paramname">norm_flag</td><td>flag to normalize projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* projections as sub-images. <pre class="fragment">A set of projections is calculated according to a list of views.
</pre> </dd></dl>

</div>
</div>
<a id="a82c60d383d623215c7803246f91a37c3" name="a82c60d383d623215c7803246f91a37c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c60d383d623215c7803246f91a37c3">&#9670;&nbsp;</a></span>pure_color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::pure_color </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a pure color image without intensity. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">Pure color is defined as:
            col
    col = --------
          sum(col)
</pre> </dd></dl>

</div>
</div>
<a id="a3e05702e10a44ce4cea8cb193d892740" name="a3e05702e10a44ce4cea8cb193d892740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e05702e10a44ce4cea8cb193d892740">&#9670;&nbsp;</a></span>quadric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::quadric </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a quadric surface over the whole image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>7-value array of parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="a0022ff9560c5435a775b17cda6859d21" name="a0022ff9560c5435a775b17cda6859d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0022ff9560c5435a775b17cda6859d21">&#9670;&nbsp;</a></span>quadric_correct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::quadric_correct </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Corrects for a quadric surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>7-value array of parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. </dd></dl>

</div>
</div>
<a id="a4374a6540837e7e0fb667ade95387125" name="a4374a6540837e7e0fb667ade95387125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4374a6540837e7e0fb667ade95387125">&#9670;&nbsp;</a></span>quadric_fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; Bimage::quadric_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fits the whole image to a quadric surface. </p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt; 7-value array of parameters. <pre class="fragment">A quadric surface is defined as:
v = a0 + a1*dx + a2*dy + a3*dz + a4*dx^2 + a5*dy^2 + a6*dz^2
</pre> </dd></dl>

</div>
</div>
<a id="a8d1a95f271379fca8636f8e1b68d74c4" name="a8d1a95f271379fca8636f8e1b68d74c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1a95f271379fca8636f8e1b68d74c4">&#9670;&nbsp;</a></span>query()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_j_svalue.html">JSvalue</a> * &gt; Bimage::query </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52206f5ade01f913c6c89ca6827abfec" name="a52206f5ade01f913c6c89ca6827abfec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52206f5ade01f913c6c89ca6827abfec">&#9670;&nbsp;</a></span>R_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::R_factor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an R factor between two images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>second image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double R factor, -1 if not run. <pre class="fragment">The difference between two images is calculated and normalized as:
                          sum(image1 - image2)^2
    R = sqrt(-------------------------------------------------)
             sqrt(sum(image1 - avg1)^2 * sum(image2 - avg2)^2)
Both images are converted to floating point.
</pre> </dd></dl>

</div>
</div>
<a id="a6ebe92011b255b290b14be60266b8632" name="a6ebe92011b255b290b14be60266b8632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ebe92011b255b290b14be60266b8632">&#9670;&nbsp;</a></span>radial() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::radial </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>minrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrap</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the radial average of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minrad</td><td>minimum radius in voxels. </td></tr>
    <tr><td class="paramname">maxrad</td><td>maximum radius in voxels. </td></tr>
    <tr><td class="paramname">rad_step</td><td>step size in voxels. </td></tr>
    <tr><td class="paramname">*pmask</td><td>mask to limit calculation. </td></tr>
    <tr><td class="paramname">wrap</td><td>flag to wrap the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* radial average in the form of a 1D image. <pre class="fragment">A radial average of a 2D or 3D image is calculated between a minimum
and maximum radius.  An interpolative method is used where the value of 
a voxel is distributed between the two nearest radial annuli.
The final sum in an annulus is normalized by the number of voxels 
contributing to the annulus sum.
The origins within the sub-image structures are used.
</pre> </dd></dl>

</div>
</div>
<a id="a9873d1561805e0845a44c24cf2b4d872" name="a9873d1561805e0845a44c24cf2b4d872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9873d1561805e0845a44c24cf2b4d872">&#9670;&nbsp;</a></span>radial() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::radial </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>minrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ellipticity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrap</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the radial average of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minrad</td><td>minimum radius in voxels. </td></tr>
    <tr><td class="paramname">maxrad</td><td>maximum radius in voxels. </td></tr>
    <tr><td class="paramname">rad_step</td><td>step size in voxels. </td></tr>
    <tr><td class="paramname">ellipticity</td><td>ratio of major and minor axes. </td></tr>
    <tr><td class="paramname">angle</td><td>angle of major axis. </td></tr>
    <tr><td class="paramname">*pmask</td><td>mask to limit calculation. </td></tr>
    <tr><td class="paramname">wrap</td><td>flag to wrap the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* radial average in the form of a 1D image. <pre class="fragment">A radial average of a 2D or 3D image is calculated between a minimum
and maximum radius.  An interpolative method is used where the value of 
a voxel is distributed between the two nearest radial annuli.
The final sum in an annulus is normalized by the number of voxels 
contributing to the annulus sum.
The origins within the sub-image structures are used.
</pre> </dd></dl>

</div>
</div>
<a id="a7e58dfcfdf34ccd506bed0d3ef5b4db5" name="a7e58dfcfdf34ccd506bed0d3ef5b4db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e58dfcfdf34ccd506bed0d3ef5b4db5">&#9670;&nbsp;</a></span>radial() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::radial </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>minrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_step</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrap</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the radial average of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minrad</td><td>minimum radius in voxels. </td></tr>
    <tr><td class="paramname">maxrad</td><td>maximum radius in voxels. </td></tr>
    <tr><td class="paramname">rad_step</td><td>step size in voxels. </td></tr>
    <tr><td class="paramname">wrap</td><td>flag to wrap the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* radial average in the form of a 1D image. <pre class="fragment">A radial average of a 2D or 3D image is calculated between a minimum
and maximum radius.  An interpolative method is used where the value of 
a voxel is distributed between the two nearest radial annuli.
The final sum in an annulus is normalized by the number of voxels 
contributing to the annulus sum.
The origins within the sub-image structures are used.
</pre> </dd></dl>

</div>
</div>
<a id="a2a29bbf90a10dd26c13974ba24320196" name="a2a29bbf90a10dd26c13974ba24320196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a29bbf90a10dd26c13974ba24320196">&#9670;&nbsp;</a></span>radial_coverage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::radial_coverage </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the coverage in each radial shell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>density threshold to distinguish for- and background. </td></tr>
    <tr><td class="paramname">rad_step</td><td>radial step size (voxels). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="adf4764ac2099326f8550a9f85f9e8290" name="adf4764ac2099326f8550a9f85f9e8290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4764ac2099326f8550a9f85f9e8290">&#9670;&nbsp;</a></span>radial_fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * Bimage::radial_fit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fits a radial profile to a reference radial profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pref</td><td>reference radial profile as a 1D image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double* 3-value result vector: dimension scale, amplitude scale and amplitude shift. <pre class="fragment">A radial profile is fitted to a reference profile using an iterative
simplex down-hill method.  The equations solved are:
    x(new) = x(old)*m
    y(new) = y(old)*a + b
where   m is the dimension scaling (or magnification).
        a is the amplitude scaling.
        b is the amplitude shift.
</pre> </dd></dl>

</div>
</div>
<a id="a5a73644b93a8f9033ada10246f952e0a" name="a5a73644b93a8f9033ada10246f952e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a73644b93a8f9033ada10246f952e0a">&#9670;&nbsp;</a></span>radial_sections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::radial_sections </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>spherical_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code><a class="el" href="utilities_8h.html#ae8a4ca63176786d1254d05591419ba9c">FILL_USER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an image with slices giving the radial section projections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rad_start</td><td>starting radius (voxels). </td></tr>
    <tr><td class="paramname">rad_end</td><td>ending radius (voxels). </td></tr>
    <tr><td class="paramname">rad_step</td><td>radial step size (voxels). </td></tr>
    <tr><td class="paramname">spherical_fraction</td><td>fraction of spherical section (requires symmetry). </td></tr>
    <tr><td class="paramname">*sym</td><td>symmetry for non-spherical sections. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>value to fill in excluded regions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* image with radial sections. <pre class="fragment">The 3D image is converted so that the sections contain 2D projections
of radial shells. The projection in slice i is defined for:
    i &gt;= sqrt(x^2 + y^2)
Non-spherical sections can be generated by specifying the symmetry and
the fraction of spherical nature (1=spherical, 0=based on symmetry).
Sampling in x and y is not changed.
The sampling in the input map must be isotropic.
</pre> </dd></dl>

</div>
</div>
<a id="a886dcdd400fd1e7a920975dad3c43835" name="a886dcdd400fd1e7a920975dad3c43835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886dcdd400fd1e7a920975dad3c43835">&#9670;&nbsp;</a></span>radial_shells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::radial_shells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an image with slices representing radial shell projections. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The 3D image is converted so that the sections contain 2D projections
of radial shells. The projection in slice z is defined for:
    z &gt;= sqrt((x-xo)^2 + (y-yo)^2) + zo
The first projection is placed at the z origin and radiates out into
both positive and negative directions.
Sampling in x and y is not changed.
The sampling must be isotropic.
</pre> </dd></dl>

</div>
</div>
<a id="a8e666b9c155a9929050dcf4b0f339789" name="a8e666b9c155a9929050dcf4b0f339789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e666b9c155a9929050dcf4b0f339789">&#9670;&nbsp;</a></span>radial_symmetry_adjusted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::radial_symmetry_adjusted </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>spherical_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the symmetry-adjusted radial average of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rad_start</td><td>minimum radius in voxels. </td></tr>
    <tr><td class="paramname">rad_end</td><td>maximum radius in voxels. </td></tr>
    <tr><td class="paramname">rad_step</td><td>step size in voxels. </td></tr>
    <tr><td class="paramname">spherical_fraction</td><td>ratio of major and minor axes. </td></tr>
    <tr><td class="paramname">*sym</td><td>point group symmetry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* radial average in the form of a 1D image. <pre class="fragment">A radial average of a 2D or 3D image is calculated between a minimum
and maximum radius.  An interpolative method is used where the value of
a voxel is distributed between the two nearest radial annuli.
The final sum in an annulus is normalized by the number of voxels
contributing to the annulus sum.
The symmetry is used to adjust the radius to follow the contours of a shell.
The origins within the sub-image structures are used.
</pre> </dd></dl>

</div>
</div>
<a id="a47f717fb32a8f0dc296581f6987e5c23" name="a47f717fb32a8f0dc296581f6987e5c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f717fb32a8f0dc296581f6987e5c23">&#9670;&nbsp;</a></span>radial_to_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::radial_to_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a full 2D or 3D image from a radial profile in a 1D image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>size of image to expand to. </td></tr>
    <tr><td class="paramname">origin</td><td>origin for radial profile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new 2D or 3D image. <pre class="fragment">It assumes the resultant image is square or cubic.
</pre> </dd></dl>

</div>
</div>
<a id="aa758e00d61b0cf27d877e46a8054d93c" name="aa758e00d61b0cf27d877e46a8054d93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa758e00d61b0cf27d877e46a8054d93c">&#9670;&nbsp;</a></span>read_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * Bimage::read_data </td>
          <td>(</td>
          <td class="paramtype">ifstream *&#160;</td>
          <td class="paramname"><em>fimg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>img_select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read image data in a generalized style. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*fimg</td><td>file descriptor: file opened in calling function. </td></tr>
    <tr><td class="paramname">img_select</td><td>image selection: if -1, all images, if &gt;= 0, one image. </td></tr>
    <tr><td class="paramname">sb</td><td>flag activates byte swapping. </td></tr>
    <tr><td class="paramname">vax</td><td>indicate vax style floating point - activates conversion. </td></tr>
    <tr><td class="paramname">pad</td><td>any interspersed control or separation bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned char* data pointer, NULL if reading failed. The whole file or a single image from a file may be read. The data is read in the largest blocks possible for efficiency. Any interspersed padding and page sizes not matching the data size contribute to inefficiency in reading. Swapping: sb = 1: swap bytes the size of the data type sb &gt; 1: swap these number of bytes regardless of the data type </dd></dl>

</div>
</div>
<a id="a4430e9d49a8accb2a3063f358b634d64" name="a4430e9d49a8accb2a3063f358b634d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4430e9d49a8accb2a3063f358b634d64">&#9670;&nbsp;</a></span>real_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::real_coordinates </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af318fb13b1b1086f6019982d1bed9f88" name="af318fb13b1b1086f6019982d1bed9f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af318fb13b1b1086f6019982d1bed9f88">&#9670;&nbsp;</a></span>real_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::real_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6dd5f8f962afb07c80b14efbf922a29" name="ad6dd5f8f962afb07c80b14efbf922a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dd5f8f962afb07c80b14efbf922a29">&#9670;&nbsp;</a></span>reciprocal_half()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; Bimage::reciprocal_half </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b36e3e577be485764fd630ed6cd4134" name="a5b36e3e577be485764fd630ed6cd4134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b36e3e577be485764fd630ed6cd4134">&#9670;&nbsp;</a></span>red_white_blue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::red_white_blue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>red_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>white_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>white_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>blue_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Colorizes an image with blue positive and red negative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">red_min</td><td>beginning of red gradient (most negative). </td></tr>
    <tr><td class="paramname">white_min</td><td>end of red gradient (fade into white). </td></tr>
    <tr><td class="paramname">white_max</td><td>beginning of blue gradient (start with white). </td></tr>
    <tr><td class="paramname">blue_max</td><td>end of blue gradient (most positive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* color scale image. <pre class="fragment">A grayscale image is converted to RGB and colored with blue positive, 
red negative, and white in between.
</pre> </dd></dl>

</div>
</div>
<a id="a0fab637fb5be036d3821df66f90559ba" name="a0fab637fb5be036d3821df66f90559ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fab637fb5be036d3821df66f90559ba">&#9670;&nbsp;</a></span>refine_peak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::refine_peak </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines the position of a peak to sub-voxel resolution. </p>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">The sub-voxel resolution peak in the vicinity of a voxel is defined 
by fitting a 2D/3D second order function around the voxel.
(typically used to find the shift vector in a cross-correlation map).
</pre> </dd></dl>

</div>
</div>
<a id="ae8655ec31cdfa4008f2cd15e5810300b" name="ae8655ec31cdfa4008f2cd15e5810300b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8655ec31cdfa4008f2cd15e5810300b">&#9670;&nbsp;</a></span>refine_peak_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::refine_peak_new </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines the position of a peak to sub-voxel resolution. </p>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">The sub-voxel resolution peak in the vicinity of a voxel is defined 
by fitting a 2D/3D second order function around the voxel.
(typically used to find the shift vector in a cross-correlation map).
</pre> </dd></dl>

</div>
</div>
<a id="a7c44ca1140db2f36355ae99a0d0e933a" name="a7c44ca1140db2f36355ae99a0d0e933a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c44ca1140db2f36355ae99a0d0e933a">&#9670;&nbsp;</a></span>region_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::region_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>region_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all the pixels that are part of the same region. </p>
<dl class="section author"><dt>Author</dt><dd>Bernard Heymann and Samuel Payne </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>a mask holding region assignments. </td></tr>
    <tr><td class="paramname">idx</td><td>the first voxel of a region. </td></tr>
    <tr><td class="paramname">region_number</td><td>the region number that voxels are assigned. </td></tr>
    <tr><td class="paramname">threshold</td><td>the level to define background. </td></tr>
    <tr><td class="paramname">sign</td><td>sign controlling direction of thresholding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">This method uses a list to keep track of voxels assigned to a region.
In subsequent iterations the non-assigned voxels next to those in
the list are assigned if they exceed the threshold, and their indices
are kept in a new list. The new list is transferred to the old list
and the process iteratively continued until the new list contains
no more voxels.
</pre> </dd></dl>

</div>
</div>
<a id="ab0e749d2074b4a2e493324e9b526c4e0" name="ab0e749d2074b4a2e493324e9b526c4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e749d2074b4a2e493324e9b526c4e0">&#9670;&nbsp;</a></span>region_flood()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::region_flood </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_borders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and expands a region map from a starting to ending threshold value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>region map (if NULL, generate from high threshold). </td></tr>
    <tr><td class="paramname">threshold_hi</td><td>the level to pick initial regions. </td></tr>
    <tr><td class="paramname">threshold_lo</td><td>the lowest level to include voxels in regions. </td></tr>
    <tr><td class="paramname">threshold_step</td><td>the incremental change in threshold. </td></tr>
    <tr><td class="paramname">fill_borders</td><td>flag to assign borders between regions (default not). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of regions. <pre class="fragment">A region map is calculated at the threshold furthest from the average.
The region map is then expanded by lowering the threshold gradually 
and assigning newly included voxels to neighboring regions (i.e., flooding).
Voxels with neighbours assigned to two or more different regions are tagged
as indeterminate to indicate borders between regions. These border voxels
are counted and can be used to estimate the extent of interfaces.
The indices of all the final regions are packed into an integer data block
within a new image.
The image is assumed to have high values for objects (i.e., density is white).
</pre> </dd></dl>

</div>
</div>
<a id="a97e5ef2e7188a1ba225d6f2c31932686" name="a97e5ef2e7188a1ba225d6f2c31932686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e5ef2e7188a1ba225d6f2c31932686">&#9670;&nbsp;</a></span>region_peaks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::region_peaks </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flood</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrap</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a segmented image from peaks above a threshold value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel_size</td><td>size of kernel to determine peaks. </td></tr>
    <tr><td class="paramname">threshold</td><td>the lowest level to include voxels in regions. </td></tr>
    <tr><td class="paramname">flood</td><td>flag to flood to the threshold. </td></tr>
    <tr><td class="paramname">wrap</td><td>flag to wrap the kernel around image boundaries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* integer image containing region index numbers. <pre class="fragment">Every voxel with a value above the threshold is tagged by a pointer 
pointing to the highest value within a kernel. 
A peak is defined as pointing to itself, while every other voxel
points towards a peak.
The voxels in the mask are then iteratively assigned to the peaks
they point to.
The indices of all the final regions are packed into an integer data block
within a new image.
</pre> </dd></dl>

</div>
</div>
<a id="a5480279ea3c3895fb01a20ffb1839ce7" name="a5480279ea3c3895fb01a20ffb1839ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5480279ea3c3895fb01a20ffb1839ce7">&#9670;&nbsp;</a></span>region_threshold_series()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::region_threshold_series </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segments a map through a series of thresholds and reports results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold_first</td><td>the level to pick initial regions. </td></tr>
    <tr><td class="paramname">threshold_last</td><td>the lowest level to include voxels in regions. </td></tr>
    <tr><td class="paramname">threshold_step</td><td>the incremental change in threshold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="ac55bb02394e154f3b19519c3be2c8c98" name="ac55bb02394e154f3b19519c3be2c8c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55bb02394e154f3b19519c3be2c8c98">&#9670;&nbsp;</a></span>regions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::regions </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segments an image into contiguous regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>the level at which things are ignored. </td></tr>
    <tr><td class="paramname">sign</td><td>sign controlling direction of thresholding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* level mask with indexed regions. <pre class="fragment">The image is segmented into contiguous regions where a region is 
defined as all those voxels exceeding the given threshold and
adjacent to each other.
This method uses a list to keep track of voxels assigned to a region.
In subsequent iterations the non-assigned voxels next to those in
the list are assigned if they exceed the threshold, and their indices
are kept in a new list. The new list is transferred to the old list
and the process iteratively continued until the new list contains
no more voxels. The indices of all the regions are packed into
an integer data block within a new image.
The new image maps the indices of the regions starting from one to as
many regions as were found (the maximum gives the number of regions).
The new image has zeroes for all voxels outside the regions.
</pre> </dd></dl>

</div>
</div>
<a id="a53c0e1a29c59f66cea84af7fbc18fd14" name="a53c0e1a29c59f66cea84af7fbc18fd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c0e1a29c59f66cea84af7fbc18fd14">&#9670;&nbsp;</a></span>relative_density()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::relative_density </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the relative density in a region defined by a mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>a 4 level mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double relative density. <pre class="fragment">The mask is assumed to have 4 levels:
0       region of no interest
1       region to estimate relative density
2       reference region
3       background region
</pre> </dd></dl>

</div>
</div>
<a id="a3e690ba847608adfe186083d63e0a8f8" name="a3e690ba847608adfe186083d63e0a8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e690ba847608adfe186083d63e0a8f8">&#9670;&nbsp;</a></span>replace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the data with that from the given image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*img</td><td>source image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The input image must be the same size as the receiving image.
</pre> </dd></dl>

</div>
</div>
<a id="a9898fd3b514d2f774ddd72c2673450a0" name="a9898fd3b514d2f774ddd72c2673450a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9898fd3b514d2f774ddd72c2673450a0">&#9670;&nbsp;</a></span>replace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::replace </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces one sub-image in an image structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number to replace. </td></tr>
    <tr><td class="paramname">*img</td><td>source image. </td></tr>
    <tr><td class="paramname">nr</td><td>source sub-image number. </td></tr>
    <tr><td class="paramname">fill</td><td>fill vlue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The input image may have a different size as the receiving image.
</pre> </dd></dl>

</div>
</div>
<a id="a42023ed856fd661419b1d2ac9d4f7508" name="a42023ed856fd661419b1d2ac9d4f7508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42023ed856fd661419b1d2ac9d4f7508">&#9670;&nbsp;</a></span>replace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::replace </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces one sub-image in an image structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image number to replace. </td></tr>
    <tr><td class="paramname">*img</td><td>source image. </td></tr>
    <tr><td class="paramname">nr</td><td>source sub-image number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The input image must be the same size as the receiving image.
</pre> </dd></dl>

</div>
</div>
<a id="a2f42862e052c422dc5868b9b1234cd5d" name="a2f42862e052c422dc5868b9b1234cd5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f42862e052c422dc5868b9b1234cd5d">&#9670;&nbsp;</a></span>replace_maxima()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::replace_maxima </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces maxima above a threshold using local averages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>threshold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of voxels replaced. <pre class="fragment">The image is first segemented into regions, each defined as a 
contiguous cluster of voxels with values above the threshold. 
Each region is encoded in an integer image, with all the values
in this image set to the indices of the regions, or zero elsewhere.
The regions are iteratively filled in, where in every iteration, 
the border values of the regions are replaced by the average 
of the neighbouring voxels outside the region. After each iteration, 
every region is shrunk by excluding the newly replaced voxels.
</pre> </dd></dl>

</div>
</div>
<a id="a2051e36bed46213a60d8c727a8e4fd6e" name="a2051e36bed46213a60d8c727a8e4fd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2051e36bed46213a60d8c727a8e4fd6e">&#9670;&nbsp;</a></span>replicate_asymmetric_unit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::replicate_asymmetric_unit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a full map from one asymmetric unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*sym</td><td>symmetry structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">A reference view for each point group is generated such that it is
located close to the center of the canonical asymmetric unit.
For each voxel in the target map, a set of symmetry-related views 
are generated and the one closest to the reference view used
to determine the corresponding voxels within the asymmetric unit.
The new voxel value is calculated by trilinear interpolation of the
voxels in the asymmetric unit. 
</pre> </dd></dl>

</div>
</div>
<a id="a9b7833cb5588bdc30b2a46f45eaf3224" name="a9b7833cb5588bdc30b2a46f45eaf3224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7833cb5588bdc30b2a46f45eaf3224">&#9670;&nbsp;</a></span>rescale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rescale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescales the image data with a given multiplier and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>multiplier. </td></tr>
    <tr><td class="paramname">shift</td><td>addition or offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">The new data is calculated as:
    new_datum = datum*scale + shift
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="ac4a76e101fc59bdcabd5f3bb4299955e" name="ac4a76e101fc59bdcabd5f3bb4299955e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a76e101fc59bdcabd5f3bb4299955e">&#9670;&nbsp;</a></span>rescale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rescale </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescales the image data with a given multiplier and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">scale</td><td>multiplier. </td></tr>
    <tr><td class="paramname">shift</td><td>addition or offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">Requirement: The images must have the same size.
</pre> </dd></dl>

</div>
</div>
<a id="aa480cb0fa61541df90440f2e929142ce" name="aa480cb0fa61541df90440f2e929142ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa480cb0fa61541df90440f2e929142ce">&#9670;&nbsp;</a></span>rescale_to_avg_std() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rescale_to_avg_std </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nuavg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nustd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescales the image data to a given average and standard deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nuavg</td><td>new average. </td></tr>
    <tr><td class="paramname">nustd</td><td>new standard deviation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">The new data is calculated as:
                                new_std_dev
    new_datum = (datum - avg) * ----------- + new_avg
                                  std_dev
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="ace3199a5d7bb5c9ea9fcd544e67dff6b" name="ace3199a5d7bb5c9ea9fcd544e67dff6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3199a5d7bb5c9ea9fcd544e67dff6b">&#9670;&nbsp;</a></span>rescale_to_avg_std() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rescale_to_avg_std </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nuavg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nustd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescales the image data to a given average and standard deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nuavg</td><td>new average. </td></tr>
    <tr><td class="paramname">nustd</td><td>new standard deviation. </td></tr>
    <tr><td class="paramname">*pmask</td><td>statistical calculations limited to the masked region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">The new data is calculated as:
                                new_std_dev
    new_datum = (datum - avg) * ----------- + new_avg
                                  std_dev
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="abda4a7e4de4efa8b83f0a1ef6445da09" name="abda4a7e4de4efa8b83f0a1ef6445da09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda4a7e4de4efa8b83f0a1ef6445da09">&#9670;&nbsp;</a></span>rescale_to_avg_std() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rescale_to_avg_std </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nuavg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nustd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescales the image data to a given average and standard deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">nuavg</td><td>new average. </td></tr>
    <tr><td class="paramname">nustd</td><td>new standard deviation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">The new data is calculated as:
                                new_std_dev
    new_datum = (datum - avg) * ----------- + new_avg
                                  std_dev
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a6a5bdce631807ed399818c368aa246f4" name="a6a5bdce631807ed399818c368aa246f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5bdce631807ed399818c368aa246f4">&#9670;&nbsp;</a></span>rescale_to_min_max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rescale_to_min_max </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>numin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>numax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescales the image data to a given minimum and maximum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numin</td><td>new minimum. </td></tr>
    <tr><td class="paramname">numax</td><td>new maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">The new data is calculated as:
                                new_max - new_min
    new_datum = (datum - min) * ----------------- + new_min
                                    max - min
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="ae86c101a63bbebc20a1a83b359e4c898" name="ae86c101a63bbebc20a1a83b359e4c898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86c101a63bbebc20a1a83b359e4c898">&#9670;&nbsp;</a></span>rescale_to_min_max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rescale_to_min_max </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>numin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>numax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescales the image data to a given minimum and maximum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">numin</td><td>new minimum. </td></tr>
    <tr><td class="paramname">numax</td><td>new maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. <pre class="fragment">The new data is calculated as:
                                new_max - new_min
    new_datum = (datum - min) * ----------------- + new_min
                                    max - min
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="aa92d1c8b78e7032d0810e50691308d6a" name="aa92d1c8b78e7032d0810e50691308d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92d1c8b78e7032d0810e50691308d6a">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>translate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes without interpolation or rescaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>new image size three-value vector. </td></tr>
    <tr><td class="paramname">translate</td><td>three-value translation vector. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER </td></tr>
    <tr><td class="paramname">fill</td><td>value to fill in new regions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">An image is resized with translation and filling of new regions with 
a given value.
</pre> </dd></dl>

</div>
</div>
<a id="aceac93b83e083d4149e77dc87b21d468" name="aceac93b83e083d4149e77dc87b21d468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceac93b83e083d4149e77dc87b21d468">&#9670;&nbsp;</a></span>resize_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::resize_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>translate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes without interpolation or rescaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>new image size three-value vector. </td></tr>
    <tr><td class="paramname">translate</td><td>three-value translation vector. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER </td></tr>
    <tr><td class="paramname">fill</td><td>value to fill in new regions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* resized image. <pre class="fragment">An image is resized with translation and filling of new regions with 
a given value.
</pre> </dd></dl>

</div>
</div>
<a id="a9e6f5ec793f21d082df60e9365eeb417" name="a9e6f5ec793f21d082df60e9365eeb417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6f5ec793f21d082df60e9365eeb417">&#9670;&nbsp;</a></span>resize_wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::resize_wrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>translate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes without interpolation or rescaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>new image size three-value vector. </td></tr>
    <tr><td class="paramname">translate</td><td>three-value translation vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">An image is resized with translation and filling of new regions with 
a given value.
</pre> </dd></dl>

</div>
</div>
<a id="a34ad16a7706778bce66dc7caf93ceea0" name="a34ad16a7706778bce66dc7caf93ceea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ad16a7706778bce66dc7caf93ceea0">&#9670;&nbsp;</a></span>resize_wrap_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::resize_wrap_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>translate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes with wrapping without interpolation or rescaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>new image size three-value vector. </td></tr>
    <tr><td class="paramname">translate</td><td>three-value translation vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* resized image. <pre class="fragment">An image is resized with translation and filling of new regions with 
a given value.
</pre> </dd></dl>

</div>
</div>
<a id="ad5ed5dc6affb2312432591d328c6d27b" name="ad5ed5dc6affb2312432591d328c6d27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ed5dc6affb2312432591d328c6d27b">&#9670;&nbsp;</a></span>reslice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::reslice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a>&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches axes of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>string encoding the reslicing order. <pre class="fragment">Reslicing refers to switching the axes of a multidimensional image.
The equivalent is rotation around angles that are multiples of pi/2.
The reslicing is encoded as a string of x, y and z, with the order
and sign indicating the type of reslicing to be done.
The new data replaces the old data.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46db3bd25b8e4a6477a4ef686604ceab" name="a46db3bd25b8e4a6477a4ef686604ceab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46db3bd25b8e4a6477a4ef686604ceab">&#9670;&nbsp;</a></span>reslice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::reslice </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d625d181159abc9d151369048f20733" name="a2d625d181159abc9d151369048f20733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d625d181159abc9d151369048f20733">&#9670;&nbsp;</a></span>resolution_prepare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::resolution_prepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeebfb1d152e36bd7aaf0b7549ba7bc6e" name="aeebfb1d152e36bd7aaf0b7549ba7bc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebfb1d152e36bd7aaf0b7549ba7bc6e">&#9670;&nbsp;</a></span>resolution_prepare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::resolution_prepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d343109d74d589f4fc4ce873b4f9e03" name="a2d343109d74d589f4fc4ce873b4f9e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d343109d74d589f4fc4ce873b4f9e03">&#9670;&nbsp;</a></span>rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_g_b.html">RGB</a>&lt; double &gt; Bimage::rgb </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a color value at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RGB&lt;double&gt; the color value. <pre class="fragment">The index refers to compound values.
</pre> </dd></dl>

</div>
</div>
<a id="ae66b4728fbd4a4338eb41ab606915fb4" name="ae66b4728fbd4a4338eb41ab606915fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66b4728fbd4a4338eb41ab606915fb4">&#9670;&nbsp;</a></span>rgb_to_cmyk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::rgb_to_cmyk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="class_r_g_b.html">RGB</a> color image to <a class="el" href="class_c_m_y_k.html">CMYK</a>. </p>

</div>
</div>
<a id="a0c7ab28a033eb07c2c62b38044affdfa" name="a0c7ab28a033eb07c2c62b38044affdfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7ab28a033eb07c2c62b38044affdfa">&#9670;&nbsp;</a></span>rgb_to_rgba()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::rgb_to_rgba </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alpha channel is added to a <a class="el" href="class_r_g_b.html">RGB</a> color image. </p>
<pre class="fragment">The alpha channel value is set to 255.
</pre> 
</div>
</div>
<a id="a7bffddc51e0a60f24d2768534501f9d7" name="a7bffddc51e0a60f24d2768534501f9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bffddc51e0a60f24d2768534501f9d7">&#9670;&nbsp;</a></span>rgba()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_g_b_a.html">RGBA</a>&lt; double &gt; Bimage::rgba </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a color value at the given index. </p>
<pre class="fragment">The index refers to compound values.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RGBA&lt;double&gt; the color value. </dd></dl>

</div>
</div>
<a id="a99a75c617a560025a571c7635b7f015a" name="a99a75c617a560025a571c7635b7f015a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a75c617a560025a571c7635b7f015a">&#9670;&nbsp;</a></span>rgba_to_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::rgba_to_rgb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The alpha channel is delete from an <a class="el" href="class_r_g_b_a.html">RGBA</a> color image. </p>

</div>
</div>
<a id="a88866b740da67ec07103b1d342cc3a98" name="a88866b740da67ec07103b1d342cc3a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88866b740da67ec07103b1d342cc3a98">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rotate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image using parameters defined in the image in place. </p>
<dl class="section return"><dt>Returns</dt><dd>0 error code. <pre class="fragment">The image is rotated according to the view and origin encoded
for the sub-image.
</pre> </dd></dl>

</div>
</div>
<a id="ab27f87167748ab84725b81c74438b932" name="ab27f87167748ab84725b81c74438b932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27f87167748ab84725b81c74438b932">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rotate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image around the z-axis by the given angle in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>rotation angle in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 error code. <pre class="fragment">The image is rotated according to the axis and angle given.
</pre> </dd></dl>

</div>
</div>
<a id="ad6256d410696b7e3294809706e015efe" name="ad6256d410696b7e3294809706e015efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6256d410696b7e3294809706e015efe">&#9670;&nbsp;</a></span>rotate() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image using the specified matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>3x3 rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 error code. <pre class="fragment">An image is rotated according to the input matrix.
The input image origin is the rotation center.
</pre> </dd></dl>

</div>
</div>
<a id="adc92a9f1c9ff02d2c22b9e7a9ffb1be4" name="adc92a9f1c9ff02d2c22b9e7a9ffb1be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc92a9f1c9ff02d2c22b9e7a9ffb1be4">&#9670;&nbsp;</a></span>rotate() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image using an axis and angle in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>3-value rotation axis. </td></tr>
    <tr><td class="paramname">angle</td><td>rotation angle in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 error code. <pre class="fragment">The image is rotated according to the axis and angle given.
</pre> </dd></dl>

</div>
</div>
<a id="aac8847c323035bc8efc85d9f8de52baf" name="aac8847c323035bc8efc85d9f8de52baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8847c323035bc8efc85d9f8de52baf">&#9670;&nbsp;</a></span>rotate() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>translate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image using the specified shift and matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translate</td><td>translation after rotation. </td></tr>
    <tr><td class="paramname">mat</td><td>3x3 rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 error code. <pre class="fragment">An image is rotated according to the input view vector and angle. 
The input image origin is the rotation center.
The rotated image is translated to the input origin.
</pre> </dd></dl>

</div>
</div>
<a id="ad2c655354c84a54ec1b4bd71c8af60be" name="ad2c655354c84a54ec1b4bd71c8af60be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c655354c84a54ec1b4bd71c8af60be">&#9670;&nbsp;</a></span>rotate() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>translate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image to a specified view in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translate</td><td>translation after rotation. </td></tr>
    <tr><td class="paramname">*view</td><td>view vector and angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 error code. <pre class="fragment">An image is rotated according to the input view vector and angle. 
The input image origin is the rotation center.
The rotated image is translated to the input origin.
</pre> </dd></dl>

</div>
</div>
<a id="a6607d768271a95c3b9f35933e991ad2e" name="a6607d768271a95c3b9f35933e991ad2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6607d768271a95c3b9f35933e991ad2e">&#9670;&nbsp;</a></span>rotate() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image using parameters defined in the image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>3-value new image size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* rotated image. <pre class="fragment">The image is rotated according to the view and origin encoded
for the sub-image.
</pre> </dd></dl>

</div>
</div>
<a id="ab7b52ec12fd191c8f312cfa658fca1ba" name="ab7b52ec12fd191c8f312cfa658fca1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b52ec12fd191c8f312cfa658fca1ba">&#9670;&nbsp;</a></span>rotate() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image around the z-axis by the given angle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>3-value new image size. </td></tr>
    <tr><td class="paramname">angle</td><td>rotation angle in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* rotated image. <pre class="fragment">The image is rotated according to the axis and angle given.
</pre> </dd></dl>

</div>
</div>
<a id="aa27ac57c3c18d91f290b3881d2f29d95" name="aa27ac57c3c18d91f290b3881d2f29d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27ac57c3c18d91f290b3881d2f29d95">&#9670;&nbsp;</a></span>rotate() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image using the specified matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>new image size. </td></tr>
    <tr><td class="paramname">mat</td><td>3x3 rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* rotated image. <pre class="fragment">An image is rotated according to the input matrix.
The input image origin is the rotation center.
</pre> </dd></dl>

</div>
</div>
<a id="af9c535401a34f4be682c0cedc8de5237" name="af9c535401a34f4be682c0cedc8de5237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c535401a34f4be682c0cedc8de5237">&#9670;&nbsp;</a></span>rotate() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image using an axis and angle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>3-value new image size. </td></tr>
    <tr><td class="paramname">axis</td><td>3-value rotation axis. </td></tr>
    <tr><td class="paramname">angle</td><td>rotation angle in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* rotated image. <pre class="fragment">The image is rotated according to the axis and angle given.
</pre> </dd></dl>

</div>
</div>
<a id="a0e3c27171aa545d21f78bf9053bb5055" name="a0e3c27171aa545d21f78bf9053bb5055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3c27171aa545d21f78bf9053bb5055">&#9670;&nbsp;</a></span>rotate() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>translate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image to a specified view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>3-value new image size. </td></tr>
    <tr><td class="paramname">translate</td><td>translation after rotation. </td></tr>
    <tr><td class="paramname">*view</td><td>view vector and angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* rotated image. <pre class="fragment">An image is rotated according to the input view vector and angle. 
The input image origin is the rotation center.
The rotated image is translated to the input origin.
</pre> </dd></dl>

</div>
</div>
<a id="a3e899df9053f40b4f83f2f2398c79629" name="a3e899df9053f40b4f83f2f2398c79629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e899df9053f40b4f83f2f2398c79629">&#9670;&nbsp;</a></span>rotate() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image to a specified view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>3-value new image size. </td></tr>
    <tr><td class="paramname">*view</td><td>view vector and angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* rotated image. <pre class="fragment">An image is rotated according to the input view vector and angle. 
The input image origin is the rotation center.
The rotated image is translated to the input origin.
</pre> </dd></dl>

</div>
</div>
<a id="a7bf45aa1df7f0171cc46ffaf00d4507a" name="a7bf45aa1df7f0171cc46ffaf00d4507a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf45aa1df7f0171cc46ffaf00d4507a">&#9670;&nbsp;</a></span>rotate() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image to a specified view in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*view</td><td>view vector and angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 error code. <pre class="fragment">An image is rotated according to the input view vector and angle. 
The input image origin is the rotation center.
The rotated image is translated to the input origin.
</pre> </dd></dl>

</div>
</div>
<a id="ad873912e785241f662e91058d513cc91" name="ad873912e785241f662e91058d513cc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad873912e785241f662e91058d513cc91">&#9670;&nbsp;</a></span>rotate_and_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::rotate_and_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image to a specified view and adds it to another image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>the image to rotate and add (modified). </td></tr>
    <tr><td class="paramname">origin</td><td>origin in input image. </td></tr>
    <tr><td class="paramname">*view</td><td>view vector and angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">An image is rotated according to the input view vector and angle. 
The input image origin is the rotation center.
The rotated image is translated to the input origin.
The result is added to the current image.
</pre> </dd></dl>

</div>
</div>
<a id="aa0e7e96e701d68bc872693a78aa74c8f" name="aa0e7e96e701d68bc872693a78aa74c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e7e96e701d68bc872693a78aa74c8f">&#9670;&nbsp;</a></span>rotate_correlate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::rotate_correlate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates a copy of an image and correlates it with the original. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>rotation axis. </td></tr>
    <tr><td class="paramname">angle</td><td>rotation angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double correlation coefficient, -1 if error. <pre class="fragment">This mainly used to determine the symmetry of a map.
</pre> </dd></dl>

</div>
</div>
<a id="a7169f09ebd58457a19368b08bf994833" name="a7169f09ebd58457a19368b08bf994833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7169f09ebd58457a19368b08bf994833">&#9670;&nbsp;</a></span>rotate_cross_correlate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::rotate_cross_correlate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>search_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f5f4a66f61f68ea7af007429c246baa" name="a7f5f4a66f61f68ea7af007429c246baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5f4a66f61f68ea7af007429c246baa">&#9670;&nbsp;</a></span>rotate_cross_correlate_two_way()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::rotate_cross_correlate_two_way </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5e061b02110ae259864ad686a234038" name="ae5e061b02110ae259864ad686a234038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e061b02110ae259864ad686a234038">&#9670;&nbsp;</a></span>rotate_find_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::rotate_find_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refine_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates and find shift by cross-correlation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>rotation matrix. </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit in angstroms. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit in angstroms. </td></tr>
    <tr><td class="paramname">radius</td><td>search radius. </td></tr>
    <tr><td class="paramname">sigma</td><td>soften search radius cutoff. </td></tr>
    <tr><td class="paramname">refine_flag</td><td>refine shift. </td></tr>
    <tr><td class="paramname">planf</td><td>forward Fourier transform plan. </td></tr>
    <tr><td class="paramname">planb</td><td>backward Fourier transform plan.k </td></tr>
    <tr><td class="paramname">&amp;cc</td><td>correlation coefficient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector3.html">Vector3&lt;double&gt;</a> origin. <pre class="fragment">The point group symmetry operations are applied to an image with an
orientation defined by the reference symmetry axis (default {0,0,1}). 
</pre> </dd></dl>

</div>
</div>
<a id="a94d462f9cb36da0a45674bcedfa787d1" name="a94d462f9cb36da0a45674bcedfa787d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d462f9cb36da0a45674bcedfa787d1">&#9670;&nbsp;</a></span>rotate_height()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::rotate_height </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>translate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates a 3D map and calculates the height along the z-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>3x3 rotation or skewing matrix. </td></tr>
    <tr><td class="paramname">translate</td><td>3-value vector for translation after transformation. </td></tr>
    <tr><td class="paramname">threshold</td><td>density threshold to consider as object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new 2D height image. <pre class="fragment">The 3D map is rotated around its center as origin and the height 
calculated along the z-direction.
The resultant 2D image is translated if the translation vector is 
non-zero.
The rotation origin is obtained from the map origin.
</pre> </dd></dl>

</div>
</div>
<a id="aa6dea162b89d48d12f9f29f757a299e3" name="aa6dea162b89d48d12f9f29f757a299e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dea162b89d48d12f9f29f757a299e3">&#9670;&nbsp;</a></span>rotate_project()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::rotate_project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>translate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radial_cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_flag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates a 3D map and projects it along the z-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>3x3 rotation or skewing matrix. </td></tr>
    <tr><td class="paramname">translate</td><td>3-value vector for translation after transformation. </td></tr>
    <tr><td class="paramname">radial_cutoff</td><td>spherical cutoff to apply. </td></tr>
    <tr><td class="paramname">norm_flag</td><td>flag to normalize projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new 2D projection image. <pre class="fragment">The 3D map is rotated around its center as origin and the data 
integrated along the z-direction after subtraction of the
background (which must be calculated before this function).
The resultant 2D image is translated if the translation vector is 
non-zero. A radial cutoff can be applied to decrease the computation 
time. A value of zero or less sets the default to the length of the 
x-axis (i.e., no effective cutoff).
The rotation origin is obtained from the map origin.
</pre> </dd></dl>

</div>
</div>
<a id="a1204e425ce7833d410445af713a8792a" name="a1204e425ce7833d410445af713a8792a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1204e425ce7833d410445af713a8792a">&#9670;&nbsp;</a></span>rotate_to_axis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::rotate_to_axis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>axis_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates to a symmetry axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*sym</td><td>symmetry structure. </td></tr>
    <tr><td class="paramname">axis</td><td>desired symmetry axis order. </td></tr>
    <tr><td class="paramname">axis_flag</td><td>view modifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long 0. </dd></dl>

</div>
</div>
<a id="afbbcebef8ab9eeb4069edacbebc8ef2e" name="afbbcebef8ab9eeb4069edacbebc8ef2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbcebef8ab9eeb4069edacbebc8ef2e">&#9670;&nbsp;</a></span>sampling() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; &gt; Bimage::sampling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44553b4ff840993fa3911892949b46f7" name="a44553b4ff840993fa3911892949b46f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44553b4ff840993fa3911892949b46f7">&#9670;&nbsp;</a></span>sampling() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::sampling </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>uy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>uz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af764e499f3c674fe665f78d73da60a56" name="af764e499f3c674fe665f78d73da60a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af764e499f3c674fe665f78d73da60a56">&#9670;&nbsp;</a></span>sampling() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::sampling </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af1e1de0aa7f12bb2db5dba29f400cce7" name="af1e1de0aa7f12bb2db5dba29f400cce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e1de0aa7f12bb2db5dba29f400cce7">&#9670;&nbsp;</a></span>sampling() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::sampling </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>uy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>uz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea6d4d42a222c4916583a05e196e0fd1" name="aea6d4d42a222c4916583a05e196e0fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6d4d42a222c4916583a05e196e0fd1">&#9670;&nbsp;</a></span>sampling() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::sampling </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aadcb407c60a020cea5a03823a958f26e" name="aadcb407c60a020cea5a03823a958f26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcb407c60a020cea5a03823a958f26e">&#9670;&nbsp;</a></span>sampling() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::sampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aced5e9fd821016cc227138bc3dc31c06" name="aced5e9fd821016cc227138bc3dc31c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced5e9fd821016cc227138bc3dc31c06">&#9670;&nbsp;</a></span>sampling() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::sampling </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; &gt;&#160;</td>
          <td class="paramname"><em>sam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8221a6b44bccd9fb4bd31cc31320fcaa" name="a8221a6b44bccd9fb4bd31cc31320fcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8221a6b44bccd9fb4bd31cc31320fcaa">&#9670;&nbsp;</a></span>scale_to_reference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::scale_to_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalemin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalemax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales and image to the given reference, searching for the correct scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pref</td><td>reference/template image. </td></tr>
    <tr><td class="paramname">pmask</td><td>mask to limit correlation calculation (can be NULL). </td></tr>
    <tr><td class="paramname">scalemin</td><td>minimum scaling to start search. </td></tr>
    <tr><td class="paramname">scalemax</td><td>maximum scaling to end search. </td></tr>
    <tr><td class="paramname">step</td><td>scaling search step size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* scaled image. </dd></dl>

</div>
</div>
<a id="afa7a3a7acb990d667c474c2c7d694b30" name="afa7a3a7acb990d667c474c2c7d694b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7a3a7acb990d667c474c2c7d694b30">&#9670;&nbsp;</a></span>scale_to_reference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::scale_to_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales and image to the given reference, searching for the correct scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pref</td><td>reference/template image. </td></tr>
    <tr><td class="paramname">pmask</td><td>mask to limit correlation calculation (can be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* scaled image. </dd></dl>

</div>
</div>
<a id="a5003afb6ec7e7d88800197dc47e4abfc" name="a5003afb6ec7e7d88800197dc47e4abfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5003afb6ec7e7d88800197dc47e4abfc">&#9670;&nbsp;</a></span>scale_to_same_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::scale_to_same_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales and image to the given reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pref</td><td>reference/template image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* scaled image. </dd></dl>

</div>
</div>
<a id="a45b58edcb6fea8c4b1bd1ccd54790ffd" name="a45b58edcb6fea8c4b1bd1ccd54790ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b58edcb6fea8c4b1bd1ccd54790ffd">&#9670;&nbsp;</a></span>seamed_helix_symmetrize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bplot.html">Bplot</a> * Bimage::seamed_helix_symmetrize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>helix_rise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>helix_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seam_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dyad_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrizes an image given helical symmetry parameters and seam shift parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">helix_rise</td><td>rise per asymmetric unit (angstrom). </td></tr>
    <tr><td class="paramname">helix_angle</td><td>rotation angle per asymmetric unit (radians). </td></tr>
    <tr><td class="paramname">seam_shift</td><td>translation along the seam (subunit height units). </td></tr>
    <tr><td class="paramname">dyad_axis</td><td>dyad axis indicator: 2=dyad axis on x-axis, otherwise none. </td></tr>
    <tr><td class="paramname">zmin</td><td>mimimum z slice to include. </td></tr>
    <tr><td class="paramname">zmax</td><td>maximum z slice to include. </td></tr>
    <tr><td class="paramname">radius</td><td>radius to do symmetrizing over (pixels). </td></tr>
    <tr><td class="paramname">norm_flag</td><td>if 1, normalize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bplot* plot. <pre class="fragment">The data between the z limits are replicated along the helical axis
according to the helical rise and rotation and the seam to fill the new volume.
</pre> </dd></dl>

</div>
</div>
<a id="a1d6eeb216ad95114a41546c5f948661e" name="a1d6eeb216ad95114a41546c5f948661e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6eeb216ad95114a41546c5f948661e">&#9670;&nbsp;</a></span>search_views()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::search_views </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>ptemp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a> *&#160;</td>
          <td class="paramname"><em>views</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>search_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>currview</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>currshift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches a 2D/3D density map for a template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*ptemp</td><td>the template to be searched for. </td></tr>
    <tr><td class="paramname">*views</td><td>list of views to search. </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">search_radius</td><td>radius for shift search. </td></tr>
    <tr><td class="paramname">*pmask</td><td>mask for cross-correlation (ignored if NULL). </td></tr>
    <tr><td class="paramname">&amp;currview</td><td>best current view to return. </td></tr>
    <tr><td class="paramname">&amp;currshift</td><td>best current shift to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double the best correlation coefficient. <pre class="fragment">The template is rotated and cross-correlated to find the best fit.
The views must be calculated externally to allow for custom sets.
</pre> </dd></dl>

</div>
</div>
<a id="a7ce30d7a0b92b8e8886a19be03e23eff" name="a7ce30d7a0b92b8e8886a19be03e23eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce30d7a0b92b8e8886a19be03e23eff">&#9670;&nbsp;</a></span>search_volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::search_volume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>ptemp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches a 2D/3D density map for a template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*ptemp</td><td>the template to be searched for. </td></tr>
    <tr><td class="paramname">*view</td><td>views. </td></tr>
    <tr><td class="paramname">alpha</td><td>rotation around view vector, &lt;0 = use 2*PI (radians). </td></tr>
    <tr><td class="paramname">alpha_step</td><td>angular step size around view vector (radians). </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">*pmask</td><td>mask for cross-correlation (ignored if NULL). </td></tr>
    <tr><td class="paramname">threshold</td><td>threshold value, if 0, threshold = FOMmax/2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* image with the best view at each voxel and FOM block. <pre class="fragment">The template is rotated and cross-correlated to find the best fit.
The views must be calculated externally to allow for custom sets.
</pre> </dd></dl>

</div>
</div>
<a id="a5ac6c12ee2b9faa6521107716e981814" name="a5ac6c12ee2b9faa6521107716e981814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac6c12ee2b9faa6521107716e981814">&#9670;&nbsp;</a></span>search_volume_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::search_volume_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>ptemp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pfit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches a 2D/3D density map for a template using a specific view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*ptemp</td><td>the template to be searched for. </td></tr>
    <tr><td class="paramname">view</td><td>view. </td></tr>
    <tr><td class="paramname">hires</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">lores</td><td>low resolution limit. </td></tr>
    <tr><td class="paramname">*pmask</td><td>mask for cross-correlation (ignored if NULL). </td></tr>
    <tr><td class="paramname">threshold</td><td>threshold value, if 0, threshold = FOMmax/2. </td></tr>
    <tr><td class="paramname">*pfit</td><td>view image with FOM block to hold results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double maximum FOM. <pre class="fragment">The template is rotated to the view and cross-correlated.
A view image is updated with the results where the correlation coefficients are higher.
The views must be calculated externally to allow for custom sets.
</pre> </dd></dl>

</div>
</div>
<a id="ad890b6b933f3f467cf30b787b0d7bbc4" name="ad890b6b933f3f467cf30b787b0d7bbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad890b6b933f3f467cf30b787b0d7bbc4">&#9670;&nbsp;</a></span>select_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::select_images </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a>&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08e615360c7c3c68ed3144acccf40f02" name="a08e615360c7c3c68ed3144acccf40f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e615360c7c3c68ed3144acccf40f02">&#9670;&nbsp;</a></span>set() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::set </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_m_y_k.html">CMYK</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a color value at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
    <tr><td class="paramname">color</td><td>color value. <pre class="fragment">The index refers to compound values.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44a60b5de3fd18a6c8e0858af9cd65b8" name="a44a60b5de3fd18a6c8e0858af9cd65b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a60b5de3fd18a6c8e0858af9cd65b8">&#9670;&nbsp;</a></span>set() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::set </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_complex.html">Complex</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>cv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a complex value at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
    <tr><td class="paramname">cv</td><td>complex value. <pre class="fragment">The index refers to compound values.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f091b084f0e714284d7c761dd4c0b15" name="a7f091b084f0e714284d7c761dd4c0b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f091b084f0e714284d7c761dd4c0b15">&#9670;&nbsp;</a></span>set() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::set </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a single value at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
    <tr><td class="paramname">v</td><td>value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abff9753006d934364d77b51c87b34fa4" name="abff9753006d934364d77b51c87b34fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff9753006d934364d77b51c87b34fa4">&#9670;&nbsp;</a></span>set() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::set </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_g_b.html">RGB</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a color value at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
    <tr><td class="paramname">color</td><td>color value. <pre class="fragment">The index refers to compound values.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e4265c10a266a3f930f0f773f4d1d45" name="a0e4265c10a266a3f930f0f773f4d1d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4265c10a266a3f930f0f773f4d1d45">&#9670;&nbsp;</a></span>set() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::set </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_g_b_a.html">RGBA</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a color value at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
    <tr><td class="paramname">color</td><td>color value. <pre class="fragment">The index refers to compound values.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53c53e826eac2717012b6c08e04c0d9a" name="a53c53e826eac2717012b6c08e04c0d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c53e826eac2717012b6c08e04c0d9a">&#9670;&nbsp;</a></span>set() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::set </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a 3-value vector at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
    <tr><td class="paramname">vec</td><td>3-value vector. <pre class="fragment">The index refers to compound values.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30e0d8a5922143b1c8edba5c07aacb13" name="a30e0d8a5922143b1c8edba5c07aacb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e0d8a5922143b1c8edba5c07aacb13">&#9670;&nbsp;</a></span>set() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::set </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a 3-value vector at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
    <tr><td class="paramname">view</td><td>4-value view. <pre class="fragment">The index refers to compound values.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a059a3df092b74a3b4f56ef2623a1a45d" name="a059a3df092b74a3b4f56ef2623a1a45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059a3df092b74a3b4f56ef2623a1a45d">&#9670;&nbsp;</a></span>set_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::set_max </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value at a given location to neigboring data elements if it is larger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x location. </td></tr>
    <tr><td class="paramname">yy</td><td>y location. </td></tr>
    <tr><td class="paramname">zz</td><td>z location. </td></tr>
    <tr><td class="paramname">nn</td><td>image number (4 th dimension). </td></tr>
    <tr><td class="paramname">v</td><td>value to assess and set. <pre class="fragment">All neighboring voxels are checked and set to the given value if it is larger.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeff910cb0d91aa55d4ec824e2ecf2b58" name="aeff910cb0d91aa55d4ec824e2ecf2b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff910cb0d91aa55d4ec824e2ecf2b58">&#9670;&nbsp;</a></span>set_subset_selection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::set_subset_selection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a>&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the sub-image selections based on a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>list of sub-images to select. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of images selected. <pre class="fragment">The data is not altered.
</pre> </dd></dl>

</div>
</div>
<a id="a9143f5bc96c3fb12dada8d1be1120332" name="a9143f5bc96c3fb12dada8d1be1120332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9143f5bc96c3fb12dada8d1be1120332">&#9670;&nbsp;</a></span>set_time() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::set_time </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a906cdf211bd171c7af7088c3ac70423c" name="a906cdf211bd171c7af7088c3ac70423c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906cdf211bd171c7af7088c3ac70423c">&#9670;&nbsp;</a></span>set_time() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::set_time </td>
          <td>(</td>
          <td class="paramtype">tm *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a38e87c1320e30753ce7e908a4ccd93b6" name="a38e87c1320e30753ce7e908a4ccd93b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e87c1320e30753ce7e908a4ccd93b6">&#9670;&nbsp;</a></span>shape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::shape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a shape in an image and fills it with a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of shape: 0=rectangle, 1=oval, 2=cylinder </td></tr>
    <tr><td class="paramname">rect</td><td>three-value size of the area to be filled. </td></tr>
    <tr><td class="paramname">start</td><td>three-value start of area. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of smoothing function. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The edge of the area is smoothed with a function:
                    v_old(x,y,z) + fill*exp(1.618*dist/width)
    v_new(x,y,z) = ------------------------------------------
                           1 + exp(1.618*dist/width)
where   fill is the constant fill value.
        dist is the distance to the rectangular boundary defined by 
            the input size and start
        width is the gaussian width (softness)
With very small values of the gaussian width, the edge approaches a
step function.
</pre> </dd></dl>

</div>
</div>
<a id="a8c5f912dd3240b4763bf53cda85da9e1" name="a8c5f912dd3240b4763bf53cda85da9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5f912dd3240b4763bf53cda85da9e1">&#9670;&nbsp;</a></span>shape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::shape </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a shape in an image and fills it with a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of edge: 0=rectangle, 1=oval, 2=cylinder </td></tr>
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">rect</td><td>three-value size of the area to be filled. </td></tr>
    <tr><td class="paramname">start</td><td>three-value start of area. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of smoothing function. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The edge of the area is smoothed with a function:
                    v_old(x,y,z) + fill*exp(1.618*dist/width)
    v_new(x,y,z) = ------------------------------------------
                           1 + exp(1.618*dist/width)
where   fill is the constant fill value.
        dist is the distance to the rectangular boundary defined by 
            the input size and start
        width is the gaussian width (softness)
With very small values of the gaussian width, the edge approaches a
step function.
</pre> </dd></dl>

</div>
</div>
<a id="aa909a61852ba0685fbebca6c091c667e" name="aa909a61852ba0685fbebca6c091c667e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa909a61852ba0685fbebca6c091c667e">&#9670;&nbsp;</a></span>shell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::shell </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a shell within an image with a uniform value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">center</td><td>center of shell. </td></tr>
    <tr><td class="paramname">minrad</td><td>minimum radius of shell. </td></tr>
    <tr><td class="paramname">maxrad</td><td>maximum radius of shell. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of smoothing function. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">All voxels within a shell at a given location and within given radii
are set to a given fill value.
The new data replaces the old data.
The default center is {0,0,0}.
</pre> </dd></dl>

</div>
</div>
<a id="aafb93c9e36f480a8b8c7cf40b826a37a" name="aafb93c9e36f480a8b8c7cf40b826a37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb93c9e36f480a8b8c7cf40b826a37a">&#9670;&nbsp;</a></span>shell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a shell within an image with a uniform value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of shell. </td></tr>
    <tr><td class="paramname">minrad</td><td>minimum radius of shell. </td></tr>
    <tr><td class="paramname">maxrad</td><td>maximum radius of shell. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of smoothing function. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">All voxels within a shell at a given location and within given radii
are set to a given fill value.
The new data replaces the old data.
The default center is {0,0,0}.
</pre> </dd></dl>

</div>
</div>
<a id="a50d40a435fef4c6e8c9bff4bf4b4d6f5" name="a50d40a435fef4c6e8c9bff4bf4b4d6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d40a435fef4c6e8c9bff4bf4b4d6f5">&#9670;&nbsp;</a></span>shell_wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::shell_wrap </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a shell within an image with a uniform value with wrapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">center</td><td>center of shell. </td></tr>
    <tr><td class="paramname">minrad</td><td>minimum radius of shell. </td></tr>
    <tr><td class="paramname">maxrad</td><td>maximum radius of shell. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of smoothing function. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">All voxels within a shell at a given location and within given radii
are set to a given fill value.
The new data replaces the old data.
The default center is {0,0,0}.
</pre> </dd></dl>

</div>
</div>
<a id="aa35b264e07b883cb7128b9539ceb05af" name="aa35b264e07b883cb7128b9539ceb05af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35b264e07b883cb7128b9539ceb05af">&#9670;&nbsp;</a></span>shift() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::shift </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts one sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">vec</td><td>3-value real space shift vector. </td></tr>
    <tr><td class="paramname">fill_type</td><td>fill type for filling empty regions. </td></tr>
    <tr><td class="paramname">fill</td><td>value to fill in empty regions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. </dd></dl>

</div>
</div>
<a id="a7f416c3ad809348ac75ef571b6874d99" name="a7f416c3ad809348ac75ef571b6874d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f416c3ad809348ac75ef571b6874d99">&#9670;&nbsp;</a></span>shift() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>3-value real space shift vector. </td></tr>
    <tr><td class="paramname">fill_type</td><td>fill type for filling empty regions. </td></tr>
    <tr><td class="paramname">fill</td><td>value to fill in empty regions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. </dd></dl>

</div>
</div>
<a id="a45890e60f74185ddfc88080dcbeda69e" name="a45890e60f74185ddfc88080dcbeda69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45890e60f74185ddfc88080dcbeda69e">&#9670;&nbsp;</a></span>shift_background()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::shift_background </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bkg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the background for each sub-image to a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bkg</td><td>new background value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">The background is taken as the average of the values outside the
circle or sphere enclosed by the image.
</pre> </dd></dl>

</div>
</div>
<a id="a215f5b8d6d4748458c05434ebd7f006b" name="a215f5b8d6d4748458c05434ebd7f006b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215f5b8d6d4748458c05434ebd7f006b">&#9670;&nbsp;</a></span>shift_wrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::shift_wrap </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts one sub-image with wrapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image. </td></tr>
    <tr><td class="paramname">vec</td><td>3-value real space shift vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. </dd></dl>

</div>
</div>
<a id="a358a46af05970ae98fe37d43333af8fb" name="a358a46af05970ae98fe37d43333af8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358a46af05970ae98fe37d43333af8fb">&#9670;&nbsp;</a></span>shift_wrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::shift_wrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>3-value real space shift vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int error code. </dd></dl>

</div>
</div>
<a id="a2341b7e858a5c023cd4be98b1ab64773" name="a2341b7e858a5c023cd4be98b1ab64773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2341b7e858a5c023cd4be98b1ab64773">&#9670;&nbsp;</a></span>show_image() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::show_image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9391231710bedec11f8bddad05150770" name="a9391231710bedec11f8bddad05150770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9391231710bedec11f8bddad05150770">&#9670;&nbsp;</a></span>show_image() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::show_image </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15c6ec8dead569920900c0abef394fa3" name="a15c6ec8dead569920900c0abef394fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c6ec8dead569920900c0abef394fa3">&#9670;&nbsp;</a></span>show_maximum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::show_maximum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3db073fe28ad4546b95b2f8993cfc2de" name="a3db073fe28ad4546b95b2f8993cfc2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db073fe28ad4546b95b2f8993cfc2de">&#9670;&nbsp;</a></span>show_maximum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::show_maximum </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac845ec573ac4f2e8d2da9806a27423ed" name="ac845ec573ac4f2e8d2da9806a27423ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac845ec573ac4f2e8d2da9806a27423ed">&#9670;&nbsp;</a></span>show_minimum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::show_minimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5616baac679d6a1250d86db6ecba273" name="af5616baac679d6a1250d86db6ecba273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5616baac679d6a1250d86db6ecba273">&#9670;&nbsp;</a></span>show_minimum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::show_minimum </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9f10d298cff665dca49330d90e3b2f6" name="af9f10d298cff665dca49330d90e3b2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f10d298cff665dca49330d90e3b2f6">&#9670;&nbsp;</a></span>show_scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::show_scale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a37bf22fd62b24a81897e5a69bcd85784" name="a37bf22fd62b24a81897e5a69bcd85784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bf22fd62b24a81897e5a69bcd85784">&#9670;&nbsp;</a></span>show_scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::show_scale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af903a9c1e50c06aafeb8464426d88a3b" name="af903a9c1e50c06aafeb8464426d88a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af903a9c1e50c06aafeb8464426d88a3b">&#9670;&nbsp;</a></span>show_slice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::show_slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29efa892a7c10ec5a88b3f686f97045d" name="a29efa892a7c10ec5a88b3f686f97045d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29efa892a7c10ec5a88b3f686f97045d">&#9670;&nbsp;</a></span>show_slice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::show_slice </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf488f62aca81f8ec7d4835c97103bc8" name="abf488f62aca81f8ec7d4835c97103bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf488f62aca81f8ec7d4835c97103bc8">&#9670;&nbsp;</a></span>shrink_wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::shrink_wrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>translate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrinks an image to a new size with wrapping of the excluded edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>new image size three-value vector. </td></tr>
    <tr><td class="paramname">translate</td><td>three-value translation vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">An image is resized to a smaller size with translation and wrapping
of the excluded edges to complete periodic boundaries. The image is
first converted to floating point to prevent overflows of smaller 
data types. The new image is finally converted back to the original
data type.
The new data replaces the old data.
</pre> </dd></dl>

</div>
</div>
<a id="a140b990f45d37151903ebc5d7541cddd" name="a140b990f45d37151903ebc5d7541cddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140b990f45d37151903ebc5d7541cddd">&#9670;&nbsp;</a></span>simple_to_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::simple_to_complex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple image is converted to a complex image. </p>
<pre class="fragment">The input image is written into the real part of the complex image.
</pre> 
</div>
</div>
<a id="aafc8731d276675569a09899fe294cb52" name="aafc8731d276675569a09899fe294cb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc8731d276675569a09899fe294cb52">&#9670;&nbsp;</a></span>simple_to_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::simple_to_rgb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple image is converted to a color image. </p>
<pre class="fragment">All three color values in each voxel are the same (i.e., gray).
</pre> 
</div>
</div>
<a id="a288b49e2101c603a259453e74f8fb9ee" name="a288b49e2101c603a259453e74f8fb9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288b49e2101c603a259453e74f8fb9ee">&#9670;&nbsp;</a></span>simple_to_rgba()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::simple_to_rgba </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple image is converted to a color image. </p>
<pre class="fragment">All three color values in each voxel are the same (i.e., gray).
The alpha value is set to 255.
</pre> 
</div>
</div>
<a id="aa73f430809a61cffcf9313c60a417090" name="aa73f430809a61cffcf9313c60a417090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73f430809a61cffcf9313c60a417090">&#9670;&nbsp;</a></span>size() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; Bimage::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04248059b87991c9de87d916c3dacfe9" name="a04248059b87991c9de87d916c3dacfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04248059b87991c9de87d916c3dacfe9">&#9670;&nbsp;</a></span>size() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::size </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad92c7423ec3efeebff4da5fc880282bb" name="ad92c7423ec3efeebff4da5fc880282bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92c7423ec3efeebff4da5fc880282bb">&#9670;&nbsp;</a></span>size() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15a3862564a94ee0bef5c1d2b0a33180" name="a15a3862564a94ee0bef5c1d2b0a33180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a3862564a94ee0bef5c1d2b0a33180">&#9670;&nbsp;</a></span>size() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::size </td>
          <td>(</td>
          <td class="paramtype">vector&lt; long &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a573098677821d6cb2a3f971a60600585" name="a573098677821d6cb2a3f971a60600585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573098677821d6cb2a3f971a60600585">&#9670;&nbsp;</a></span>sizeX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::sizeX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a7935b0778f079de4436a87e6007beb" name="a8a7935b0778f079de4436a87e6007beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7935b0778f079de4436a87e6007beb">&#9670;&nbsp;</a></span>sizeX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::sizeX </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a950470752066c7c8c3a42df1dcbba815" name="a950470752066c7c8c3a42df1dcbba815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950470752066c7c8c3a42df1dcbba815">&#9670;&nbsp;</a></span>sizeY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::sizeY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a24fff6fffe26b2cf9954c7086838deac" name="a24fff6fffe26b2cf9954c7086838deac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fff6fffe26b2cf9954c7086838deac">&#9670;&nbsp;</a></span>sizeY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::sizeY </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ny</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a598f1a14a9194965bb93d57c0510536f" name="a598f1a14a9194965bb93d57c0510536f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598f1a14a9194965bb93d57c0510536f">&#9670;&nbsp;</a></span>sizeZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::sizeZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0af0b19b20a1f3a29f6d46cf0a38964" name="aa0af0b19b20a1f3a29f6d46cf0a38964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0af0b19b20a1f3a29f6d46cf0a38964">&#9670;&nbsp;</a></span>sizeZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::sizeZ </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aacbdfdfe1d47935021b5868821eb4f89" name="aacbdfdfe1d47935021b5868821eb4f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbdfdfe1d47935021b5868821eb4f89">&#9670;&nbsp;</a></span>slices_to_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::slices_to_images </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the slices in a 3D image into a set of 2D images. </p>
<dl class="section return"><dt>Returns</dt><dd>int error code (&lt;0 means failure). </dd></dl>

</div>
</div>
<a id="aa7fd506ba5395c911834305a76c3fe66" name="aa7fd506ba5395c911834305a76c3fe66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fd506ba5395c911834305a76c3fe66">&#9670;&nbsp;</a></span>smallest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::smallest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the smallest of each pixel from two images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>other image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af717a562427570bee1788cf53f3dc408" name="af717a562427570bee1788cf53f3dc408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af717a562427570bee1788cf53f3dc408">&#9670;&nbsp;</a></span>snvariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::snvariance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>snradius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the ratio of variance inside and outside a given radius. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snradius</td><td>radius of signal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double the SNR. <pre class="fragment">The region outside the radial limit is considered noise and the region
inside is considered signal plus noise.
</pre> </dd></dl>

</div>
</div>
<a id="a06916652b8d41c5bad363331a0095862" name="a06916652b8d41c5bad363331a0095862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06916652b8d41c5bad363331a0095862">&#9670;&nbsp;</a></span>space_group() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::space_group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad458840e2a3e8969140355c131443cad" name="ad458840e2a3e8969140355c131443cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad458840e2a3e8969140355c131443cad">&#9670;&nbsp;</a></span>space_group() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::space_group </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>grp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a540ad8a401b61ff5602ffe643efc2b58" name="a540ad8a401b61ff5602ffe643efc2b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540ad8a401b61ff5602ffe643efc2b58">&#9670;&nbsp;</a></span>sphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::sphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a sphere within an image with a uniform value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>three vector center of sphere. </td></tr>
    <tr><td class="paramname">radius</td><td>sphere radius. </td></tr>
    <tr><td class="paramname">width</td><td>gaussian width of smoothing function. </td></tr>
    <tr><td class="paramname">fill_type</td><td>FILL_AVERAGE, FILL_BACKGROUND, FILL_USER. </td></tr>
    <tr><td class="paramname">fill</td><td>fill value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">All voxels within a sphere at a given location and with a given radius 
are increased by a given fill value.
The new data replaces the old data.
The default center is {0,0,0}.
</pre> </dd></dl>

</div>
</div>
<a id="a33659b73113d0d84e2482517310311d5" name="a33659b73113d0d84e2482517310311d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33659b73113d0d84e2482517310311d5">&#9670;&nbsp;</a></span>split_channels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::split_channels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the channels into individual images. </p>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new image. <pre class="fragment">The channels are converted to successive sets of images.
</pre> </dd></dl>

</div>
</div>
<a id="abaa0057b767acf23c99af72b999b5368" name="abaa0057b767acf23c99af72b999b5368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa0057b767acf23c99af72b999b5368">&#9670;&nbsp;</a></span>square()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::square </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the square of an image. </p>
<pre class="fragment">Values less than zero are set to zero.
Values greater than the data type maximum are set to the maximum.
</pre> 
</div>
</div>
<a id="a7411e52811a3b4f86631e89f3a19da2e" name="a7411e52811a3b4f86631e89f3a19da2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7411e52811a3b4f86631e89f3a19da2e">&#9670;&nbsp;</a></span>square_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::square_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the square root of an image. </p>
<pre class="fragment">Values less than zero are set to zero.
Values greater than the data type maximum are set to the maximum.
</pre> 
</div>
</div>
<a id="ad055b167896256474d3cf3cf6bb5c6a4" name="ad055b167896256474d3cf3cf6bb5c6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad055b167896256474d3cf3cf6bb5c6a4">&#9670;&nbsp;</a></span>standard_deviation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::standard_deviation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70982cf915d12b0d32511c299dd2a003" name="a70982cf915d12b0d32511c299dd2a003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70982cf915d12b0d32511c299dd2a003">&#9670;&nbsp;</a></span>standard_deviation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::standard_deviation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a164807e87f62d5e817344738f69b8c16" name="a164807e87f62d5e817344738f69b8c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164807e87f62d5e817344738f69b8c16">&#9670;&nbsp;</a></span>statistics() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the statistics for an image. </p>
<dl class="section return"><dt>Returns</dt><dd>long number of errors. </dd></dl>

</div>
</div>
<a id="a0e4bd3138163814bd4f96e38d8f9d5fd" name="a0e4bd3138163814bd4f96e38d8f9d5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4bd3138163814bd4f96e38d8f9d5fd">&#9670;&nbsp;</a></span>statistics() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>regavg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>regstd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the statistics for a region in an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pmask</td><td>region. </td></tr>
    <tr><td class="paramname">&amp;regavg</td><td>region average to be calculated. </td></tr>
    <tr><td class="paramname">&amp;regstd</td><td>region standard deviation to be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of voxels. </dd></dl>

</div>
</div>
<a id="a1d479463c3714a99b670129d62d3fe7a" name="a1d479463c3714a99b670129d62d3fe7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d479463c3714a99b670129d62d3fe7a">&#9670;&nbsp;</a></span>statistics() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::statistics </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>img_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the statistics for a sub-image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_num</td><td>sub-image number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of errors. </dd></dl>

</div>
</div>
<a id="ac6e146a61ad251fc4e5562495f6021aa" name="ac6e146a61ad251fc4e5562495f6021aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e146a61ad251fc4e5562495f6021aa">&#9670;&nbsp;</a></span>stats_in_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::stats_in_mask </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the statistics for an image for each level in a mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image number. </td></tr>
    <tr><td class="paramname">*pmask</td><td>mask with two or more levels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of levels (0 means failure). </dd></dl>

</div>
</div>
<a id="a4524e0f31e3c2c83e3d579cb199aa03f" name="a4524e0f31e3c2c83e3d579cb199aa03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4524e0f31e3c2c83e3d579cb199aa03f">&#9670;&nbsp;</a></span>stats_in_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::stats_in_poly </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>vavg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>vstd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the statistics for an image within the given polyhedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image number. </td></tr>
    <tr><td class="paramname">nvert</td><td>number of polygon vertices. </td></tr>
    <tr><td class="paramname">*poly</td><td>array of polygon vertices. </td></tr>
    <tr><td class="paramname">&amp;vavg</td><td>return value for the average. </td></tr>
    <tr><td class="paramname">&amp;vstd</td><td>return value for the standard deviation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of values (0 means failure). <pre class="fragment">If a voxel lies within the specified polyhedron, it is included in
the statistical calculations.
</pre> </dd></dl>

</div>
</div>
<a id="af67e899354c36a6d1a4abdb37136f079" name="af67e899354c36a6d1a4abdb37136f079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67e899354c36a6d1a4abdb37136f079">&#9670;&nbsp;</a></span>stats_in_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::stats_in_shape </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>vavg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>vstd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the statistics for an image within the given box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image number. </td></tr>
    <tr><td class="paramname">type</td><td>type of selection: 1=rectangle, 2=ellipse. </td></tr>
    <tr><td class="paramname">start</td><td>starting coordinates. </td></tr>
    <tr><td class="paramname">end</td><td>ending coordinates. </td></tr>
    <tr><td class="paramname">&amp;vavg</td><td>return value for the average. </td></tr>
    <tr><td class="paramname">&amp;vstd</td><td>return value for the standard deviation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of values (0 means failure). <pre class="fragment">If a voxel lies within the specified box, it is included in
the statistical calculations.
</pre> </dd></dl>

</div>
</div>
<a id="acce5020e4d29e2e0fc0b3ee369b68bc0" name="acce5020e4d29e2e0fc0b3ee369b68bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce5020e4d29e2e0fc0b3ee369b68bc0">&#9670;&nbsp;</a></span>stats_within_radii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::stats_within_radii </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>vavg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>vstd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the statistics for an image within given radii from a location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image number. </td></tr>
    <tr><td class="paramname">loc</td><td>center of shell. </td></tr>
    <tr><td class="paramname">rad_min</td><td>minimum radius (pixel units). </td></tr>
    <tr><td class="paramname">rad_max</td><td>maximum radius (pixel units). </td></tr>
    <tr><td class="paramname">&amp;vavg</td><td>return value for the average. </td></tr>
    <tr><td class="paramname">&amp;vstd</td><td>return value for the standard deviation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of values (0 means failure). <pre class="fragment">If a voxel lies within the specified radii, it is included in
the statistical calculations.
</pre> </dd></dl>

</div>
</div>
<a id="ac63bc84ebfa0da20f4783d5406fb0ada" name="ac63bc84ebfa0da20f4783d5406fb0ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63bc84ebfa0da20f4783d5406fb0ada">&#9670;&nbsp;</a></span>subimage_information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::subimage_information </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints out header information for all sub-images. </p>
<dl class="section return"><dt>Returns</dt><dd>int error code (&lt;0 means failure). </dd></dl>

</div>
</div>
<a id="a7349e99d1a9375c118ca86b69d387f0f" name="a7349e99d1a9375c118ca86b69d387f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7349e99d1a9375c118ca86b69d387f0f">&#9670;&nbsp;</a></span>subtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts another image from an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>image to be added. <pre class="fragment">Requirement: The images must have the same size.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb34c252e6a493a4672317f6790c6bfc" name="abb34c252e6a493a4672317f6790c6bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb34c252e6a493a4672317f6790c6bfc">&#9670;&nbsp;</a></span>subtract_background()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::subtract_background </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the background for each sub-image. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0, &lt;0 on error. <pre class="fragment">The background is taken from the sub-image structures.
</pre> </dd></dl>

</div>
</div>
<a id="a48263b31ee57d8c986bb1256413b71bd" name="a48263b31ee57d8c986bb1256413b71bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48263b31ee57d8c986bb1256413b71bd">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::sum </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> **&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sums an array of images with their FOM blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>number of images in the array. </td></tr>
    <tr><td class="paramname">**p</td><td>array of images. <pre class="fragment">The images must all have the same dimensions.
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca83b7f355394a839d387473c46cb804" name="aca83b7f355394a839d387473c46cb804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca83b7f355394a839d387473c46cb804">&#9670;&nbsp;</a></span>sum_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::sum_images </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all sub-images. </p>

</div>
</div>
<a id="aa33a023390e57b9360c07a7e29897096" name="aa33a023390e57b9360c07a7e29897096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33a023390e57b9360c07a7e29897096">&#9670;&nbsp;</a></span>superpixels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_bsuperpixel.html">Bsuperpixel</a> &gt; Bimage::superpixels </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>colorweight</em> = <code>0.2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stop</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segment the image into superpixels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>initial superpixel intervals. </td></tr>
    <tr><td class="paramname">colorweight</td><td>weight of color differences compared to spatial distances. </td></tr>
    <tr><td class="paramname">iterations</td><td>maximum number of iterations. </td></tr>
    <tr><td class="paramname">stop</td><td>stopping condition as a percent of voxel changes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;Bsuperpixel&gt; array of superpixels. <pre class="fragment">The segment array contents are:
0       count
1-3     coordinates
4+      channels
last    color weight for the segment - maximum squared distance

The mask is linked to the original image for return.
</pre> </dd></dl>

</div>
</div>
<a id="af8595e7180726af4e712990b8d8c1e69" name="af8595e7180726af4e712990b8d8c1e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8595e7180726af4e712990b8d8c1e69">&#9670;&nbsp;</a></span>superpixels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_bsuperpixel.html">Bsuperpixel</a> &gt; Bimage::superpixels </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>colorweight</em> = <code>0.2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bin_levels</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stop</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed87b5005e95430846c84a77a59a7231" name="aed87b5005e95430846c84a77a59a7231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed87b5005e95430846c84a77a59a7231">&#9670;&nbsp;</a></span>superpixels_from_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_bsuperpixel.html">Bsuperpixel</a> &gt; Bimage::superpixels_from_mask </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create superpixels from a multilevel mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>number of channels in the original image. </td></tr>
    <tr><td class="paramname">step</td><td>distance limit to determine neigbors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;Bsuperpixel&gt; array of superpixels. </dd></dl>

</div>
</div>
<a id="a0967da4dc8941259b9e4e03fbc169b8e" name="a0967da4dc8941259b9e4e03fbc169b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0967da4dc8941259b9e4e03fbc169b8e">&#9670;&nbsp;</a></span>superpixels_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::superpixels_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; long &gt;&#160;</td>
          <td class="paramname"><em>vstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>colorweight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_bsuperpixel.html">Bsuperpixel</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1de22ac24c7afaac9c174a4b4ff27bc9" name="a1de22ac24c7afaac9c174a4b4ff27bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de22ac24c7afaac9c174a4b4ff27bc9">&#9670;&nbsp;</a></span>surface_to_topograph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::surface_to_topograph </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dir</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 3D image to a 2D height image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>threshold to define the surface (assuming positive density). </td></tr>
    <tr><td class="paramname">dir</td><td>direction: 0=bottom up, 1=top down. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* 2D height image. <pre class="fragment">The threshold defines the surface of the positive density in the 3D image.
Each line of voxels in the z-direction is scanned for the voxel
exceeding the threshold with the highest z-index.
</pre> </dd></dl>

</div>
</div>
<a id="ac9d5028551a2b8fde28e38228f3e998b" name="ac9d5028551a2b8fde28e38228f3e998b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d5028551a2b8fde28e38228f3e998b">&#9670;&nbsp;</a></span>symmetrize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::symmetrize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a> &amp;&#160;</td>
          <td class="paramname"><em>symmetry_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adcb92270632a302bdf4773ee5da2be0a" name="adcb92270632a302bdf4773ee5da2be0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb92270632a302bdf4773ee5da2be0a">&#9670;&nbsp;</a></span>symmetrize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::symmetrize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a> &amp;&#160;</td>
          <td class="paramname"><em>symmetry_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>ref_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9234ec2ff8a260449cf950cdafa717a" name="ac9234ec2ff8a260449cf950cdafa717a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9234ec2ff8a260449cf950cdafa717a">&#9670;&nbsp;</a></span>symmetrize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::symmetrize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a>&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adda5f353fd53c60a772c4457e6585a8b" name="adda5f353fd53c60a772c4457e6585a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda5f353fd53c60a772c4457e6585a8b">&#9670;&nbsp;</a></span>symmetrize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::symmetrize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a>&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>ref_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies point group symmetry to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>point group. </td></tr>
    <tr><td class="paramname">ref_view</td><td>reference view vector and rotation angle. </td></tr>
    <tr><td class="paramname">flag</td><td>flag to normalize after symmetrization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double symmetry FOM. <pre class="fragment">The point group symmetry operations are applied to an image with an
orientation defined by the reference symmetry axis (default {0,0,1}). 
The fill value is taken from image's background value.
The symmetry FOM is taken as the ratio of the power after to before
symmetrization. 
</pre> </dd></dl>

</div>
</div>
<a id="a9780d7cbd494044686c433a6b525b9b6" name="a9780d7cbd494044686c433a6b525b9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9780d7cbd494044686c433a6b525b9b6">&#9670;&nbsp;</a></span>symmetrize_cyclic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::symmetrize_cyclic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cyclic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abff0d6899e55fcad02d800f179e87e46" name="abff0d6899e55fcad02d800f179e87e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff0d6899e55fcad02d800f179e87e46">&#9670;&nbsp;</a></span>symmetrize_cylinder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::symmetrize_cylinder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a cylindrically symmetrized map. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is replaced with its cylindrically symmetrized version.
</pre> </dd></dl>

</div>
</div>
<a id="a8e04fb8bc837bf7f030b4fb061e1bdbf" name="a8e04fb8bc837bf7f030b4fb061e1bdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e04fb8bc837bf7f030b4fb061e1bdbf">&#9670;&nbsp;</a></span>symmetrize_cylinder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::symmetrize_cylinder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a cylindrically symmetrized map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>0: </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* 2D image with the cylindrical average. <pre class="fragment">A 2D cylindrically symmetrized average is calculated.
</pre> </dd></dl>

</div>
</div>
<a id="a0df5322cc9ecfbd3e5e025316a8995a8" name="a0df5322cc9ecfbd3e5e025316a8995a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df5322cc9ecfbd3e5e025316a8995a8">&#9670;&nbsp;</a></span>symmetry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string &amp; Bimage::symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a356f24e44b64a98a02e7e3100e3349a9" name="a356f24e44b64a98a02e7e3100e3349a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356f24e44b64a98a02e7e3100e3349a9">&#9670;&nbsp;</a></span>symmetry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::symmetry </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>grp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b10d20714d9de3585a5d17a5db6021b" name="a9b10d20714d9de3585a5d17a5db6021b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b10d20714d9de3585a5d17a5db6021b">&#9670;&nbsp;</a></span>symmetry_equivalent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix3.html">Matrix3</a> Bimage::symmetry_equivalent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the symmetry equivalent orientation of a particle with respect to a template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pref</td><td>template to test against (same size as input image). </td></tr>
    <tr><td class="paramname">*pmask</td><td>mask to limit correlation calculation. </td></tr>
    <tr><td class="paramname">*sym</td><td>symmetry structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_matrix3.html">Matrix3</a> transformed image. <pre class="fragment">For point groups up to tetrahedral symmetry, there is an ambiguity in the
orientation of a particle even though it is oriented according to the 
standard orientation for the symmetry.
A template is used to select the desired orientation and the image is transformed.
Both the input image and template must be in the standard orientation
for the point group.
</pre> </dd></dl>

</div>
</div>
<a id="a441cf6a9232c52cd99f32acdb1ba905d" name="a441cf6a9232c52cd99f32acdb1ba905d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441cf6a9232c52cd99f32acdb1ba905d">&#9670;&nbsp;</a></span>symmetry_equivalent_cyclic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix3.html">Matrix3</a> Bimage::symmetry_equivalent_cyclic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bsymmetry.html">Bsymmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the cyclic symmetry equivalent orientation of a particle with respect to a template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pref</td><td>template to test against (same size as input image). </td></tr>
    <tr><td class="paramname">*pmask</td><td>mask to limit correlation calculation. </td></tr>
    <tr><td class="paramname">*sym</td><td>symmetry structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_matrix3.html">Matrix3</a> transformed image. <pre class="fragment">For point groups up to tetrahedral symmetry, there is an ambiguity in the
orientation of a particle even though it is oriented according to the 
standard orientation for the symmetry.
A template is used to select the desired orientation and the image is transformed.
Both the input image and template must be in the standard orientation
for the point group.
</pre> </dd></dl>

</div>
</div>
<a id="a8d7f8e0e6c7601e156216fc0552f24d7" name="a8d7f8e0e6c7601e156216fc0552f24d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7f8e0e6c7601e156216fc0552f24d7">&#9670;&nbsp;</a></span>test_helix_parameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::test_helix_parameters </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>mask_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>mask_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>max_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft_8h.html#a61d23c567e69684715ea52482137a5e6">fft_plan</a>&#160;</td>
          <td class="paramname"><em>planb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d6a7f6c65c1e731404fee3c2fbf7336" name="a3d6a7f6c65c1e731404fee3c2fbf7336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6a7f6c65c1e731404fee3c2fbf7336">&#9670;&nbsp;</a></span>test_helix_parameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::test_helix_parameters </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>mask_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>mask_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a960a7f0cde5092bb23f788c359c5388a" name="a960a7f0cde5092bb23f788c359c5388a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960a7f0cde5092bb23f788c359c5388a">&#9670;&nbsp;</a></span>thickness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::thickness </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>emfp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a thickness based on intensities with respect to a reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>reference intensity. </td></tr>
    <tr><td class="paramname">emfp</td><td>proportionaility coefficient. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt; 7-value array of parameters. <pre class="fragment">The thickness for each pixel is:
    t = emfp * ln(Iref/Ipix)
If Ipix &lt;= 0, t = 0
</pre> </dd></dl>

</div>
</div>
<a id="ad8ef4e4f4bf08e4282763b429c2ff060" name="ad8ef4e4f4bf08e4282763b429c2ff060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ef4e4f4bf08e4282763b429c2ff060">&#9670;&nbsp;</a></span>tile_coordinates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &gt; Bimage::tile_coordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>step_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exceed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a set of tile coordinates for an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;start</td><td>3-vector start for first tile to be extracted. </td></tr>
    <tr><td class="paramname">&amp;region</td><td>3-vector size of part of image to be extracted (0 = whole image). </td></tr>
    <tr><td class="paramname">&amp;tile_size</td><td>3-vector size of extracted image. </td></tr>
    <tr><td class="paramname">&amp;step_size</td><td>3-vector size of intervals between tiles. </td></tr>
    <tr><td class="paramname">exceed</td><td>flag to allow tiles to exceed the input image size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;Vector3&lt;long&gt;&gt; set of coordinates. <pre class="fragment">Calculating the coordinates of tiles of a specified size and within
a specified region within the image. The overlap is specified by
the step size and a flag indicates the option to exceed the
bounds of the image.
The old data is not affected.
</pre> </dd></dl>

</div>
</div>
<a id="a6c8ec73b38f79aca1d59c87ed1a7d27c" name="a6c8ec73b38f79aca1d59c87ed1a7d27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8ec73b38f79aca1d59c87ed1a7d27c">&#9670;&nbsp;</a></span>tile_coordinates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &gt; Bimage::tile_coordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>tile_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>step_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a set of tile coordinates to fit in the image dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile_size</td><td>3-vector size of extracted image. </td></tr>
    <tr><td class="paramname">&amp;step_size</td><td>3-vector size of intervals between tiles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;Vector3&lt;long&gt;&gt; set of coordinates. <pre class="fragment">Calculating the coordinates of tiles of a specified size to fit within
the bounds of the image. The overlap is specified by
the given step size, which is adjusted to fit the image bounds.
The old data is not affected.
</pre> </dd></dl>

</div>
</div>
<a id="aa0ac74f2bb136585165376ab7feb7b2b" name="aa0ac74f2bb136585165376ab7feb7b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ac74f2bb136585165376ab7feb7b2b">&#9670;&nbsp;</a></span>tile_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::tile_mask </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>step</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a mask to a tiled multilevel mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>isotropic tile edge size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new mask. <pre class="fragment">The old data is unmodified.
</pre> </dd></dl>

</div>
</div>
<a id="a1513d43b73d238e6b087fe2e4a2dc873" name="a1513d43b73d238e6b087fe2e4a2dc873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1513d43b73d238e6b087fe2e4a2dc873">&#9670;&nbsp;</a></span>to_mask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::to_mask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d8256eb1e4caa7cabb1a72f0287d98d" name="a9d8256eb1e4caa7cabb1a72f0287d98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8256eb1e4caa7cabb1a72f0287d98d">&#9670;&nbsp;</a></span>to_mask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Bimage::to_mask </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the image to a mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>set mask above this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long number of mask voxels. <pre class="fragment">The input image is effectively thresholded and a mask with 0 and 1 generated.
The new data type is unsigned char/byte.
</pre> </dd></dl>

</div>
</div>
<a id="a8c930e1334ca602ae39bcf26b3a6f851" name="a8c930e1334ca602ae39bcf26b3a6f851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c930e1334ca602ae39bcf26b3a6f851">&#9670;&nbsp;</a></span>topograph_to_surface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::topograph_to_surface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>psd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 2D AFM image to a 3D density map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*psd</td><td>2D standard deviation image. </td></tr>
    <tr><td class="paramname">nz</td><td>z dimension of the new 3D map. </td></tr>
    <tr><td class="paramname">density</td><td>density inside the surface (Da/A3). </td></tr>
    <tr><td class="paramname">resolution</td><td>sigma bounds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The 2D image is expanded in the z direction according to:
                          voxel_density
dens[x,y,z] = --------------------------------------
              1+exp(factor*(z-zdis[x,y])/sigma[x,y])
where   voxel_density is the total density attributed to a voxel
        factor = 1.618
        z - zdis[x,y] is the z distance from the surface
        sigma is a standard deviation term to describe the surface variability.
The sigma term can be set automatically or given by an input standard deviation map.
The position of the surface is calculated as:
zdis[x,y] = loz + (hiz - loz)*(image[x,y] - min)/(max - min)
where   loz and hiz are the lowest and highest points of the surface in the 3D map
        min and max are the image minimum and maximum values
</pre> </dd></dl>

</div>
</div>
<a id="a08fd2cd3face95c2fb85f2adfb36532f" name="a08fd2cd3face95c2fb85f2adfb36532f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fd2cd3face95c2fb85f2adfb36532f">&#9670;&nbsp;</a></span>track_gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::track_gradient </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a segmented image from peaks above a threshold value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>the lowest level to include voxels in regions. </td></tr>
    <tr><td class="paramname">flag</td><td>Track towards maxima (0) or minima (1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* integer image containing tracking indices. <pre class="fragment">Every voxel with a value above (below) the threshold is tagged by a pointer
pointing to the highest (lowest) value within a kernel of 3x3x3.
A peak is defined as pointing to itself, while every other voxel
points towards a peak.
</pre> </dd></dl>

</div>
</div>
<a id="a3eb5e8ee13e1fdc6ae91cf24a7b1000c" name="a3eb5e8ee13e1fdc6ae91cf24a7b1000c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb5e8ee13e1fdc6ae91cf24a7b1000c">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::transform </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>translate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a sub-image by translation, rotation, scaling and skewing, returning a single new image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>sub-image to process. </td></tr>
    <tr><td class="paramname">nusize</td><td>3-value new image size. </td></tr>
    <tr><td class="paramname">scale</td><td>3-value scale factor vector to apply. </td></tr>
    <tr><td class="paramname">origin</td><td>3-value origin for rotation and skewing. </td></tr>
    <tr><td class="paramname">translate</td><td>3-value vector for translation after transformation. </td></tr>
    <tr><td class="paramname">mat</td><td>3x3 rotation or skewing matrix. </td></tr>
    <tr><td class="paramname">fill_type</td><td>fill type for filling empty regions. </td></tr>
    <tr><td class="paramname">fill</td><td>value to fill in empty regions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new image. <pre class="fragment">A number of transformation types are combined in this function for
efficiency. The basic operation is the conversion of the image data 
from the original data block to a new data block, applying a 
transformation matrix and translation vector with a specified origin 
followed by an optional translation:
    y = R*x + t
where   R is the rotation/skewing/scaling matrix.
        t is the translation vector.
Note: The image is converted to floating point to improve interpolation.
</pre> </dd></dl>

</div>
</div>
<a id="afeb9247a8453a7e7907517b837d31144" name="afeb9247a8453a7e7907517b837d31144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb9247a8453a7e7907517b837d31144">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>translate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms an image by translation, rotation, scaling and skewing, in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>3-value scale factor vector to apply. </td></tr>
    <tr><td class="paramname">origin</td><td>3-value origin for rotation and skewing. </td></tr>
    <tr><td class="paramname">translate</td><td>3-value vector for translation after transformation. </td></tr>
    <tr><td class="paramname">mat</td><td>3x3 rotation or skewing matrix. </td></tr>
    <tr><td class="paramname">fill_type</td><td>fill type for filling empty regions. </td></tr>
    <tr><td class="paramname">fill</td><td>value to fill in empty regions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 error code. <pre class="fragment">A number of transformation types are combined in this function for
efficiency. The basic operation is the conversion of the image data 
from the original data block to a new data block, applying a 
transformation matrix and translation vector with a specified origin 
followed by an optional translation:
    y = R*x + t
where   R is the rotation/skewing/scaling matrix.
        t is the translation vector.
Note: The image is converted to floating point to improve interpolation.
</pre> </dd></dl>

</div>
</div>
<a id="af8b24fc84bde3d429023c6a2d19e993b" name="af8b24fc84bde3d429023c6a2d19e993b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b24fc84bde3d429023c6a2d19e993b">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>nusize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>translate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_type</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms an image by translation, rotation, scaling and skewing, returning a new image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nusize</td><td>3-value new image size. </td></tr>
    <tr><td class="paramname">scale</td><td>3-value scale factor vector to apply. </td></tr>
    <tr><td class="paramname">origin</td><td>3-value origin for rotation and skewing. </td></tr>
    <tr><td class="paramname">translate</td><td>3-value vector for translation after transformation. </td></tr>
    <tr><td class="paramname">mat</td><td>3x3 rotation or skewing matrix. </td></tr>
    <tr><td class="paramname">fill_type</td><td>fill type for filling empty regions. </td></tr>
    <tr><td class="paramname">fill</td><td>value to fill in empty regions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* new image. <pre class="fragment">A number of transformation types are combined in this function for
efficiency. The basic operation is the conversion of the image data 
from the original data block to a new data block, applying a 
transformation matrix and translation vector with a specified origin 
followed by an optional translation:
    y = R*x + t
where   R is the rotation/skewing/scaling matrix.
        t is the translation vector.
Note: The image is converted to floating point to improve interpolation.
</pre> </dd></dl>

</div>
</div>
<a id="a3b6ce6033d308dc4276493460266243c" name="a3b6ce6033d308dc4276493460266243c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6ce6033d308dc4276493460266243c">&#9670;&nbsp;</a></span>transform_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::transform_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba54e71d897721376cfaab4e6c360cf5" name="aba54e71d897721376cfaab4e6c360cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba54e71d897721376cfaab4e6c360cf5">&#9670;&nbsp;</a></span>transform_voxel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::transform_voxel </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>oldorigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>nuorigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix3.html">Matrix3</a>&#160;</td>
          <td class="paramname"><em>affmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55253f5cbc24af2d07edf348d81772cb" name="a55253f5cbc24af2d07edf348d81772cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55253f5cbc24af2d07edf348d81772cb">&#9670;&nbsp;</a></span>truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::truncate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>setmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>setmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncates image data to a given minimum and maximum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minim</td><td>minimum. </td></tr>
    <tr><td class="paramname">maxim</td><td>maximum. </td></tr>
    <tr><td class="paramname">setmin</td><td>value to set voxels smaller than minimum. </td></tr>
    <tr><td class="paramname">setmax</td><td>value to set voxels larger than maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">All values smaller than the new minimum are set to the new minimum
and all values larger than the new maximum are set to the new maximum.
In cases where the given minimum and maximum are outside the data
type ranges, they are reset to the data type range limits.
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a972a0567449bfb9aff48b05aafec5c7e" name="a972a0567449bfb9aff48b05aafec5c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972a0567449bfb9aff48b05aafec5c7e">&#9670;&nbsp;</a></span>truncate_to_avg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::truncate_to_avg </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets voxels in image data exceeding a given minimum and maximum to the average. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minim</td><td>minimum. </td></tr>
    <tr><td class="paramname">maxim</td><td>maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">All values smaller than the new minimum or larger than the new 
maximum are set to the image average.
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a76678f39fb8dc645ec3d54d9494db3d9" name="a76678f39fb8dc645ec3d54d9494db3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76678f39fb8dc645ec3d54d9494db3d9">&#9670;&nbsp;</a></span>truncate_to_background()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::truncate_to_background </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets voxels in image data exceeding a given minimum and maximum to the image background. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minim</td><td>minimum. </td></tr>
    <tr><td class="paramname">maxim</td><td>maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">All values smaller than the new minimum or larger than the new 
maximum are set to the background value.
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a0112a4c9c0d3c8dcd41b17f540584517" name="a0112a4c9c0d3c8dcd41b17f540584517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0112a4c9c0d3c8dcd41b17f540584517">&#9670;&nbsp;</a></span>truncate_to_min_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::truncate_to_min_max </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncates image data to a given minimum and maximum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minim</td><td>minimum. </td></tr>
    <tr><td class="paramname">maxim</td><td>maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">All values smaller than the new minimum are set to the new minimum
and all values larger than the new maximum are set to the new maximum.
In cases where the given minimum and maximum are outside the data
type ranges, they are reset to the data type range limits.
The new data replaces the old data.
Image statistics are recalculated.
</pre> </dd></dl>

</div>
</div>
<a id="a200ab278f109331849725f5398930f8e" name="a200ab278f109331849725f5398930f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200ab278f109331849725f5398930f8e">&#9670;&nbsp;</a></span>tube_interpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::tube_interpolate </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>latconst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_flag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f9ffa51405f1702ea3091f35fa66902" name="a8f9ffa51405f1702ea3091f35fa66902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9ffa51405f1702ea3091f35fa66902">&#9670;&nbsp;</a></span>tube_symmetrize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::tube_symmetrize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>latconst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_flag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrizes an image given tubular lattice parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>units along u vector. </td></tr>
    <tr><td class="paramname">k</td><td>units along v vector. </td></tr>
    <tr><td class="paramname">latconst</td><td>lattice constant (angstrom). </td></tr>
    <tr><td class="paramname">zmin</td><td>mimimum z slice to include. </td></tr>
    <tr><td class="paramname">zmax</td><td>maximum z slice to include. </td></tr>
    <tr><td class="paramname">radius</td><td>radius to do symmetrizing over (pixels). </td></tr>
    <tr><td class="paramname">norm_flag</td><td>if 1, normalize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double R factor. <pre class="fragment">The data between the z limits are replicated along the helical axis
according to the lattice parameters to fill the new volume.
</pre> </dd></dl>

</div>
</div>
<a id="a58e341bd1fde6068b484a265a546b39a" name="a58e341bd1fde6068b484a265a546b39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e341bd1fde6068b484a265a546b39a">&#9670;&nbsp;</a></span>unit_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_cell.html">UnitCell</a> Bimage::unit_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b435df6c3ad057b73957aad67172ea5" name="a3b435df6c3ad057b73957aad67172ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b435df6c3ad057b73957aad67172ea5">&#9670;&nbsp;</a></span>unit_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::unit_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_cell.html">UnitCell</a>&#160;</td>
          <td class="paramname"><em>uc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab581cd7985b8d57b0fce1d70a1651f1a" name="ab581cd7985b8d57b0fce1d70a1651f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab581cd7985b8d57b0fce1d70a1651f1a">&#9670;&nbsp;</a></span>unpack_combined_transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::unpack_combined_transform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpacks a complex transform obtained from two real images. </p>
<dl class="section return"><dt>Returns</dt><dd>Bimage* transform of second image. <pre class="fragment">The complex image must be a Fourier transform obtained from two real 
space images which were packed into the real and imaginary parts
of the complex image before Fourier transformation.
The input image is used to hold the transform of the first image.
A new image is created to hold the transform of the second image.
Both these images are complex floating point.
Note: Images with even dimensions cannot be unpacked exactly because
    the inverse is not present when x=nx/2 or y=ny/2 or z=nz/2.
</pre> </dd></dl>

</div>
</div>
<a id="abac3ddeaa17b3475f3023da92ddbc786" name="abac3ddeaa17b3475f3023da92ddbc786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac3ddeaa17b3475f3023da92ddbc786">&#9670;&nbsp;</a></span>unpack_transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::unpack_transform </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>img_select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_bimage_8h.html#a01e0deba350901d769526633e868806f">FourierType</a>&#160;</td>
          <td class="paramname"><em>tf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d169bcc5a3105a3b258b3d62449618f" name="a5d169bcc5a3105a3b258b3d62449618f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d169bcc5a3105a3b258b3d62449618f">&#9670;&nbsp;</a></span>unpack_transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::unpack_transform </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_bimage_8h.html#a01e0deba350901d769526633e868806f">FourierType</a>&#160;</td>
          <td class="paramname"><em>tf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42dd5c73484665555ed8068a6fc0f63c" name="a42dd5c73484665555ed8068a6fc0f63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42dd5c73484665555ed8068a6fc0f63c">&#9670;&nbsp;</a></span>update_from_meta_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::update_from_meta_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update sub-image information from the metadata. </p>
<pre class="fragment">The metadata in JSON format is transferred to the sub-image information.
</pre> 
</div>
</div>
<a id="a0015cbfaf312d0e77f62ff5e413f5a14" name="a0015cbfaf312d0e77f62ff5e413f5a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0015cbfaf312d0e77f62ff5e413f5a14">&#9670;&nbsp;</a></span>values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; Bimage::values </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c5c2a2c6d2b645b5c076703c2ef35c4" name="a0c5c2a2c6d2b645b5c076703c2ef35c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5c2a2c6d2b645b5c076703c2ef35c4">&#9670;&nbsp;</a></span>values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::values </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab1bb8c97d8f6513ae63dc0f101f4f81" name="aab1bb8c97d8f6513ae63dc0f101f4f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1bb8c97d8f6513ae63dc0f101f4f81">&#9670;&nbsp;</a></span>values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; Bimage::values </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array with all channel data at the given coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>image index. </td></tr>
    <tr><td class="paramname">vox</td><td>voxel coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt; value array. <pre class="fragment">The values of all channels are returned in double precision.
</pre> </dd></dl>

</div>
</div>
<a id="a4bf8a5dccfa06f31723598cfb9f08a22" name="a4bf8a5dccfa06f31723598cfb9f08a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf8a5dccfa06f31723598cfb9f08a22">&#9670;&nbsp;</a></span>variance() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::variance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc9022fbf57ed364f1c2f52b71f7af4d" name="afc9022fbf57ed364f1c2f52b71f7af4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9022fbf57ed364f1c2f52b71f7af4d">&#9670;&nbsp;</a></span>variance() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::variance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>pweight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the local variance weighed with the given image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pweight</td><td>weight image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The local variance is calculated using the given image as kernel weights.
The calculation is threaded if compiled with GCD or OpenMP.
</pre> </dd></dl>

</div>
</div>
<a id="a9dff1ffc38196ca423bf5f842fc3c1e6" name="a9dff1ffc38196ca423bf5f842fc3c1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dff1ffc38196ca423bf5f842fc3c1e6">&#9670;&nbsp;</a></span>variance() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::variance </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the local variance within the given kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel_size</td><td>size of kernel edge. </td></tr>
    <tr><td class="paramname">flag</td><td>selects type of output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The local variance within a kernel is calculated.
The calculation is threaded if compiled with GCD or OpenMP.
Flag values:
0   variance
1   standard deviation
2   poisson excess variance
</pre> </dd></dl>

</div>
</div>
<a id="a3f1e1cdce8cdbf4f060da4c6bb22df70" name="a3f1e1cdce8cdbf4f060da4c6bb22df70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1e1cdce8cdbf4f060da4c6bb22df70">&#9670;&nbsp;</a></span>variance() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::variance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; long &gt;&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the local variance within the given kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel_size</td><td>3-value size of kernel edge. </td></tr>
    <tr><td class="paramname">flag</td><td>selects type of output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The local variance within a kernel is calculated.
The calculation is threaded if compiled with GCD or OpenMP.
Flag values:
0   variance
1   standard deviation
2   poisson excess variance
</pre> </dd></dl>

</div>
</div>
<a id="a3d30db7452d06854cadb693a84e2385a" name="a3d30db7452d06854cadb693a84e2385a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d30db7452d06854cadb693a84e2385a">&#9670;&nbsp;</a></span>variance_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a> * Bimage::variance_mask </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lowvar</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bkg_flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a mask based on local variance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel_size</td><td>size of kernel edge. </td></tr>
    <tr><td class="paramname">lowvar</td><td>low variance threshold. </td></tr>
    <tr><td class="paramname">bkg_flag</td><td>flag to generate a background with value -1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* binary mask. <pre class="fragment">The local variance within a kernel is calculated and used to generate the mask.
A threshold is calculated to define the foreground and background.
Excluded regions are defined by a low variance parameter.
Foreground is set to 1, background is set to -1, excluded areas are set to 0.
</pre> </dd></dl>

</div>
</div>
<a id="ac78b4ad1046f5e78339620f7ac38309f" name="ac78b4ad1046f5e78339620f7ac38309f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78b4ad1046f5e78339620f7ac38309f">&#9670;&nbsp;</a></span>variance_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::variance_threshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lowvar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a threshold for a local variance image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowvar</td><td>low variance threshold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double threshold. <pre class="fragment">A threshold is calculated to define the foreground and background.
Excluded regions are defined by a low variance parameter.
</pre> </dd></dl>

</div>
</div>
<a id="a47314981f2e8b29a34b0eeba3f25e541" name="a47314981f2e8b29a34b0eeba3f25e541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47314981f2e8b29a34b0eeba3f25e541">&#9670;&nbsp;</a></span>vector3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector3.html">Vector3</a>&lt; double &gt; Bimage::vector3 </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 3-value vector at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector3.html">Vector3&lt;double&gt;</a> the 3-value vector. <pre class="fragment">The index refers to compound values.
</pre> </dd></dl>

</div>
</div>
<a id="aa3c2b8af69df7f99b805f0e0a226e59d" name="aa3c2b8af69df7f99b805f0e0a226e59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c2b8af69df7f99b805f0e0a226e59d">&#9670;&nbsp;</a></span>vector_to_simple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::vector_to_simple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector image is converted to a simple image. </p>
<pre class="fragment">The new value for each voxel is the length of each vector.
</pre> 
</div>
</div>
<a id="ab474ad5f14737ab4931c0171a5d95579" name="ab474ad5f14737ab4931c0171a5d95579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab474ad5f14737ab4931c0171a5d95579">&#9670;&nbsp;</a></span>view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::view </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>va</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab13be5e642f025a863a9ac1a50d75ab9" name="ab13be5e642f025a863a9ac1a50d75ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13be5e642f025a863a9ac1a50d75ab9">&#9670;&nbsp;</a></span>view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_view.html">View</a>&#160;</td>
          <td class="paramname"><em>vw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af38e5d5dbc312e6ee7f56a7c962e62d5" name="af38e5d5dbc312e6ee7f56a7c962e62d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38e5d5dbc312e6ee7f56a7c962e62d5">&#9670;&nbsp;</a></span>voxel_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Bimage::voxel_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e84daec20bb95e8212c96f06e308de5" name="a3e84daec20bb95e8212c96f06e308de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e84daec20bb95e8212c96f06e308de5">&#9670;&nbsp;</a></span>within_boundaries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Bimage::within_boundaries </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>zz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5185f2ed4cc550d97a5520280de9b48" name="af5185f2ed4cc550d97a5520280de9b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5185f2ed4cc550d97a5520280de9b48">&#9670;&nbsp;</a></span>within_boundaries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Bimage::within_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3.html">Vector3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3acc3a092a8e100f263dbf6625863b72" name="a3acc3a092a8e100f263dbf6625863b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acc3a092a8e100f263dbf6625863b72">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a> &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c09597809c7610566d5615cf9dbfca1" name="a7c09597809c7610566d5615cf9dbfca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c09597809c7610566d5615cf9dbfca1">&#9670;&nbsp;</a></span>zero_fourier_origin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bimage::zero_fourier_origin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zeroes the first voxel in each image. </p>

</div>
</div>
<a id="a32b57fc3c6d4e3ea245b11686bf4c8ae" name="a32b57fc3c6d4e3ea245b11686bf4c8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b57fc3c6d4e3ea245b11686bf4c8ae">&#9670;&nbsp;</a></span>zero_origin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Bimage::zero_origin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts the origins to zero with wrapping. </p>
<dl class="section return"><dt>Returns</dt><dd>int error code. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4c3d90a7e963c8fb653f825eb139b045" name="a4c3d90a7e963c8fb653f825eb139b045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3d90a7e963c8fb653f825eb139b045">&#9670;&nbsp;</a></span>image</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bsub__image.html">Bsub_image</a>* Bimage::image</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0195ccc461a1a7c1170461211e66f103" name="a0195ccc461a1a7c1170461211e66f103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0195ccc461a1a7c1170461211e66f103">&#9670;&nbsp;</a></span>next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a>* Bimage::next</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/heymannb/b20/bsoft/include/<a class="el" href="_bimage_8h.html">Bimage.h</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage_8cpp.html">Bimage.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__align_8cpp.html">Bimage_align.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__background_8cpp.html">Bimage_background.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__bin_8cpp.html">Bimage_bin.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__color_8cpp.html">Bimage_color.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__combine_8cpp.html">Bimage_combine.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__complex_8cpp.html">Bimage_complex.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__correlate_8cpp.html">Bimage_correlate.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__edit_8cpp.html">Bimage_edit.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__extract_8cpp.html">Bimage_extract.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__fft_8cpp.html">Bimage_fft.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__filter_8cpp.html">Bimage_filter.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__fspace_8cpp.html">Bimage_fspace.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__helix_8cpp.html">Bimage_helix.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__histogram_8cpp.html">Bimage_histogram.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__mask_8cpp.html">Bimage_mask.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__montage_8cpp.html">Bimage_montage.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__nad_8cpp.html">Bimage_nad.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__noise_8cpp.html">Bimage_noise.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__polar_8cpp.html">Bimage_polar.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__powerspectrum_8cpp.html">Bimage_powerspectrum.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__project_8cpp.html">Bimage_project.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__reconstruct_8cpp.html">Bimage_reconstruct.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__rescale_8cpp.html">Bimage_rescale.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__resize_8cpp.html">Bimage_resize.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__resolution_8cpp.html">Bimage_resolution.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__search_8cpp.html">Bimage_search.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__segment_8cpp.html">Bimage_segment.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__stats_8cpp.html">Bimage_stats.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__symmetry_8cpp.html">Bimage_symmetry.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__topo_8cpp.html">Bimage_topo.cpp</a></li>
<li>/Users/heymannb/b20/bsoft/src/img/<a class="el" href="_bimage__transform_8cpp.html">Bimage_transform.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_bimage.html">Bimage</a></li>
    <li class="footer">Generated on Fri Jan 7 2022 02:32:17 for Bsoft by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
