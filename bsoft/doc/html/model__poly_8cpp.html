<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bsoft: /Users/heymannb/b20/bsoft/src/model/model_poly.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Bsoft_icon128.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">Bsoft<span id="projectnumber">&#160;2.1.4</span>
   </div>
   <div id="projectbrief">Bernard&#39;s software package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('model__poly_8cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">model_poly.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Functions to manipulate polyhedral coordinate files.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="model__poly_8h.html">model_poly.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="model__transform_8h.html">model_transform.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="model__views_8h.html">model_views.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="model__util_8h.html">model_util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="matrix__linear_8h.html">matrix_linear.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="model__links_8h.html">model_links.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="model__compare_8h.html">model_compare.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="math__util_8h.html">math_util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="random__numbers_8h.html">random_numbers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="symmetry_8h.html">symmetry.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_vector3_8h.html">Vector3.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="linked__list_8h.html">linked_list.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="utilities_8h.html">utilities.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9de48502da3a35561d0f472c4d9113da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a9de48502da3a35561d0f472c4d9113da">NSMAX</a>&#160;&#160;&#160;100</td></tr>
<tr class="separator:a9de48502da3a35561d0f472c4d9113da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae222afe171915bf11ebb12ed1adf935f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#ae222afe171915bf11ebb12ed1adf935f">model_poly_faces</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="memdesc:ae222afe171915bf11ebb12ed1adf935f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates links between the vertices to define the polyhedron faces.  <a href="model__poly_8cpp.html#ae222afe171915bf11ebb12ed1adf935f">More...</a><br /></td></tr>
<tr class="separator:ae222afe171915bf11ebb12ed1adf935f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161dfce55680989088111159b165cbb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a161dfce55680989088111159b165cbb8">poly_get_connectivity</a> (<a class="el" href="class_bcomponent.html">Bcomponent</a> *comp, int ilink, int nlink, <a class="el" href="class_bpolygon.html">Bpolygon</a> *poly)</td></tr>
<tr class="separator:a161dfce55680989088111159b165cbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69630144dc2a1a5c121d2ce88195a4de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a69630144dc2a1a5c121d2ce88195a4de">model_poly_generate</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="memdesc:a69630144dc2a1a5c121d2ce88195a4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates polygons based on a vertex network.  <a href="model__poly_8cpp.html#a69630144dc2a1a5c121d2ce88195a4de">More...</a><br /></td></tr>
<tr class="separator:a69630144dc2a1a5c121d2ce88195a4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833472f113be3db0394f66c2c1977eab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a833472f113be3db0394f66c2c1977eab">model_vertex_types</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="memdesc:a833472f113be3db0394f66c2c1977eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the vertex type based on adjacent polygons.  <a href="model__poly_8cpp.html#a833472f113be3db0394f66c2c1977eab">More...</a><br /></td></tr>
<tr class="separator:a833472f113be3db0394f66c2c1977eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecf398aa430e1c4d4735c51d14077f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bstring.html">Bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#abecf398aa430e1c4d4735c51d14077f3">component_6digit_type</a> (<a class="el" href="class_bcomponent.html">Bcomponent</a> *comp)</td></tr>
<tr class="separator:abecf398aa430e1c4d4735c51d14077f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4ebc5cf734b6dc4079b90ecaacbe38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#aef4ebc5cf734b6dc4079b90ecaacbe38">model_extended_vertex_types</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="memdesc:aef4ebc5cf734b6dc4079b90ecaacbe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the vertex type based on adjacent and opposed polygons.  <a href="model__poly_8cpp.html#aef4ebc5cf734b6dc4079b90ecaacbe38">More...</a><br /></td></tr>
<tr class="separator:aef4ebc5cf734b6dc4079b90ecaacbe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ce252911a534fb6bd91bfa8f9ff2d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a13ce252911a534fb6bd91bfa8f9ff2d6">model_poly_dual</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>, int order)</td></tr>
<tr class="memdesc:a13ce252911a534fb6bd91bfa8f9ff2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dual of a polyhedral network.  <a href="model__poly_8cpp.html#a13ce252911a534fb6bd91bfa8f9ff2d6">More...</a><br /></td></tr>
<tr class="separator:a13ce252911a534fb6bd91bfa8f9ff2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d645d79148629e28359e6d56544483f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a3d645d79148629e28359e6d56544483f">model_poly_analyze</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="memdesc:a3d645d79148629e28359e6d56544483f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes a model for polygon regularity and planarity.  <a href="model__poly_8cpp.html#a3d645d79148629e28359e6d56544483f">More...</a><br /></td></tr>
<tr class="separator:a3d645d79148629e28359e6d56544483f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc37112393d5be62a4cbda6bcf9e748"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#afbc37112393d5be62a4cbda6bcf9e748">model_poly_links</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="memdesc:afbc37112393d5be62a4cbda6bcf9e748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all the model links.  <a href="model__poly_8cpp.html#afbc37112393d5be62a4cbda6bcf9e748">More...</a><br /></td></tr>
<tr class="separator:afbc37112393d5be62a4cbda6bcf9e748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7c3975f7ca736804cf3d2ab818540c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a7c7c3975f7ca736804cf3d2ab818540c">model_poly_angles</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="memdesc:a7c7c3975f7ca736804cf3d2ab818540c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all the polygon angles.  <a href="model__poly_8cpp.html#a7c7c3975f7ca736804cf3d2ab818540c">More...</a><br /></td></tr>
<tr class="separator:a7c7c3975f7ca736804cf3d2ab818540c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc64136b0d773295f36c483ea45c36ca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#acc64136b0d773295f36c483ea45c36ca">model_poly_regularity</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="memdesc:acc64136b0d773295f36c483ea45c36ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes a model for polygon regularity.  <a href="model__poly_8cpp.html#acc64136b0d773295f36c483ea45c36ca">More...</a><br /></td></tr>
<tr class="separator:acc64136b0d773295f36c483ea45c36ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42971b213f9ab2a2b2098a9286a7f31b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a42971b213f9ab2a2b2098a9286a7f31b">model_poly_planarity</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="memdesc:a42971b213f9ab2a2b2098a9286a7f31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes a model for polygon planarity.  <a href="model__poly_8cpp.html#a42971b213f9ab2a2b2098a9286a7f31b">More...</a><br /></td></tr>
<tr class="separator:a42971b213f9ab2a2b2098a9286a7f31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e483dc0ab7525ce728f656e6a4f7a59"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a4e483dc0ab7525ce728f656e6a4f7a59">model_poly_energy</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>, double angle_ref)</td></tr>
<tr class="memdesc:a4e483dc0ab7525ce728f656e6a4f7a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the different energy terms for all models.  <a href="model__poly_8cpp.html#a4e483dc0ab7525ce728f656e6a4f7a59">More...</a><br /></td></tr>
<tr class="separator:a4e483dc0ab7525ce728f656e6a4f7a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf230b314f43f17e0e225c34de14963f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#adf230b314f43f17e0e225c34de14963f">model_poly_pentagon_adjacency</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="memdesc:adf230b314f43f17e0e225c34de14963f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of edges shared by pentagons.  <a href="model__poly_8cpp.html#adf230b314f43f17e0e225c34de14963f">More...</a><br /></td></tr>
<tr class="separator:adf230b314f43f17e0e225c34de14963f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76055407ce2074fbd3dfb313748c72d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bstring.html">Bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a76055407ce2074fbd3dfb313748c72d3">model_poly_find_symmetry</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>, double threshold)</td></tr>
<tr class="memdesc:a76055407ce2074fbd3dfb313748c72d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the symmetry axes associated with polyhedral elements.  <a href="model__poly_8cpp.html#a76055407ce2074fbd3dfb313748c72d3">More...</a><br /></td></tr>
<tr class="separator:a76055407ce2074fbd3dfb313748c72d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744e4405963456b438652b1d6fe6c577"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a744e4405963456b438652b1d6fe6c577">model_poly_hand</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="memdesc:a744e4405963456b438652b1d6fe6c577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the polyhedron hand.  <a href="model__poly_8cpp.html#a744e4405963456b438652b1d6fe6c577">More...</a><br /></td></tr>
<tr class="separator:a744e4405963456b438652b1d6fe6c577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b5d8268cbe1605e1bdaba6ec97d20e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#af3b5d8268cbe1605e1bdaba6ec97d20e">model_poly_compare</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>, <a class="el" href="class_bmodel.html">Bmodel</a> *refmodel)</td></tr>
<tr class="memdesc:af3b5d8268cbe1605e1bdaba6ec97d20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a model with reference models based on the eigenvalues of the adjacency matrix.  <a href="model__poly_8cpp.html#af3b5d8268cbe1605e1bdaba6ec97d20e">More...</a><br /></td></tr>
<tr class="separator:af3b5d8268cbe1605e1bdaba6ec97d20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e203c334ff4e50c845f2b3aa9b557b"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a68e203c334ff4e50c845f2b3aa9b557b">model_poly_eigenvalues</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>, int <a class="el" href="rw_d_m_8cpp.html#ae83c07067345faf98c959261a0b7db76">show</a>)</td></tr>
<tr class="memdesc:a68e203c334ff4e50c845f2b3aa9b557b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the eigenvalues of the adjacency matrix for a model.  <a href="model__poly_8cpp.html#a68e203c334ff4e50c845f2b3aa9b557b">More...</a><br /></td></tr>
<tr class="separator:a68e203c334ff4e50c845f2b3aa9b557b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532a21a6752383d334666921d1635443"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a532a21a6752383d334666921d1635443">comp_count_connected</a> (<a class="el" href="class_bcomponent.html">Bcomponent</a> *comp)</td></tr>
<tr class="separator:a532a21a6752383d334666921d1635443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cd9f7fb76a95749027f5b1d23461ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a40cd9f7fb76a95749027f5b1d23461ae">model_number_connected_clusters</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="separator:a40cd9f7fb76a95749027f5b1d23461ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad675ba9708916b58990cd114b1aac8f0"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#ad675ba9708916b58990cd114b1aac8f0">model_poly_sphere_coor</a> (<a class="el" href="class_bmodel.html">Bmodel</a> *<a class="el" href="tcltk__bmodel_8cpp.html#a828359eaa8de833b547ac96934f43841">model</a>)</td></tr>
<tr class="memdesc:ad675ba9708916b58990cd114b1aac8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates coordinates for components based on the eigenvectors of the adjacency matrix.  <a href="model__poly_8cpp.html#ad675ba9708916b58990cd114b1aac8f0">More...</a><br /></td></tr>
<tr class="separator:ad675ba9708916b58990cd114b1aac8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0b2caeb4b6f130be43e5a2f0267dd453"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="model__poly_8cpp.html#a0b2caeb4b6f130be43e5a2f0267dd453">verbose</a></td></tr>
<tr class="separator:a0b2caeb4b6f130be43e5a2f0267dd453"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Functions to manipulate polyhedral coordinate files. </p>
<dl class="section author"><dt>Author</dt><dd>Bernard Heymann </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Created: 20010828 </dd>
<dd>
Modified: 20150208 </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9de48502da3a35561d0f472c4d9113da" name="a9de48502da3a35561d0f472c4d9113da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de48502da3a35561d0f472c4d9113da">&#9670;&nbsp;</a></span>NSMAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NSMAX&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a532a21a6752383d334666921d1635443" name="a532a21a6752383d334666921d1635443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532a21a6752383d334666921d1635443">&#9670;&nbsp;</a></span>comp_count_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comp_count_connected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bcomponent.html">Bcomponent</a> *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abecf398aa430e1c4d4735c51d14077f3" name="abecf398aa430e1c4d4735c51d14077f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecf398aa430e1c4d4735c51d14077f3">&#9670;&nbsp;</a></span>component_6digit_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bstring.html">Bstring</a> component_6digit_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bcomponent.html">Bcomponent</a> *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef4ebc5cf734b6dc4079b90ecaacbe38" name="aef4ebc5cf734b6dc4079b90ecaacbe38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4ebc5cf734b6dc4079b90ecaacbe38">&#9670;&nbsp;</a></span>model_extended_vertex_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int model_extended_vertex_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the vertex type based on adjacent and opposed polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The link flag of each component is asigned such that the order of the
rigth adjacent polygon is in the first digit, that of the left adjacent
polygon in the second digit, and that of the opposing polygon in the 
third digit.
New component types are generated.
</pre> </dd></dl>

</div>
</div>
<a id="a40cd9f7fb76a95749027f5b1d23461ae" name="a40cd9f7fb76a95749027f5b1d23461ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cd9f7fb76a95749027f5b1d23461ae">&#9670;&nbsp;</a></span>model_number_connected_clusters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int model_number_connected_clusters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d645d79148629e28359e6d56544483f" name="a3d645d79148629e28359e6d56544483f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d645d79148629e28359e6d56544483f">&#9670;&nbsp;</a></span>model_poly_analyze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int model_poly_analyze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyzes a model for polygon regularity and planarity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. </dd></dl>

</div>
</div>
<a id="a7c7c3975f7ca736804cf3d2ab818540c" name="a7c7c3975f7ca736804cf3d2ab818540c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7c3975f7ca736804cf3d2ab818540c">&#9670;&nbsp;</a></span>model_poly_angles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int model_poly_angles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates all the polygon angles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int number of angles. <pre class="fragment">The angles for each polygon is calculated and averaged. The overall 
statistics for every polygon order is shown.
</pre> </dd></dl>

</div>
</div>
<a id="af3b5d8268cbe1605e1bdaba6ec97d20e" name="af3b5d8268cbe1605e1bdaba6ec97d20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b5d8268cbe1605e1bdaba6ec97d20e">&#9670;&nbsp;</a></span>model_poly_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int model_poly_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>refmodel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares a model with reference models based on the eigenvalues of the adjacency matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
    <tr><td class="paramname">*refmodel</td><td>reference model(s) to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The comparison is based on the eigenvectors of the adjacency matrix,
which are related to spherical harmonics.
There are 3 P(sigma) eigenvectors giving the vertex coordinates.
These are usually (but not always) vectors 2, 3, and 4 ordered by eigenvalue.
The eigenvalues are characteristic for a polyhedron, although they may not be unique.
For every model identified, the model type is set from the reference ID.
The reference model selection is incremented to indicate the count. 

Dover Publications, Inc., Mineola, New York, pages 101 - 104.
</pre> Reference: Fowler, P.W. and Manolopoulos, D.E. (2006) An Atlas of Fullerenes. </dd></dl>

</div>
</div>
<a id="a13ce252911a534fb6bd91bfa8f9ff2d6" name="a13ce252911a534fb6bd91bfa8f9ff2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ce252911a534fb6bd91bfa8f9ff2d6">&#9670;&nbsp;</a></span>model_poly_dual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bmodel.html">Bmodel</a> * model_poly_dual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the dual of a polyhedral network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
    <tr><td class="paramname">order</td><td>order of polygons to convert to vertices, &lt; 3 = all. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bmodel* new model structure with the dual. <pre class="fragment">The polygons are first defined to calculate the dual network that
has vertices at the polygon centers.
</pre> </dd></dl>

</div>
</div>
<a id="a68e203c334ff4e50c845f2b3aa9b557b" name="a68e203c334ff4e50c845f2b3aa9b557b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e203c334ff4e50c845f2b3aa9b557b">&#9670;&nbsp;</a></span>model_poly_eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; model_poly_eigenvalues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>show</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the eigenvalues of the adjacency matrix for a model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure (modified with the topological coordinates). </td></tr>
    <tr><td class="paramname">show</td><td>flag to show eigenvalues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt; eigenvalues. <pre class="fragment">The eigenvectors of the adjacency matrix are related to spherical harmonics.
The eigenvalues are characteristic for a polyhedron, although they may not be unique.
Only the first model in the list is processed.

Dover Publications, Inc., Mineola, New York, pages 101 - 104.
</pre> Reference: Fowler, P.W. and Manolopoulos, D.E. (2006) An Atlas of Fullerenes. </dd></dl>

</div>
</div>
<a id="a4e483dc0ab7525ce728f656e6a4f7a59" name="a4e483dc0ab7525ce728f656e6a4f7a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e483dc0ab7525ce728f656e6a4f7a59">&#9670;&nbsp;</a></span>model_poly_energy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double model_poly_energy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the different energy terms for all models. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
    <tr><td class="paramname">angle_ref</td><td>reference angle (&lt;=0 to use the polygon angle). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double 0. <pre class="fragment">The angular energy is calculated either with a given reference angle,
or with the nominal polygon inner angle as reference.
Regularity is defined as the adherence to a constant distance of each
vertex from the polygon center. The polygon area is:
     n * s^2       1 + cos(2*PI/n)
A = ------- sqrt(-----------------)
       4           1 - cos(2*PI/n)
where n is the number of vertices in the polygon.
The contribution of each polygon to the polyhedral volume is:
V = A * dc / 3
where dc is the distance of the polygon center to the polyhedral center.
</pre> </dd></dl>

</div>
</div>
<a id="ae222afe171915bf11ebb12ed1adf935f" name="ae222afe171915bf11ebb12ed1adf935f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae222afe171915bf11ebb12ed1adf935f">&#9670;&nbsp;</a></span>model_poly_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int model_poly_faces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates links between the vertices to define the polyhedron faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">Two vertices are linked only when they are on the surface of the 
polyhedron, i.e., all other vertices are on one side of the pair 
of vertices. This is only true if there are no other vertices v
with the following property:
    v•v0 &gt; v0•v0
where v0 is the average of the two vertices considered for linkage.
Only the first model is processed.
</pre> </dd></dl>

</div>
</div>
<a id="a76055407ce2074fbd3dfb313748c72d3" name="a76055407ce2074fbd3dfb313748c72d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76055407ce2074fbd3dfb313748c72d3">&#9670;&nbsp;</a></span>model_poly_find_symmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bstring.html">Bstring</a> model_poly_find_symmetry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the symmetry axes associated with polyhedral elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
    <tr><td class="paramname">threshold</td><td>cutoff to flag a symmetry axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_bstring.html">Bstring</a> symmetry string. <pre class="fragment">Symmetry axes are associated with specific elements:
    link        reflection and 2-fold axis.
    vertex      n-fold axis based on vertex order.
    polygon     n-fold axis based on polygon order.
Only the first model in the list is processed.
</pre> </dd></dl>

</div>
</div>
<a id="a69630144dc2a1a5c121d2ce88195a4de" name="a69630144dc2a1a5c121d2ce88195a4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69630144dc2a1a5c121d2ce88195a4de">&#9670;&nbsp;</a></span>model_poly_generate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int model_poly_generate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates polygons based on a vertex network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The search startegy is to start at a vertex and then search always turning into
the same direction. First the outward pointing normal for each vertex is
calculated. Then the connectivity is followed always turning in the same 
direction at each vertex.
</pre> </dd></dl>

</div>
</div>
<a id="a744e4405963456b438652b1d6fe6c577" name="a744e4405963456b438652b1d6fe6c577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744e4405963456b438652b1d6fe6c577">&#9670;&nbsp;</a></span>model_poly_hand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int model_poly_hand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the polyhedron hand. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int hand sign. <pre class="fragment">The hand of a polyhedron is based on the sign of the rotational strength 
element associated with the first two eigenvectors of the adjacency matrix.
It is assumed that the symmetry has been determined.
The hand sign is:
    0   no handedness.
    1   one enantiomorph.
    -1  other enantiomorph.
</pre> </dd></dl>

</div>
</div>
<a id="afbc37112393d5be62a4cbda6bcf9e748" name="afbc37112393d5be62a4cbda6bcf9e748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc37112393d5be62a4cbda6bcf9e748">&#9670;&nbsp;</a></span>model_poly_links()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int model_poly_links </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates all the model links. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int number of links. </dd></dl>

</div>
</div>
<a id="adf230b314f43f17e0e225c34de14963f" name="adf230b314f43f17e0e225c34de14963f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf230b314f43f17e0e225c34de14963f">&#9670;&nbsp;</a></span>model_poly_pentagon_adjacency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int model_poly_pentagon_adjacency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the number of edges shared by pentagons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int number of edges shared by pentagons for last model. </dd></dl>

</div>
</div>
<a id="a42971b213f9ab2a2b2098a9286a7f31b" name="a42971b213f9ab2a2b2098a9286a7f31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42971b213f9ab2a2b2098a9286a7f31b">&#9670;&nbsp;</a></span>model_poly_planarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double model_poly_planarity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyzes a model for polygon planarity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double standard deviation from planarity. <pre class="fragment">A plane is fit through the polygon vertices and the normal calculated from:
    n•p = d
where n is the normal vector, p is a point in the plane, and d is the offset.
The polygon planarity is defined as the root-mean-square-deviation from 
the fitted plane.
</pre> </dd></dl>

</div>
</div>
<a id="acc64136b0d773295f36c483ea45c36ca" name="acc64136b0d773295f36c483ea45c36ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc64136b0d773295f36c483ea45c36ca">&#9670;&nbsp;</a></span>model_poly_regularity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double model_poly_regularity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyzes a model for polygon regularity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double standard deviation from regularity. <pre class="fragment">Regularity is defined as the adherence to a constant distance of each
vertex from the polygon center. The polygon area is:
     n * s^2       1 + cos(2*PI/n)
A = ------- sqrt(-----------------)
       4           1 - cos(2*PI/n)
where n is the number of vertices in the polygon.
The contribution of each polygon to the polyhedral volume is:
V = A * dc / 3
where dc is the distance of the polygon center to the polyhedral center.
</pre> </dd></dl>

</div>
</div>
<a id="ad675ba9708916b58990cd114b1aac8f0" name="ad675ba9708916b58990cd114b1aac8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad675ba9708916b58990cd114b1aac8f0">&#9670;&nbsp;</a></span>model_poly_sphere_coor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; model_poly_sphere_coor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates coordinates for components based on the eigenvectors of the adjacency matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvector&lt;double&gt; eigenvalues. <pre class="fragment">The eigenvectors of the adjacency matrix are related to spherical harmonics.
There are 3 P(sigma) eigenvectors giving the vertex coordinates.
These are usually (but not always) vectors 2, 3, and 4 ordered by eigenvalue.
The actual 3 P(sigma) eigenvectors are identified as those having exactly
a single node, i.e., closely connected vertices cluster together in every dimension.
The eigenvalues are characteristic for a polyhedron, although they may not be unique.

Dover Publications, Inc., Mineola, New York, pages 101 - 104.
</pre> Reference: Fowler, P.W. and Manolopoulos, D.E. (2006) An Atlas of Fullerenes. </dd></dl>

</div>
</div>
<a id="a833472f113be3db0394f66c2c1977eab" name="a833472f113be3db0394f66c2c1977eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833472f113be3db0394f66c2c1977eab">&#9670;&nbsp;</a></span>model_vertex_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int model_vertex_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bmodel.html">Bmodel</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the vertex type based on adjacent polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*model</td><td>model structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The polygon order is written into flags for vertex links in one
direction for each polygon.
New component types are generated.
</pre> </dd></dl>

</div>
</div>
<a id="a161dfce55680989088111159b165cbb8" name="a161dfce55680989088111159b165cbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161dfce55680989088111159b165cbb8">&#9670;&nbsp;</a></span>poly_get_connectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int poly_get_connectivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bcomponent.html">Bcomponent</a> *&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ilink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nlink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bpolygon.html">Bpolygon</a> *&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0b2caeb4b6f130be43e5a2f0267dd453" name="a0b2caeb4b6f130be43e5a2f0267dd453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2caeb4b6f130be43e5a2f0267dd453">&#9670;&nbsp;</a></span>verbose</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int verbose</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_5dd65160827af56e6353642206b80129.html">model</a></li><li class="navelem"><a class="el" href="model__poly_8cpp.html">model_poly.cpp</a></li>
    <li class="footer">Generated on Fri Jan 7 2022 02:32:17 for Bsoft by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
