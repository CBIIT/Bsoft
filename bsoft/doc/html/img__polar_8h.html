<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Bsoft: /usr/local/bsoft/include/img_polar.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Bsoft_icon128.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bsoft
   &#160;<span id="projectnumber">1.9</span>
   </div>
   <div id="projectbrief">Bernard&#39;s software package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('img__polar_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">img_polar.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Library routines for polar and spherical transformations and calculations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="rwimg_8h_source.html">rwimg.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="symmetry_8h_source.html">symmetry.h</a>&quot;</code><br />
</div>
<p><a href="img__polar_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae8ba32e1c6e5f22eec608e8382acd726"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="img__polar_8h.html#ae8ba32e1c6e5f22eec608e8382acd726">img_cartesian_to_spherical</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, int nannuli, int ntheta, int nphi)</td></tr>
<tr class="memdesc:ae8ba32e1c6e5f22eec608e8382acd726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an image with spherical coordinates.  <a href="#ae8ba32e1c6e5f22eec608e8382acd726">More...</a><br /></td></tr>
<tr class="separator:ae8ba32e1c6e5f22eec608e8382acd726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab541565a686c52a7ff5288d5a0de72d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="img__polar_8h.html#ab541565a686c52a7ff5288d5a0de72d5">img_cartesian_to_cylindrical</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, int nannuli, int nphi)</td></tr>
<tr class="memdesc:ab541565a686c52a7ff5288d5a0de72d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an image with cylindrical coordinates.  <a href="#ab541565a686c52a7ff5288d5a0de72d5">More...</a><br /></td></tr>
<tr class="separator:ab541565a686c52a7ff5288d5a0de72d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cff4f8038159cb273bd38a8cb405e44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="img__polar_8h.html#a7cff4f8038159cb273bd38a8cb405e44">img_radial_shells</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:a7cff4f8038159cb273bd38a8cb405e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an image with slices representing radial shell projections.  <a href="#a7cff4f8038159cb273bd38a8cb405e44">More...</a><br /></td></tr>
<tr class="separator:a7cff4f8038159cb273bd38a8cb405e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e4bba69ac7ad4f848dd5038b0ead04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="img__polar_8h.html#af5e4bba69ac7ad4f848dd5038b0ead04">img_cylindrical_shells</a> (<a class="el" href="class_bimage.html">Bimage</a> *p)</td></tr>
<tr class="memdesc:af5e4bba69ac7ad4f848dd5038b0ead04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an image with slices representing cylindrical shell projections.  <a href="#af5e4bba69ac7ad4f848dd5038b0ead04">More...</a><br /></td></tr>
<tr class="separator:af5e4bba69ac7ad4f848dd5038b0ead04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cb623b3487c04e3e7e7f5d3c5c4eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="img__polar_8h.html#a45cb623b3487c04e3e7e7f5d3c5c4eb1">img_radial_sections</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double rad_start, double rad_end, double rad_step, double spherical_fraction, <a class="el" href="class_bstring.html">Bstring</a> &amp;symmetry_string)</td></tr>
<tr class="memdesc:a45cb623b3487c04e3e7e7f5d3c5c4eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an image with slices giving the radial section projections.  <a href="#a45cb623b3487c04e3e7e7f5d3c5c4eb1">More...</a><br /></td></tr>
<tr class="separator:a45cb623b3487c04e3e7e7f5d3c5c4eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb34877b829ec2371ae2acd342b63c6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="img__polar_8h.html#afb34877b829ec2371ae2acd342b63c6e">img_polar_transform</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, int nannuli, int nangles, int ann_min, int ann_max)</td></tr>
<tr class="memdesc:afb34877b829ec2371ae2acd342b63c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a cartesian image to polar or cylindrical coordinates.  <a href="#afb34877b829ec2371ae2acd342b63c6e">More...</a><br /></td></tr>
<tr class="separator:afb34877b829ec2371ae2acd342b63c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c138536fe7af8588b13eb18afd1c08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="img__polar_8h.html#a53c138536fe7af8588b13eb18afd1c08">img_polar_power_spectrum</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, int nannuli, int npsi, int transform_flag, int norm_flag)</td></tr>
<tr class="memdesc:a53c138536fe7af8588b13eb18afd1c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the polar power spectrum from a Fourier transform.  <a href="#a53c138536fe7af8588b13eb18afd1c08">More...</a><br /></td></tr>
<tr class="separator:a53c138536fe7af8588b13eb18afd1c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac262a6e42eb76b23fa88147b2988c737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="img__polar_8h.html#ac262a6e42eb76b23fa88147b2988c737">img_polar_power_spectrum</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, double resolution, long num_angle)</td></tr>
<tr class="memdesc:ac262a6e42eb76b23fa88147b2988c737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the polar power spectrum of an image.  <a href="#ac262a6e42eb76b23fa88147b2988c737">More...</a><br /></td></tr>
<tr class="separator:ac262a6e42eb76b23fa88147b2988c737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bca9ff7261fe2afcd71d036cc24472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="img__polar_8h.html#a15bca9ff7261fe2afcd71d036cc24472">img_polar2D</a> (<a class="el" href="class_bimage.html">Bimage</a> *p, int nannuli, int nseg)</td></tr>
<tr class="memdesc:a15bca9ff7261fe2afcd71d036cc24472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates radial segment averages from an image.  <a href="#a15bca9ff7261fe2afcd71d036cc24472">More...</a><br /></td></tr>
<tr class="separator:a15bca9ff7261fe2afcd71d036cc24472"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Library routines for polar and spherical transformations and calculations. </p>
<dl class="section author"><dt>Author</dt><dd>Bernard Heymann </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Created: 19990904 Modified: 20140710 </dd></dl>

<p>Definition in file <a class="el" href="img__polar_8h_source.html">img_polar.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab541565a686c52a7ff5288d5a0de72d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int img_cartesian_to_cylindrical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nannuli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nphi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an image with cylindrical coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>3D image (converted). </td></tr>
    <tr><td class="paramname">nannuli</td><td>number of annuli. </td></tr>
    <tr><td class="paramname">nphi</td><td>number of phi angles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is converted to cylindrical form with a specified number of 
annuli and angles. 
A point vector p = {x,y,z} with respect to the image origin (typically
the center of the image) is converted to cylindrical coordinates as follows:
    The distance from the z-origin gives the annulus:
        |p| = sqrt(x*x+y*y)
    Phi is the rotation angle around the z-axis, starting at the x-axis:
        phi = atan(y/x)
    The z-coordinate remains unchanged.
The new dimensions are mapped as follows with their maximum ranges:
    |p|   ===&gt; x_dimension (0 - max(x_size,y_size,z_size)
    phi   ===&gt; y_dimension (0 - 2*PI)
    z     ===&gt; z_dimension
The sampling within these ranges are given by the calling function.
The sampling must be isotropic.
The origins within the sub-image structures are used.
The interpolation routine actually calculates the old cartesian 
coordinates for each set of cylindrical coordinates.</pre> </dd></dl>

<p>Definition at line <a class="el" href="img__polar_8cpp_source.html#l00154">154</a> of file <a class="el" href="img__polar_8cpp_source.html">img_polar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8ba32e1c6e5f22eec608e8382acd726"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int img_cartesian_to_spherical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nannuli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ntheta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an image with spherical coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>3D image (converted). </td></tr>
    <tr><td class="paramname">nannuli</td><td>number of annuli. </td></tr>
    <tr><td class="paramname">nphi</td><td>number of phi angles. </td></tr>
    <tr><td class="paramname">ntheta</td><td>number of theta angles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The image is converted to polar form with a specified number of annuli
and angles in one (a 2D image) or two (a 3D map) directions. The 
angular convention is consistent with the Euler angles used for 3D
image processing. 
A point vector p = {x,y,z} with respect to the image origin (typically
the center of the image) is converted to polar coordinates as follows:
    The size of the vector gives the annulus:
        |p| = sqrt(x*x+y*y+z*z)
    Phi is the rotation angle around the z-axis, starting at the x-axis:
        phi = atan(y/x)
    Theta is the angle between the positive z-axis and the point vector:
        theta = acos(z/|p|)
The new dimensions are mapped as follows with their maximum ranges:
    |p|   ===&gt; x_dimension (0 - max(x_size,y_size,z_size)
    phi   ===&gt; y_dimension (0 - 2*PI)
    theta ===&gt; z_dimension (0 - PI)
The sampling within these ranges are given by the calling function.
The sampling must be isotropic.
The origins within the sub-image structures are used.
The interpolation routine actually calculates the old cartesian 
coordinates for each set of spherical coordinates.</pre> </dd></dl>

<p>Definition at line <a class="el" href="img__polar_8cpp_source.html#l00050">50</a> of file <a class="el" href="img__polar_8cpp_source.html">img_polar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5e4bba69ac7ad4f848dd5038b0ead04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int img_cylindrical_shells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an image with slices representing cylindrical shell projections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>3D image (converted). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The 3D image is converted so that the sections contain 2D projections
of cylindrical shells. The projection in slice i is defined for:
    i &gt;= sqrt(x^2 + y^2)
The first projection is placed at the z origin and radiates out into
both positive and negative directions.
Sampling in x and y is not changed.
The sampling must be isotropic.</pre> </dd></dl>

<p>Definition at line <a class="el" href="img__polar_8cpp_source.html#l00327">327</a> of file <a class="el" href="img__polar_8cpp_source.html">img_polar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15bca9ff7261fe2afcd71d036cc24472"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a>* img_polar2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nannuli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nseg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates radial segment averages from an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>2D image. </td></tr>
    <tr><td class="paramname">nannuli</td><td>number of annuli. </td></tr>
    <tr><td class="paramname">nseg</td><td>number of segments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* the polar 2D image. <pre class="fragment">An integrative method is used to calculate radial segment averages.
Restrictions: The data type may not be complex.
The x-axis in the polar image represents the annulus and the y-axis
represents the angle.
A new image is returned.</pre> </dd></dl>

<p>Definition at line <a class="el" href="img__polar_8cpp_source.html#l00874">874</a> of file <a class="el" href="img__polar_8cpp_source.html">img_polar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53c138536fe7af8588b13eb18afd1c08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a>* img_polar_power_spectrum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nannuli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>transform_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the polar power spectrum from a Fourier transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>2D/3D Fourier transform or power spectrum. </td></tr>
    <tr><td class="paramname">nannuli</td><td>number of annuli or radii. </td></tr>
    <tr><td class="paramname">npsi</td><td>number of angles. </td></tr>
    <tr><td class="paramname">transform_flag</td><td>flag causing transformation first. </td></tr>
    <tr><td class="paramname">norm_flag</td><td>flag to normalize each annulus by its maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* radial power spectrum in the form of a 2D image. <pre class="fragment">A polar power spectrum of a 2D Fourier transform is calculated.  
An interpolative method is used where the value at a specific
radius and angle is obtained from contributions of the four
surrounding pixels in the original image. To overcome the sparse
sampling at high annuli, a large annulus is first extracted by
interpolation and then averaged for each segment.
The x-axis in the polar image represents the angle and the y-axis
represents the annulus.
Each annulus may be normalized by the maximum in the annulus.
The first angle is zero and the angular step size is 2*pi/npsi.</pre> </dd></dl>

<p>Definition at line <a class="el" href="img__polar_8cpp_source.html#l00673">673</a> of file <a class="el" href="img__polar_8cpp_source.html">img_polar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac262a6e42eb76b23fa88147b2988c737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a>* img_polar_power_spectrum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>num_angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the polar power spectrum of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>2D Fourier transform. </td></tr>
    <tr><td class="paramname">resolution</td><td>high resolution limit. </td></tr>
    <tr><td class="paramname">num_angle</td><td>number of angles to use for interpolation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* polar power spectrum. <pre class="fragment">The length of each annulus is NANG times the radial offset.
The samples on each annulus are calculated by bilinear interpolation.
The maximum annulus calculated depends on the resolution limit specified
in the input image.</pre> </dd></dl>

<p>Definition at line <a class="el" href="img__polar_8cpp_source.html#l00808">808</a> of file <a class="el" href="img__polar_8cpp_source.html">img_polar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb34877b829ec2371ae2acd342b63c6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a>* img_polar_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nannuli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ann_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ann_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a cartesian image to polar or cylindrical coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>2D/3D Fourier transform or power spectrum. </td></tr>
    <tr><td class="paramname">nannuli</td><td>number of annuli or radii. </td></tr>
    <tr><td class="paramname">nangles</td><td>number of angles. </td></tr>
    <tr><td class="paramname">ann_min</td><td>first annulus to calculate. </td></tr>
    <tr><td class="paramname">ann_max</td><td>last annulus to calculate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* polar (cylindrical) image. <pre class="fragment">An interpolative method is used where the value at a specific
radius and angle is obtained from contributions of the four
surrounding pixels in the original image.
The x-axis in the polar image represents the angle and the y-axis
represents the annulus.
Only the specified range of annuli is calculated to save time.
The first angle is zero and the angular step size is 2*pi/nangles.
The data type of the polar image is always floating point.</pre> </dd></dl>

<p>Definition at line <a class="el" href="img__polar_8cpp_source.html#l00573">573</a> of file <a class="el" href="img__polar_8cpp_source.html">img_polar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a45cb623b3487c04e3e7e7f5d3c5c4eb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bimage.html">Bimage</a>* img_radial_sections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>spherical_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bstring.html">Bstring</a> &amp;&#160;</td>
          <td class="paramname"><em>symmetry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an image with slices giving the radial section projections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>3D image. </td></tr>
    <tr><td class="paramname">rad_start</td><td>starting radius (voxels). </td></tr>
    <tr><td class="paramname">rad_end</td><td>ending radius (voxels). </td></tr>
    <tr><td class="paramname">rad_step</td><td>radial step size (voxels). </td></tr>
    <tr><td class="paramname">spherical_fraction</td><td>fraction of spherical section (requires symmetry). </td></tr>
    <tr><td class="paramname">&amp;symmetry_string</td><td>symmetry for non-spherical sections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bimage* image with radial sections. <pre class="fragment">The 3D image is converted so that the sections contain 2D projections
of radial shells. The projection in slice i is defined for:
    i &gt;= sqrt(x^2 + y^2)
Non-spherical sections can be generated by specifying the symmetry and
the fraction of spherical nature (1=spherical, 0=based on symmetry).
Sampling in x and y is not changed.
The sampling in the input map must be isotropic.</pre> </dd></dl>

<p>Definition at line <a class="el" href="img__polar_8cpp_source.html#l00509">509</a> of file <a class="el" href="img__polar_8cpp_source.html">img_polar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7cff4f8038159cb273bd38a8cb405e44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int img_radial_shells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bimage.html">Bimage</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an image with slices representing radial shell projections. </p>
<dl class="section return"><dt>Returns</dt><dd>int 0. <pre class="fragment">The 3D image is converted so that the sections contain 2D projections
of radial shells. The projection in slice z is defined for:
    z &gt;= sqrt((x-xo)^2 + (y-yo)^2) + zo
The first projection is placed at the z origin and radiates out into
both positive and negative directions.
Sampling in x and y is not changed.
The sampling must be isotropic.
</pre></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*p</td><td>3D image (converted). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="img__polar_8cpp_source.html#l00252">252</a> of file <a class="el" href="img__polar_8cpp_source.html">img_polar.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="img__polar_8h.html">img_polar.h</a></li>
    <li class="footer">Generated on Fri Aug 7 2015 17:03:19 for Bsoft by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
