.TH "Bimage" 3 "Wed Sep 1 2021" "Version 2.1.0" "Bsoft" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Bimage \- General image parameter class\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Bimage\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBBimage\fP ()"
.br
.RI "Initializes an image\&. "
.ti -1c
.RI "\fBBimage\fP (const \fBBimage\fP &p)"
.br
.RI "The copy constructor\&. "
.ti -1c
.RI "\fBBimage\fP (\fBBstring\fP &fn, int readdata, int img_select)"
.br
.RI "Reads an image from a file\&. "
.ti -1c
.RI "\fBBimage\fP (\fBDataType\fP type, \fBCompoundType\fP ctype, long nx, long ny, long nz, long nn)"
.br
.RI "Initializes an image\&. "
.ti -1c
.RI "\fBBimage\fP (\fBDataType\fP type, \fBCompoundType\fP ctype, \fBVector3\fP< long > \fBsize\fP, long nn)"
.br
.RI "Initializes an image\&. "
.ti -1c
.RI "\fBBimage\fP (\fBDataType\fP type, \fBCompoundType\fP ctype, vector< long > \fBsize\fP, long nn)"
.br
.RI "Initializes an image\&. "
.ti -1c
.RI "\fBBimage\fP (\fBDataType\fP type, long nc, long nx, long ny, long nz, long nn)"
.br
.RI "Initializes a generic multi-channel image\&. "
.ti -1c
.RI "\fBBimage\fP (\fBDataType\fP type, long nc, \fBVector3\fP< long > \fBsize\fP, long nn)"
.br
.RI "Initializes a generic multi-channel image\&. "
.ti -1c
.RI "\fBBimage\fP (\fBMatrix\fP &mat, long scale)"
.br
.RI "Initializes an image from a 2D matrix\&. "
.ti -1c
.RI "\fB~Bimage\fP ()"
.br
.RI "Image destructor\&. "
.ti -1c
.RI "\fBCompoundType\fP \fBguess_compoundtype\fP (long nc)"
.br
.ti -1c
.RI "bool \fBcheck_compoundtype\fP (long nc, \fBCompoundType\fP ct)"
.br
.ti -1c
.RI "void \fBcheck\fP ()"
.br
.RI "Checks an image for reasonable properties\&. "
.ti -1c
.RI "bool \fBcheck_if_same_size\fP (\fBBimage\fP *p)"
.br
.RI "Check if two images are the same size\&. "
.ti -1c
.RI "bool \fBcheck_if_same_image_size\fP (\fBBimage\fP *p)"
.br
.RI "Check if two images are the same size\&. "
.ti -1c
.RI "void \fBcheck_sampling\fP ()"
.br
.RI "Checks that the sampling is properly specified\&. "
.ti -1c
.RI "void \fBcheck_resolution\fP (double &resolution)"
.br
.RI "Checks that the resolution falls within reasonable limits\&. "
.ti -1c
.RI "bool \fBcompatible\fP (\fBBimage\fP *p)"
.br
.RI "Check if this image has the same number of channels and data type as another\&. "
.ti -1c
.RI "void \fBidentifier\fP (\fBBstring\fP s)"
.br
.ti -1c
.RI "\fBBstring\fP & \fBidentifier\fP ()"
.br
.ti -1c
.RI "\fBJSvalue\fP & \fBmeta_data\fP ()"
.br
.ti -1c
.RI "\fBJSvalue\fP & \fBoperator[]\fP (string tag)"
.br
.ti -1c
.RI "vector< \fBJSvalue\fP * > \fBquery\fP (string &path)"
.br
.ti -1c
.RI "long \fBerase\fP (string tag)"
.br
.ti -1c
.RI "void \fBmeta_data_update\fP ()"
.br
.RI "Update metadata from the sub-image information\&. "
.ti -1c
.RI "void \fBupdate_from_meta_data\fP ()"
.br
.RI "Update sub-image information from the metadata\&. "
.ti -1c
.RI "void \fBmeta_data_retain_one_image\fP (long img_num)"
.br
.RI "Erases all sub-image records from the meta data except one\&. "
.ti -1c
.RI "void \fBfile_name\fP (string s)"
.br
.ti -1c
.RI "string & \fBfile_name\fP ()"
.br
.ti -1c
.RI "\fBBimage\fP * \fBfind\fP (\fBBstring\fP fn)"
.br
.ti -1c
.RI "void \fBlabel\fP (string s)"
.br
.ti -1c
.RI "string & \fBlabel\fP ()"
.br
.ti -1c
.RI "time_t \fBget_time\fP ()"
.br
.ti -1c
.RI "tm * \fBget_localtime\fP ()"
.br
.ti -1c
.RI "void \fBset_time\fP (time_t t)"
.br
.ti -1c
.RI "void \fBset_time\fP (tm *t)"
.br
.ti -1c
.RI "long \fBalloc_size\fP () const"
.br
.ti -1c
.RI "long \fBdata_size\fP ()"
.br
.ti -1c
.RI "unsigned char * \fBdata_alloc\fP ()"
.br
.ti -1c
.RI "unsigned char * \fBdata_alloc_and_clear\fP ()"
.br
.ti -1c
.RI "unsigned char * \fBdata_alloc\fP (long nbytes)"
.br
.RI "Allocate image data\&. "
.ti -1c
.RI "unsigned char * \fBdata_alloc_and_clear\fP (long nbytes)"
.br
.ti -1c
.RI "unsigned char * \fBdata_alloc\fP (\fBDataType\fP type, \fBCompoundType\fP ctype, long nx, long ny, long nz, long nn)"
.br
.RI "Allocate image data with size parameters\&. "
.ti -1c
.RI "unsigned char * \fBdata_alloc_and_clear\fP (\fBDataType\fP type, \fBCompoundType\fP ctype, long nx, long ny, long nz, long nn)"
.br
.ti -1c
.RI "unsigned char * \fBdata_assign\fP (unsigned char *nudata)"
.br
.RI "Assign image data\&. "
.ti -1c
.RI "unsigned char * \fBdata_pointer\fP ()"
.br
.ti -1c
.RI "unsigned char * \fBdata_pointer\fP (long offset)"
.br
.ti -1c
.RI "void \fBdata_pointer\fP (unsigned char *ptr)"
.br
.ti -1c
.RI "void \fBdata_delete\fP ()"
.br
.RI "Deallocates the image data\&. "
.ti -1c
.RI "long \fBdata_offset\fP ()"
.br
.ti -1c
.RI "void \fBdata_offset\fP (long doff)"
.br
.ti -1c
.RI "long \fBimage_size\fP ()"
.br
.ti -1c
.RI "\fBBimage\fP & \fBoperator=\fP (const \fBBimage\fP &p)"
.br
.RI "Assigns an image\&. "
.ti -1c
.RI "double \fBoperator[]\fP (long j) const"
.br
.RI "Returns the data value at the given index\&. "
.ti -1c
.RI "double \fBget\fP (long nn, long xx, long yy, long zz, long cc=0)"
.br
.RI "Returns the data value at the given coordinates\&. "
.ti -1c
.RI "double \fBget\fP (long nn, \fBVector3\fP< double > vox, long cc=0)"
.br
.RI "Returns the data value at the given coordinates\&. "
.ti -1c
.RI "vector< double > \fBvalues\fP (long i)"
.br
.ti -1c
.RI "void \fBvalues\fP (long i, vector< double > val)"
.br
.ti -1c
.RI "vector< double > \fBvalues\fP (long nn, \fBVector3\fP< double > vox)"
.br
.RI "Returns an array with all channel data at the given coordinates\&. "
.ti -1c
.RI "\fBComplex\fP< double > \fBcomplex\fP (long j)"
.br
.RI "Returns a complex value at the given index\&. "
.ti -1c
.RI "\fBVector3\fP< double > \fBvector3\fP (long j)"
.br
.RI "Returns a 3-value vector at the given index\&. "
.ti -1c
.RI "\fBRGB\fP< double > \fBrgb\fP (long j)"
.br
.RI "Returns a color value at the given index\&. "
.ti -1c
.RI "\fBRGBA\fP< double > \fBrgba\fP (long j)"
.br
.RI "Returns a color value at the given index\&. "
.ti -1c
.RI "\fBCMYK\fP< double > \fBcmyk\fP (long j)"
.br
.RI "Returns a color value at the given index\&. "
.ti -1c
.RI "\fBTypePointer\fP \fBfill_value\fP (double v)"
.br
.ti -1c
.RI "void \fBset\fP (long j, double v)"
.br
.RI "Sets a single value at the given index\&. "
.ti -1c
.RI "void \fBset\fP (long j, \fBComplex\fP< double > cv)"
.br
.RI "Sets a complex value at the given index\&. "
.ti -1c
.RI "void \fBset\fP (long j, \fBRGB\fP< double > color)"
.br
.RI "Sets a color value at the given index\&. "
.ti -1c
.RI "void \fBset\fP (long j, \fBRGBA\fP< double > color)"
.br
.RI "Sets a color value at the given index\&. "
.ti -1c
.RI "void \fBset\fP (long j, \fBCMYK\fP< double > color)"
.br
.RI "Sets a color value at the given index\&. "
.ti -1c
.RI "void \fBset\fP (long j, \fBVector3\fP< double > vec)"
.br
.RI "Sets a 3-value vector at the given index\&. "
.ti -1c
.RI "void \fBset\fP (long j, \fBView\fP \fBview\fP)"
.br
.RI "Sets a 3-value vector at the given index\&. "
.ti -1c
.RI "void \fBadd\fP (long j, double v)"
.br
.ti -1c
.RI "void \fBadd\fP (long j, \fBComplex\fP< double > cv)"
.br
.ti -1c
.RI "void \fBadd\fP (double xx, double yy, double zz, long nn, double v)"
.br
.RI "Adds a value at a given location to neigboring data elements\&. "
.ti -1c
.RI "void \fBset_max\fP (double xx, double yy, double zz, long nn, double v)"
.br
.RI "Sets a value at a given location to neigboring data elements if it is larger\&. "
.ti -1c
.RI "void \fBmultiply\fP (long j, \fBComplex\fP< double > cv)"
.br
.ti -1c
.RI "double \fBaverage2D\fP (long cc, double xf, double yf, double zf, long nn, double iscale)"
.br
.RI "Averages in the xy plane when scaling is less than 1\&. "
.ti -1c
.RI "double \fBaverage\fP (long cc, double xf, double yf, double zf, long nn, double iscale)"
.br
.RI "Averages in 3D when scaling is less than 1\&. "
.ti -1c
.RI "double \fBinterpolate\fP (long cc, double xx, double yy=0, double zz=0, long nn=0, double \fBfill\fP=0) const"
.br
.RI "Interpolates using a given location\&. "
.ti -1c
.RI "double \fBinterpolate\fP (double xx, double yy=0, double zz=0, long nn=0, double \fBfill\fP=0) const"
.br
.ti -1c
.RI "double \fBinterpolate\fP (long cc, \fBVector3\fP< double > vec, long nn=0, double \fBfill\fP=0) const"
.br
.ti -1c
.RI "double \fBinterpolate\fP (\fBVector3\fP< double > vec, long nn=0, double \fBfill\fP=0) const"
.br
.ti -1c
.RI "double \fBinterpolate\fP (vector< double > vec, long nn=0, double \fBfill\fP=0) const"
.br
.ti -1c
.RI "double \fBinterpolate_wrap\fP (long cc, double xx, double yy=0, double zz=0, long nn=0) const"
.br
.RI "Interpolates using a given location with wrapping\&. "
.ti -1c
.RI "double \fBinterpolate_wrap\fP (double xx, double yy=0, double zz=0, long nn=0) const"
.br
.ti -1c
.RI "double \fBinterpolate_wrap\fP (long cc, \fBVector3\fP< double > vec, long nn=0) const"
.br
.ti -1c
.RI "double \fBinterpolate_wrap\fP (\fBVector3\fP< double > vec, long nn=0) const"
.br
.ti -1c
.RI "\fBDataType\fP \fBdata_type\fP ()"
.br
.ti -1c
.RI "void \fBdata_type\fP (\fBDataType\fP dt)"
.br
.ti -1c
.RI "\fBCompoundType\fP \fBcompound_type\fP ()"
.br
.ti -1c
.RI "long \fBcompound_type\fP (\fBCompoundType\fP ct)"
.br
.ti -1c
.RI "long \fBdata_type_bits\fP () const"
.br
.RI "Returns the size of the datatype in bits\&. "
.ti -1c
.RI "long \fBdata_type_size\fP () const"
.br
.RI "Returns the size of the datatype in bytes\&. "
.ti -1c
.RI "long \fBcompound_type_size\fP ()"
.br
.ti -1c
.RI "double \fBdata_type_min\fP ()"
.br
.RI "Get the minimum of a datatype\&. "
.ti -1c
.RI "double \fBdata_type_max\fP ()"
.br
.RI "Get the maximum of a datatype\&. "
.ti -1c
.RI "\fBBstring\fP \fBdata_type_string\fP ()"
.br
.RI "Get the string representation of a datatype\&. "
.ti -1c
.RI "\fBBstring\fP \fBcompound_type_string\fP ()"
.br
.RI "Get the string representation of a datatype\&. "
.ti -1c
.RI "void \fBfix_type\fP ()"
.br
.RI "Determines the replacement data type\&. "
.ti -1c
.RI "void \fBchange_type\fP (char letter)"
.br
.RI "Get the data type indicated by a single letter code\&. "
.ti -1c
.RI "void \fBchange_type\fP (char *string)"
.br
.RI "Get the data type from a string\&. "
.ti -1c
.RI "void \fBchange_type\fP (\fBDataType\fP nutype)"
.br
.RI "Change the data to the new type\&. "
.ti -1c
.RI "\fBBimage\fP * \fBsplit_channels\fP ()"
.br
.RI "Splits the channels into individual images\&. "
.ti -1c
.RI "void \fBcombine_channels\fP (long nc, \fBCompoundType\fP ct=\fBTSimple\fP)"
.br
.RI "Combines images as channels\&. "
.ti -1c
.RI "\fBFourierType\fP \fBfourier_type\fP ()"
.br
.ti -1c
.RI "void \fBfourier_type\fP (\fBFourierType\fP tf)"
.br
.ti -1c
.RI "void \fBzero_fourier_origin\fP ()"
.br
.RI "Zeroes the first voxel in each image\&. "
.ti -1c
.RI "long \fBchannels\fP ()"
.br
.ti -1c
.RI "void \fBchannels\fP (long cc)"
.br
.ti -1c
.RI "\fBVector3\fP< long > \fBsize\fP () const"
.br
.ti -1c
.RI "void \fBsize\fP (long nx, long ny, long nz)"
.br
.ti -1c
.RI "void \fBsize\fP (\fBVector3\fP< long > vec)"
.br
.ti -1c
.RI "void \fBsize\fP (vector< long > vec)"
.br
.ti -1c
.RI "void \fBsizeX\fP (long nx)"
.br
.ti -1c
.RI "void \fBsizeY\fP (long ny)"
.br
.ti -1c
.RI "void \fBsizeZ\fP (long nz)"
.br
.ti -1c
.RI "long \fBsizeX\fP () const"
.br
.ti -1c
.RI "long \fBsizeY\fP () const"
.br
.ti -1c
.RI "long \fBsizeZ\fP () const"
.br
.ti -1c
.RI "long \fBindex\fP (long nx, long ny) const"
.br
.ti -1c
.RI "long \fBindex\fP (long nx, long ny, long nz) const"
.br
.ti -1c
.RI "long \fBindex\fP (long nx, long ny, long nz, long nn) const"
.br
.ti -1c
.RI "long \fBindex\fP (long nc, long nx, long ny, long nz, long nn) const"
.br
.ti -1c
.RI "long \fBindex\fP (\fBVector3\fP< long > vox, long nn) const"
.br
.ti -1c
.RI "long \fBindex\fP (vector< long > vox, long nn) const"
.br
.ti -1c
.RI "long \fBindex_wrap\fP (long nx, long ny, long nz) const"
.br
.ti -1c
.RI "long \fBindex_wrap\fP (\fBVector3\fP< long > coor) const"
.br
.ti -1c
.RI "long \fBindex_wrap\fP (vector< long > coor) const"
.br
.ti -1c
.RI "void \fBcoordinates\fP (long i, long &nx, long &ny, long &nz)"
.br
.ti -1c
.RI "void \fBcoordinates\fP (long i, long &nx, long &ny, long &nz, long &nn)"
.br
.ti -1c
.RI "void \fBcoordinates\fP (long i, long &nc, long &nx, long &ny, long &nz, long &nn)"
.br
.ti -1c
.RI "\fBVector3\fP< long > \fBcoordinates\fP (long i)"
.br
.ti -1c
.RI "\fBVector3\fP< double > \fBreal_coordinates\fP (long i)"
.br
.ti -1c
.RI "template<typename T > bool \fBwithin_boundaries\fP (\fBVector3\fP< T > loc)"
.br
.ti -1c
.RI "bool \fBwithin_boundaries\fP (long xx, long yy, long zz)"
.br
.ti -1c
.RI "\fBVector3\fP< long > \fBkernel_low\fP (long i, long k=1)"
.br
.ti -1c
.RI "\fBVector3\fP< long > \fBkernel_high\fP (long i, long k=1)"
.br
.ti -1c
.RI "\fBVector3\fP< long > \fBkernel_low\fP (long i, \fBVector3\fP< long > k)"
.br
.ti -1c
.RI "\fBVector3\fP< long > \fBkernel_high\fP (long i, \fBVector3\fP< long > k)"
.br
.ti -1c
.RI "long \fBkernel_min\fP (long idx, long ksize)"
.br
.RI "Finds the highest value in a kernel\&. "
.ti -1c
.RI "long \fBkernel_max\fP (long idx, long ksize)"
.br
.RI "Finds the highest value in a kernel\&. "
.ti -1c
.RI "double \fBkernel_average\fP (long idx, long ksize, double tmin, double tmax)"
.br
.RI "Finds the highest value in a kernel\&. "
.ti -1c
.RI "long \fBkernel_max_neigbor\fP (long idx, long ksize)"
.br
.RI "Finds the highest value in a kernel excluding the central voxel\&. "
.ti -1c
.RI "long \fBkernel_max_wrap\fP (long idx, long ksize)"
.br
.RI "Finds the highest value in a kernel with wrapping\&. "
.ti -1c
.RI "multimap< double, long > \fBkernel_order\fP (long idx, long ksize)"
.br
.RI "Orders the values in a kernel\&. "
.ti -1c
.RI "multimap< double, long > \fBkernel_order_neighbors\fP (long idx, long ksize)"
.br
.RI "Orders the neigbor values in a kernel\&. "
.ti -1c
.RI "\fBVector3\fP< long > \fBpage_size\fP ()"
.br
.ti -1c
.RI "void \fBpage_size\fP (long nx, long ny, long nz)"
.br
.ti -1c
.RI "void \fBpage_size\fP (\fBVector3\fP< long > vec)"
.br
.ti -1c
.RI "void \fBpage_size\fP (vector< long > vec)"
.br
.ti -1c
.RI "\fBVector3\fP< double > \fBreal_size\fP ()"
.br
.ti -1c
.RI "long \fBimages\fP ()"
.br
.ti -1c
.RI "void \fBimages\fP (long nn)"
.br
.ti -1c
.RI "double \fBvoxel_size\fP ()"
.br
.ti -1c
.RI "void \fBsampling\fP (long nn, \fBVector3\fP< double > u)"
.br
.ti -1c
.RI "void \fBsampling\fP (long nn, double ux, double uy, double uz)"
.br
.ti -1c
.RI "void \fBsampling\fP (\fBVector3\fP< double > u)"
.br
.ti -1c
.RI "void \fBsampling\fP (double ux, double uy, double uz)"
.br
.ti -1c
.RI "\fBVector3\fP< double > \fBsampling\fP (long nn)"
.br
.ti -1c
.RI "vector< \fBVector3\fP< double > > \fBsampling\fP ()"
.br
.ti -1c
.RI "void \fBsampling\fP (vector< \fBVector3\fP< double >> sam)"
.br
.ti -1c
.RI "double \fBminimum\fP ()"
.br
.ti -1c
.RI "double \fBmaximum\fP ()"
.br
.ti -1c
.RI "double \fBaverage\fP ()"
.br
.ti -1c
.RI "double \fBstandard_deviation\fP ()"
.br
.ti -1c
.RI "double \fBvariance\fP ()"
.br
.ti -1c
.RI "void \fBminimum\fP (double d)"
.br
.ti -1c
.RI "void \fBmaximum\fP (double d)"
.br
.ti -1c
.RI "void \fBaverage\fP (double d)"
.br
.ti -1c
.RI "void \fBstandard_deviation\fP (double d)"
.br
.ti -1c
.RI "double \fBbackground\fP (long nn)"
.br
.ti -1c
.RI "void \fBbackground\fP (long nn, double bkg)"
.br
.ti -1c
.RI "void \fBbackground\fP (double bkg)"
.br
.ti -1c
.RI "long \fBshow_image\fP ()"
.br
.ti -1c
.RI "void \fBshow_image\fP (long nn)"
.br
.ti -1c
.RI "long \fBshow_slice\fP ()"
.br
.ti -1c
.RI "void \fBshow_slice\fP (long nz)"
.br
.ti -1c
.RI "double \fBshow_scale\fP ()"
.br
.ti -1c
.RI "void \fBshow_scale\fP (double scale)"
.br
.ti -1c
.RI "double \fBshow_minimum\fP ()"
.br
.ti -1c
.RI "double \fBshow_maximum\fP ()"
.br
.ti -1c
.RI "void \fBshow_minimum\fP (double v)"
.br
.ti -1c
.RI "void \fBshow_maximum\fP (double v)"
.br
.ti -1c
.RI "void \fBorigin\fP (double ox, double oy, double oz)"
.br
.ti -1c
.RI "void \fBorigin\fP (vector< double > vec)"
.br
.ti -1c
.RI "void \fBorigin\fP (\fBVector3\fP< double > vec)"
.br
.ti -1c
.RI "void \fBorigin\fP (long nn, \fBVector3\fP< double > vec)"
.br
.ti -1c
.RI "void \fBorigin\fP (long nn, vector< double > ori)"
.br
.ti -1c
.RI "void \fBorigin\fP (long nn, double ox, double oy, double oz)"
.br
.ti -1c
.RI "\fBVector3\fP< double > \fBdefault_origin\fP ()"
.br
.ti -1c
.RI "void \fBview\fP (double vx, double vy, double vz, double va)"
.br
.ti -1c
.RI "void \fBview\fP (\fBView\fP vw)"
.br
.ti -1c
.RI "long \fBspace_group\fP ()"
.br
.ti -1c
.RI "void \fBspace_group\fP (unsigned int grp)"
.br
.ti -1c
.RI "string & \fBsymmetry\fP ()"
.br
.ti -1c
.RI "void \fBsymmetry\fP (string grp)"
.br
.ti -1c
.RI "void \fBunit_cell\fP (\fBUnitCell\fP uc)"
.br
.ti -1c
.RI "\fBUnitCell\fP \fBunit_cell\fP ()"
.br
.ti -1c
.RI "double \fBmaximum_included_radius\fP ()"
.br
.RI "Returns the radius of the enclosed sphere or circle\&. "
.ti -1c
.RI "int \fBslices_to_images\fP ()"
.br
.RI "Changes the slices in a 3D image into a set of 2D images\&. "
.ti -1c
.RI "int \fBimages_to_slices\fP ()"
.br
.RI "Changes the 2D images to slices in a 3D image\&. "
.ti -1c
.RI "int \fBchannels_to_images\fP ()"
.br
.ti -1c
.RI "int \fBimages_to_channels\fP (long nc, \fBCompoundType\fP ct)"
.br
.ti -1c
.RI "long \fBset_subset_selection\fP (\fBBstring\fP list)"
.br
.RI "Sets the sub-image selections based on a list\&. "
.ti -1c
.RI "long \fBdelete_images\fP (\fBBstring\fP list, int retain=0)"
.br
.RI "Retains or deletes sub-images from a multi-image structure\&. "
.ti -1c
.RI "long \fBselect_images\fP (\fBBstring\fP list)"
.br
.ti -1c
.RI "unsigned char * \fBread_data\fP (ifstream *fimg, int img_select, int \fBsb\fP, int vax, long \fBpad\fP)"
.br
.RI "Read image data in a generalized style\&. "
.ti -1c
.RI "int \fBwrite\fP (\fBBstring\fP &fn)"
.br
.ti -1c
.RI "int \fBunpack_transform\fP (unsigned char *data, \fBFourierType\fP tf)"
.br
.ti -1c
.RI "int \fBunpack_transform\fP (int img_select, unsigned char *data, \fBFourierType\fP tf)"
.br
.ti -1c
.RI "int \fBpack_transform\fP (unsigned char *data, \fBFourierType\fP tf)"
.br
.ti -1c
.RI "int \fBpack_transform\fP (int img_select, unsigned char *data, \fBFourierType\fP tf)"
.br
.ti -1c
.RI "long \fBstatistics\fP ()"
.br
.RI "Calculates the statistics for an image\&. "
.ti -1c
.RI "long \fBstatistics\fP (long img_num)"
.br
.RI "Calculates the statistics for a sub-image\&. "
.ti -1c
.RI "long \fBstatistics\fP (\fBBimage\fP *pmask, double &regavg, double &regstd)"
.br
.RI "Calculates the statistics for a region in an image\&. "
.ti -1c
.RI "double \fBpoisson_statistics_check\fP ()"
.br
.RI "Checks whether the statistics conform to a Poisson distribution\&. "
.ti -1c
.RI "long \fBstats_within_radii\fP (long nn, \fBVector3\fP< double > loc, double rad_min, double rad_max, double &vavg, double &vstd)"
.br
.RI "Calculates the statistics for an image within given radii from a location\&. "
.ti -1c
.RI "long \fBstats_in_shape\fP (long nn, int type, \fBVector3\fP< long > start, \fBVector3\fP< long > end, double &vavg, double &vstd)"
.br
.RI "Calculates the statistics for an image within the given box\&. "
.ti -1c
.RI "long \fBstats_in_poly\fP (long nn, int nvert, \fBVector3\fP< double > *poly, double &vavg, double &vstd)"
.br
.RI "Calculates the statistics for an image within the given polyhedron\&. "
.ti -1c
.RI "long \fBstats_in_mask\fP (long nn, \fBBimage\fP *pmask)"
.br
.RI "Calculates the statistics for an image for each level in a mask\&. "
.ti -1c
.RI "int \fBvariance\fP (long kernel_size, int flag=0)"
.br
.RI "Calculates the local variance within the given kernel\&. "
.ti -1c
.RI "int \fBvariance\fP (\fBVector3\fP< long > kernel_size, int flag=0)"
.br
.RI "Calculates the local variance within the given kernel\&. "
.ti -1c
.RI "int \fBvariance\fP (\fBBimage\fP *pweight)"
.br
.RI "Calculates the local variance weighed with the given image\&. "
.ti -1c
.RI "int \fBinformation\fP ()"
.br
.RI "Prints out header information for an image\&. "
.ti -1c
.RI "int \fBsubimage_information\fP ()"
.br
.RI "Prints out header information for all sub-images\&. "
.ti -1c
.RI "int \fBmoments\fP (long max_order)"
.br
.RI "Prints out moments for all sub-images\&. "
.ti -1c
.RI "int \fBmoments\fP (long max_order, long nn)"
.br
.RI "Prints out moments for one sub-image\&. "
.ti -1c
.RI "void \fBget\fP (\fBBstring\fP tag)"
.br
.RI "Prints out header information associated with a tag string\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcopy\fP ()"
.br
.RI "Copies the header information and data of an image into a new image structure\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcopy\fP (long nu_nimg)"
.br
.RI "Copies the header information and data of an image into a new image structure\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcopy_header\fP ()"
.br
.ti -1c
.RI "\fBBimage\fP * \fBcopy_header\fP (long nu_nimg)"
.br
.RI "Copy an image structure into a new one\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract\fP (long nn)"
.br
.RI "Extracts one sub-image into new image structure\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract\fP (long n1, long n2)"
.br
.RI "Extracts a set of sub-images into new image structure\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract\fP (long nn, \fBVector3\fP< long > coords, \fBVector3\fP< long > \fBsize\fP, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Extracts a region of one sub-image into new image structure\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract\fP (long nn, \fBVector3\fP< double > loc, \fBVector3\fP< long > \fBsize\fP, \fBVector3\fP< double > \fBorigin\fP)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBextract\fP (long nn, \fBVector3\fP< double > loc, \fBVector3\fP< long > \fBsize\fP, \fBVector3\fP< double > \fBorigin\fP, \fBMatrix3\fP mat)"
.br
.RI "Extracts a region of one sub-image into new image structure\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract\fP (long nn, \fBVector3\fP< double > loc, \fBVector3\fP< long > \fBsize\fP, \fBVector3\fP< double > \fBorigin\fP, \fBView\fP \fBview\fP)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBextract_wrap\fP (long nn, \fBVector3\fP< double > loc, \fBVector3\fP< long > \fBsize\fP, \fBVector3\fP< double > \fBorigin\fP, \fBMatrix3\fP mat)"
.br
.RI "Extracts a region of one sub-image into new image structure with wrapping\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract_wrap\fP (long nn, \fBVector3\fP< long > \fBsize\fP, \fBMatrix3\fP mat)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBextract_shell\fP (long nn, double minrad, double maxrad)"
.br
.RI "Extracts a shell from an image into a new image\&. "
.ti -1c
.RI "vector< \fBVector3\fP< long > > \fBtile_coordinates\fP (\fBVector3\fP< long > &start, \fBVector3\fP< long > &region, \fBVector3\fP< long > &tile_size, \fBVector3\fP< long > &step_size, int exceed)"
.br
.RI "Generates a set of tile coordinates for an image\&. "
.ti -1c
.RI "vector< \fBVector3\fP< long > > \fBtile_coordinates\fP (\fBVector3\fP< long > tile_size, \fBVector3\fP< long > &step_size)"
.br
.RI "Generates a set of tile coordinates to fit in the image dimensions\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract_tiles\fP (long nn, vector< \fBVector3\fP< long >> &coords, \fBVector3\fP< long > tile_size)"
.br
.RI "Extracts a set of tiles at specified positions from an image into a new image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract_tiles\fP (long nn, \fBVector3\fP< long > start, \fBVector3\fP< long > region, \fBVector3\fP< long > tile_size, \fBVector3\fP< long > step_size, int exceed)"
.br
.RI "Extracts a set of tiles from an image into a new image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract_tiles\fP (long nn, \fBVector3\fP< long > tile_size, double fraction=0\&.2)"
.br
.RI "Extracts a set of tiles from an image into a new image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract_tile_stack\fP (\fBVector3\fP< long > coords, \fBVector3\fP< long > tile_size, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Extracts a stack of tiles at a specified position from an image into a new image\&. "
.ti -1c
.RI "\fBBimage\fP ** \fBextract_tile_stacks\fP (vector< \fBVector3\fP< long >> &coords, \fBVector3\fP< long > tile_size)"
.br
.RI "Extracts stacks of tiles at a specified positions from an image into an array of new images\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract_line\fP (long nn, \fBVector3\fP< double > start, \fBVector3\fP< double > end, long width)"
.br
.RI "Extracts a line from an image into a new image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract_tetrahedron\fP (\fBVector3\fP< double > *tet, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Extracts a tetrahedral part of the image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBorthogonal_slices\fP (long nn, \fBVector3\fP< long > voxel, \fBVector3\fP< long > ext_size)"
.br
.RI "Extracts orthogonal views around a voxel\&. "
.ti -1c
.RI "int \fBextract_show_chunk\fP (\fBBimage\fP *pshow, int aflag, long i, long len)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBextract_show\fP (int aflag)"
.br
.RI "Converts a slice from an image to a 2D plane for display\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract_magnify\fP (long nn, \fBVector3\fP< long > \fBcenter\fP, \fBVector3\fP< long > ext_size, double scale)"
.br
.RI "Extracts a region from an image to magnify\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract_slice\fP (long nz)"
.br
.RI "Extracts a given slice or slices from an image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBextract_filament\fP (long img_num, double width, int axis, long nspline, \fBVector3\fP< double > *spline)"
.br
.RI "Extracts a filament defined by a series of coordinates\&. "
.ti -1c
.RI "int \fBreplace\fP (\fBBimage\fP *img)"
.br
.RI "Replaces the data with that from the given image\&. "
.ti -1c
.RI "int \fBreplace\fP (long nn, \fBBimage\fP *img, long nr=0)"
.br
.RI "Replaces one sub-image in an image structure\&. "
.ti -1c
.RI "int \fBreplace\fP (long nn, \fBBimage\fP *img, long nr, double \fBfill\fP)"
.br
.RI "Replaces one sub-image in an image structure\&. "
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "void \fBfill\fP (double v)"
.br
.ti -1c
.RI "double \fBdensity\fP (long nn, \fBVector3\fP< double > coord, double radius, double &sigma)"
.br
.RI "Calculates the density in a sphere around a coordinate in an image\&. "
.ti -1c
.RI "double \fBdensity\fP (long nn, \fBVector3\fP< double > coord, double radius)"
.br
.ti -1c
.RI "double \fBrelative_density\fP (\fBBimage\fP *pmask)"
.br
.RI "Calculates the relative density in a region defined by a mask\&. "
.ti -1c
.RI "void \fBinvert\fP ()"
.br
.RI "Inverts the data in the image\&. "
.ti -1c
.RI "void \fBreslice\fP (const char *order)"
.br
.ti -1c
.RI "void \fBreslice\fP (\fBBstring\fP order)"
.br
.RI "Switches axes of an image\&. "
.ti -1c
.RI "void \fBadd\fP (double v)"
.br
.RI "Adds a constant value to an image\&. "
.ti -1c
.RI "void \fBmultiply\fP (double v)"
.br
.RI "Multiplies an image with a constant value\&. "
.ti -1c
.RI "void \fBmultiply\fP (long nn, double v)"
.br
.RI "Multiplies a sub-image with a constant value\&. "
.ti -1c
.RI "void \fBpower\fP (double v)"
.br
.RI "Calculates the power of an image\&. "
.ti -1c
.RI "void \fBsum_images\fP ()"
.br
.RI "Adds all sub-images\&. "
.ti -1c
.RI "void \fBaverage_images\fP ()"
.br
.ti -1c
.RI "\fBBimage\fP * \fBaverage_images\fP (bool sd)"
.br
.RI "Averages all sub-images and optionally calculates standard deviation image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBmoving_sum\fP (long window, long step=1, int flag=0)"
.br
.RI "Calculates a moving sum of the sub-images\&. "
.ti -1c
.RI "void \fBprogressive_sum\fP ()"
.br
.RI "Progressive sum of the sub-images\&. "
.ti -1c
.RI "void \fBadd\fP (\fBBimage\fP *p)"
.br
.RI "Adds another image to an image\&. "
.ti -1c
.RI "void \fBadd\fP (long nn, \fBBimage\fP *p)"
.br
.RI "Adds another image to a sub-image\&. "
.ti -1c
.RI "void \fBsubtract\fP (\fBBimage\fP *p)"
.br
.RI "Subtracts another image from an image\&. "
.ti -1c
.RI "void \fBadd\fP (\fBBimage\fP *p, double scale, double \fBshift\fP)"
.br
.RI "Adds another image to an image\&. "
.ti -1c
.RI "void \fBadd\fP (long nn, \fBBimage\fP *p, double scale, double \fBshift\fP)"
.br
.RI "Adds another image to an image\&. "
.ti -1c
.RI "void \fBmultiply\fP (\fBBimage\fP *p, double scale, double \fBshift\fP=0)"
.br
.RI "Multiplies an image with another image\&. "
.ti -1c
.RI "void \fBmultiply\fP (long nn, \fBBimage\fP *p)"
.br
.RI "Multiplies a sub-image with another image\&. "
.ti -1c
.RI "void \fBmultiply\fP (\fBBimage\fP *p)"
.br
.RI "Multiplies all sub-images with the first sub-image of the other image\&. "
.ti -1c
.RI "void \fBdivide\fP (\fBBimage\fP *p, double scale=1, double \fBshift\fP=0)"
.br
.RI "Divides the first image by the second\&. "
.ti -1c
.RI "void \fBdivide_one\fP (\fBBimage\fP *p, double scale=1, double \fBshift\fP=0)"
.br
.RI "Divides the first image by the first sub-image of the second\&. "
.ti -1c
.RI "void \fBinverse\fP (double minval=0)"
.br
.RI "Calculates the inverse of the image\&. "
.ti -1c
.RI "void \fBlargest\fP (\fBBimage\fP *p)"
.br
.RI "Selects the largest of each pixel from two images\&. "
.ti -1c
.RI "void \fBsmallest\fP (\fBBimage\fP *p)"
.br
.RI "Selects the smallest of each pixel from two images\&. "
.ti -1c
.RI "\fBBimage\fP * \fBoperator+\fP (\fBBimage\fP &p)"
.br
.RI "Adds two images together, adjusting for size difference\&. "
.ti -1c
.RI "\fBBplot\fP * \fBplot\fP ()"
.br
.RI "Converts a one-dimensional image into a plot\&. "
.ti -1c
.RI "void \fBvector_to_simple\fP ()"
.br
.RI "A vector image is converted to a simple image\&. "
.ti -1c
.RI "void \fBsum\fP (long m, \fBBimage\fP **p)"
.br
.RI "Sums an array of images with their FOM blocks\&. "
.ti -1c
.RI "void \fBcatenate\fP (long m, \fBBimage\fP **p)"
.br
.RI "Catenates an array of images of the same size into a multi-image structure\&. "
.ti -1c
.RI "\fBBimage\fP * \fBblend\fP (\fBBimage\fP *p, long number)"
.br
.RI "Blends the two images, creating a new set of sub-images\&. "
.ti -1c
.RI "int \fBplace\fP (long nn, \fBBimage\fP *p, \fBVector3\fP< double > loc, double radius=0, double scale=1, double \fBshift\fP=0, int operation=0)"
.br
.RI "Places a small image into a large image\&. "
.ti -1c
.RI "int \fBplace_with_addition\fP (\fBBimage\fP *p, long nn)"
.br
.RI "Packs a tile into a new composite image with addition within overlap\&. "
.ti -1c
.RI "int \fBplace_with_overlap\fP (\fBBimage\fP *p, long nn)"
.br
.RI "Packs a tile into a new composite image with weighted overlap\&. "
.ti -1c
.RI "int \fBplace_central_part\fP (\fBBimage\fP *p, long nn)"
.br
.RI "Packs a tile into a new composite image, retaining only the central part\&. "
.ti -1c
.RI "int \fBassemble_tiles\fP (\fBBimage\fP *pt, int flag=0)"
.br
.RI "Assembles overlapping tiles into this image\&. "
.ti -1c
.RI "double \fBlinear_fit\fP (\fBBimage\fP *p, \fBBimage\fP *pmask, double max_exclude)"
.br
.RI "Linear least squares fit of two images\&. "
.ti -1c
.RI "int \fBhistomatch\fP (\fBBimage\fP *p, long bins)"
.br
.RI "Fits two images by matching the histogram of the second to the first\&. "
.ti -1c
.RI "int \fBkernel_gaussian\fP (double sigma, double max)"
.br
.RI "Generates a gaussian kernel image\&. "
.ti -1c
.RI "int \fBkernel_laplacian_of_gaussian\fP (double sigma, double max)"
.br
.RI "Generates a laplacian-of-gaussian kernel\&. "
.ti -1c
.RI "int \fBfilter_average\fP (long kernel_size)"
.br
.RI "Applies an averaging filter to an image\&. "
.ti -1c
.RI "int \fBfilter_average\fP (\fBVector3\fP< long > k)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBgradient\fP ()"
.br
.RI "Calculates the central difference gradient image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBgradient3x3\fP ()"
.br
.RI "Calculates the difference gradient image in a 3x3 kernel\&. "
.ti -1c
.RI "int \fBfilter_gaussian\fP (long kernel_size, double sigma=0)"
.br
.RI "Applies a gaussian filter to an image\&. "
.ti -1c
.RI "int \fBfilter_sinc\fP ()"
.br
.RI "Weighs an image with a sinc function\&. "
.ti -1c
.RI "int \fBconvolve_chunk\fP (\fBBimage\fP *pkernel, float *nudata, long i, long len)"
.br
.ti -1c
.RI "int \fBconvolve\fP (\fBBimage\fP *pkernel)"
.br
.RI "Convolves an image with an arbitrary size convolution filter\&. "
.ti -1c
.RI "int \fBfilter_ortho\fP (int type)"
.br
.RI "Convolves the image with an orthogonal kernel with wrapping\&. "
.ti -1c
.RI "int \fBfilter_dog\fP (double sigma1, double sigma2)"
.br
.RI "Convolves the image with a difference of gausians kernel\&. "
.ti -1c
.RI "int \fBfilter_bilateral_chunk\fP (\fBBimage\fP *pkernel, double sigma2, int kernel_type, float *nudata, long i, long len, int first)"
.br
.ti -1c
.RI "int \fBfilter_bilateral\fP (double sigma1, double sigma2, int kernel_type, long kernel_radius)"
.br
.RI "Denoise an image with combined gaussian distance and density difference kernel\&. "
.ti -1c
.RI "int \fBfilter_rolling_ball\fP (long radius, double scale)"
.br
.RI "Apply a rolling ball filter\&. "
.ti -1c
.RI "int \fBfilter_rank_chunk\fP (long kernel_size, double rank, float *nudata, long i, long len)"
.br
.ti -1c
.RI "int \fBfilter_rank\fP (long kernel_size, double rank)"
.br
.RI "Applies a median filter to an image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBfilter_peak\fP (long kernel_size)"
.br
.RI "Finds the peaks in an image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBperiodic_averaging\fP (\fBVector3\fP< double > period)"
.br
.RI "Calculates an average within a periodic frame\&. "
.ti -1c
.RI "\fBBimage\fP * \fBaniso_average\fP (long ksize, double w)"
.br
.RI "Calculates an anisotropic average within a kernel based on the local gradient\&. "
.ti -1c
.RI "int \fBfilter_by_difference\fP (\fBBimage\fP *p)"
.br
.RI "Calculates an anisotropic average within a kernel based on the local gradient\&. "
.ti -1c
.RI "\fBBimage\fP * \fBnad_2D\fP (double ht, double lambda, double C, double alpha)"
.br
.RI "Denoises a 2D image by non-linear anisotropic diffusion\&. "
.ti -1c
.RI "\fBBimage\fP * \fBnad\fP (double ht, long zw, double lambda, double C, double alpha)"
.br
.RI "Denoises a 3D density map by non-linear anisotropic diffusion\&. "
.ti -1c
.RI "void \fBsimple_to_complex\fP ()"
.br
.RI "A simple image is converted to a complex image\&. "
.ti -1c
.RI "void \fBmulti_channel_to_complex\fP ()"
.br
.RI "A multi-channel image is converted to a set of complex images\&. "
.ti -1c
.RI "void \fBcomplex_to_real\fP ()"
.br
.RI "The real part of a complex image is written to a simple image\&. "
.ti -1c
.RI "void \fBcomplex_to_imaginary\fP ()"
.br
.RI "The imaginary part of a complex image is written to a simple image\&. "
.ti -1c
.RI "void \fBcomplex_to_intensities\fP ()"
.br
.RI "The intensities from a complex image is written to a simple image\&. "
.ti -1c
.RI "void \fBcomplex_to_amplitudes\fP ()"
.br
.RI "The amplitudes from a complex image is written to a simple image\&. "
.ti -1c
.RI "void \fBcomplex_to_signed_amplitudes\fP ()"
.br
.RI "The signed amplitudes from a complex image is written to a simple image\&. "
.ti -1c
.RI "void \fBcomplex_to_phases\fP ()"
.br
.RI "The phases from a complex image is written to a simple image\&. "
.ti -1c
.RI "void \fBcomplex_conjugate\fP ()"
.br
.RI "Calculates the complex conjugate image\&. "
.ti -1c
.RI "double \fBcomplex_power\fP ()"
.br
.RI "Calculates the power in a complex image\&. "
.ti -1c
.RI "double \fBcomplex_normalize\fP ()"
.br
.RI "Normalizes the power in a complex image\&. "
.ti -1c
.RI "int \fBphase_shift\fP (\fBVector3\fP< double > \fBshift\fP)"
.br
.RI "Phase shifts a complex image\&. "
.ti -1c
.RI "int \fBphase_shift\fP (long nn, \fBVector3\fP< double > \fBshift\fP)"
.br
.RI "Phase shifts a complex sub-image\&. "
.ti -1c
.RI "int \fBphase_shift_to_origin\fP ()"
.br
.RI "Phase shifts a set of reflections to the image origin\&. "
.ti -1c
.RI "int \fBphase_shift_to_center\fP ()"
.br
.RI "Phase shifts a set of reflections to the nominal center of the image origin\&. "
.ti -1c
.RI "int \fBcomplex_multiply\fP (\fBBimage\fP *p)"
.br
.RI "Calculates the product of a complex image with a simple image\&. "
.ti -1c
.RI "int \fBcomplex_product\fP (\fBBimage\fP *p)"
.br
.RI "Calculates the complex product of two complex images\&. "
.ti -1c
.RI "int \fBcomplex_conjugate_product\fP (\fBBimage\fP *p)"
.br
.RI "Calculates the product of a complex image with the conjugate of a second\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcomplex_conjugate_product_one2many\fP (\fBBimage\fP *p)"
.br
.RI "Calculates the product of a complex image with the conjugate of a second\&. "
.ti -1c
.RI "int \fBcomplex_apply_mask\fP (\fBBimage\fP *pmask)"
.br
.RI "Applies a mask to a complex image\&. "
.ti -1c
.RI "int \fBcomplex_apply_negative_mask\fP (\fBBimage\fP *pmask)"
.br
.RI "Applies a negative mask to a complex image\&. "
.ti -1c
.RI "int \fBcomplex_apply_dual_mask\fP (\fBBimage\fP *pmask)"
.br
.RI "Applies a dual mask to a complex image\&. "
.ti -1c
.RI "int \fBcomplex_bandpass\fP (double hires, double lores)"
.br
.RI "Bandpasses a Fourier transform\&. "
.ti -1c
.RI "\fBBimage\fP * \fBpack_two_in_complex\fP (\fBBimage\fP *p)"
.br
.RI "Packs two real images into one complex image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBunpack_combined_transform\fP ()"
.br
.RI "Unpacks a complex transform obtained from two real images\&. "
.ti -1c
.RI "int \fBcombined_complex_product\fP ()"
.br
.RI "Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images\&. "
.ti -1c
.RI "int \fBcombined_complex_product\fP (\fBBimage\fP *pmask)"
.br
.RI "Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images\&. "
.ti -1c
.RI "int \fBcombined_complex_product\fP (double hires, double lores)"
.br
.RI "Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images\&. "
.ti -1c
.RI "int \fBcombined_complex_product\fP (double hires, double lores, \fBBimage\fP *pmask)"
.br
.RI "Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images\&. "
.ti -1c
.RI "int \fBcombined_complex_product_implicit_mask\fP (double hires, double lores)"
.br
.RI "Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images\&. "
.ti -1c
.RI "double \fBmerge_amplitudes_and_phases\fP (\fBBimage\fP *pamp)"
.br
.RI "Merges the amplitudes from one map with the phases of another\&. "
.ti -1c
.RI "double \fBmerge_amplitudes_and_phases\fP (\fBBimage\fP *pref, double res_hi, double res_lo)"
.br
.RI "Keeps selected phases and replaces amplitudes and other phases from a reference transform\&. "
.ti -1c
.RI "\fBBimage\fP * \fBintensities_phase_colored\fP (double scale)"
.br
.RI "Generates a power spectrum with phases colored according to a color wheel\&. "
.ti -1c
.RI "int \fBphase_colour_wheel\fP ()"
.br
.RI "Generates a phase color wheel\&. "
.ti -1c
.RI "\fBfft_plan\fP \fBfft_setup\fP (\fBfft_direction\fP dir, int opt=0)"
.br
.RI "Sets up a plan for fast Fourier transforms\&. "
.ti -1c
.RI "int \fBfft\fP ()"
.br
.ti -1c
.RI "int \fBfft_back\fP ()"
.br
.ti -1c
.RI "int \fBfft\fP (\fBfft_direction\fP dir)"
.br
.RI "Fast Fourier transforms an image\&. "
.ti -1c
.RI "int \fBfft_back\fP (\fBfft_plan\fP plan, bool norm_flag=1)"
.br
.ti -1c
.RI "int \fBfft\fP (\fBfft_direction\fP dir, bool norm_flag)"
.br
.RI "Fast Fourier transforms an image\&. "
.ti -1c
.RI "int \fBfft\fP (\fBfft_plan\fP plan, bool norm_flag=1)"
.br
.RI "Fast Fourier transforms an image\&. "
.ti -1c
.RI "\fBVector3\fP< double > \fBchange_transform_size\fP (\fBVector3\fP< long > nusize)"
.br
.RI "Resizes a 'standard' transform\&. "
.ti -1c
.RI "int \fBpower_spectrum\fP (int flags=0)"
.br
.RI "Calculates a power spectrum\&. "
.ti -1c
.RI "\fBBimage\fP * \fBpowerspectrum_tiled\fP (long img_num, \fBVector3\fP< long > tile_size, int flags=0)"
.br
.RI "Prepares a tiled power spectrum from an image for determining CTF parameters\&. "
.ti -1c
.RI "\fBBimage\fP * \fBpowerspectrum_tilt_axis\fP (long img_num, \fBVector3\fP< long > tile_size, double tilt_axis, double tilt_offset, int flags=0)"
.br
.RI "Prepares a tiled powerspectrum from a tilted image for determining CTF parameters\&. "
.ti -1c
.RI "\fBBimage\fP * \fBdefocus_scale\fP (long nn, double df, double df2, double iCL2, int fill_type)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBpowerspectrum_tilted\fP (long img_num, \fBVector3\fP< long > tile_size, double tilt_axis, double tilt_angle, double defocus, double iCL2, int flags=0)"
.br
.RI "Prepares a tiled powerspectrum from a tilted image for determining CTF parameters\&. "
.ti -1c
.RI "\fBBimage\fP * \fBpowerspectrum_tiled_and_tilted\fP (\fBVector3\fP< long > tile_size, double tilt_axis, double tilt_angle, double tilt_offset, double defocus, double iCL2, int flags=0)"
.br
.RI "Prepares a tiled powerspectrum from a tilted image for determining CTF parameters\&. "
.ti -1c
.RI "vector< double > \fBpowerspectrum_isotropy\fP (long n, double &lores, double &hires)"
.br
.RI "Calculates a measure of anisotropy in a poer spectrum\&. "
.ti -1c
.RI "long \fBfspace_maximum_radius\fP (double resolution, double sampling_ratio=1)"
.br
.RI "Calculates the maximum radius in frequency space from a given resolution\&. "
.ti -1c
.RI "int \fBfspace_background\fP ()"
.br
.RI "Calculates the background for a Fourier transform\&. "
.ti -1c
.RI "\fBComplex\fP< double > \fBfspace_interpolate\fP (long img_num, \fBVector3\fP< double > m, \fBFSI_Kernel\fP *\fBkernel\fP)"
.br
.RI "Calculates the complex value at an image location by kernel-based interpolation\&. "
.ti -1c
.RI "int \fBfspace_2D_interpolate\fP (\fBComplex\fP< float > cv, \fBVector3\fP< double > m, double part_weight, int interp_type)"
.br
.RI "Interpolates a 2D image for packing ito a 3D reciprocal space volume\&. 
.br
 "
.ti -1c
.RI "int \fBfspace_pack_2D\fP (\fBBimage\fP *p, \fBMatrix3\fP mat, double hi_res, double lo_res, \fBVector3\fP< double > scale, double part_weight=1, int interp_type=0)"
.br
.RI "Packs a 2D Fourier transform into a 3D reciprocal space volume\&. 
.br
 "
.ti -1c
.RI "int \fBfspace_pack_2D\fP (\fBBimage\fP *p, \fBView\fP asu_view, \fBBsymmetry\fP &sym, double hi_res, double lo_res, \fBVector3\fP< double > scale, double part_weight=1, int interp_type=0)"
.br
.RI "Packs a 2D Fourier transform into a 3D reciprocal space volume\&. 
.br
 "
.ti -1c
.RI "long \fBfspace_pack_2D_into_central_section\fP (\fBBimage\fP *p, long ft_size, double scale, double hi_res, double lo_res, \fBMatrix3\fP matr, \fBMatrix3\fP mat)"
.br
.RI "Packs a 2D Fourier transform into a central section of a 3D reciprocal space volume\&. 
.br
 "
.ti -1c
.RI "int \fBfspace_pack_3D\fP (\fBBimage\fP *p, double hi_res=0, double threshold=0)"
.br
.RI "Packs a 3D Fourier transform into a 3D reciprocal space volume\&. "
.ti -1c
.RI "long \fBfspace_reconstruction_add\fP (\fBBimage\fP *p)"
.br
.RI "Adds all components to a reconstruction\&. "
.ti -1c
.RI "long \fBfspace_reconstruction_weigh\fP ()"
.br
.RI "Weighs a reconstruction\&. "
.ti -1c
.RI "int \fBfspace_reconstruction_stats\fP (double resolution, double sampling_ratio=1)"
.br
.RI "Calculates Fourier shell statistics\&. "
.ti -1c
.RI "long \fBfspace_reconstruction_snr\fP ()"
.br
.RI "Calculates the SNR map\&. "
.ti -1c
.RI "int \fBfspace_translate\fP (\fBVector3\fP< double > \fBshift\fP)"
.br
.RI "Translates an image in frequency space to avoid interpolation\&. "
.ti -1c
.RI "int \fBfspace_translate\fP (long nn, \fBVector3\fP< double > \fBshift\fP)"
.br
.RI "Translates an image in frequency space to avoid interpolation\&. "
.ti -1c
.RI "int \fBfspace_resize\fP (double scale, double res_hi, double res_lo)"
.br
.RI "Resizes an image in frequency space to avoid interpolation\&. "
.ti -1c
.RI "\fBBimage\fP * \fBfspace_resize\fP (\fBBimage\fP *pref)"
.br
.RI "Resizes an image in frequency space to avoid interpolation\&. "
.ti -1c
.RI "int \fBfspace_amp_one\fP ()"
.br
.RI "Sets all amplitudes to one\&. "
.ti -1c
.RI "int \fBfspace_amp_threshold\fP (double threshold)"
.br
.RI "Filters the amplitudes of the Fourier transform of an image\&. "
.ti -1c
.RI "int \fBfspace_sqrt_amp\fP ()"
.br
.RI "Change the amlitudes to their square roots\&. "
.ti -1c
.RI "int \fBfspace_square_amp\fP ()"
.br
.RI "Change the amlitudes to their squares\&. "
.ti -1c
.RI "int \fBfspace_bandpass\fP (double res_hi, double res_lo=0, double width=0)"
.br
.RI "Applies a bandpass filter to an image\&. "
.ti -1c
.RI "int \fBfspace_bandpass\fP (double res_hi, double res_lo, double width, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.RI "Applies a bandpass filter to an image\&. "
.ti -1c
.RI "int \fBfspace_frequency_filter\fP (double freq, double sigma)"
.br
.RI "Applies a frequency filter to an image\&. "
.ti -1c
.RI "int \fBfspace_frequency_filter\fP (double freq, double sigma, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.RI "Applies a frequency filter to an image\&. "
.ti -1c
.RI "int \fBfspace_gabor_filter\fP (\fBVector3\fP< double > freq, double fsigma, double psigma)"
.br
.RI "Applies a Gabor filter to an image\&. "
.ti -1c
.RI "int \fBfspace_gabor_filter\fP (\fBVector3\fP< double > freq, double fsigma, double psigma, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.RI "Applies a Gabor filter to an image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBfspace_radial_power\fP (double resolution, double sampling_ratio=1)"
.br
.RI "Calculates the radial power spectrum from a Fourier transform\&. "
.ti -1c
.RI "vector< double > \fBfspace_radial\fP (long nn, long maxrad, int flag=0)"
.br
.RI "Calculates the radial power spectrum from a Fourier transform\&. "
.ti -1c
.RI "int \fBfspace_weigh\fP (vector< double > &curve, int flag=0)"
.br
.ti -1c
.RI "int \fBfspace_scale\fP (vector< double > &scale, \fBBimage\fP *pmask=NULL)"
.br
.ti -1c
.RI "int \fBfspace_scale\fP (long nn, vector< double > &scale, \fBBimage\fP *pmask=NULL)"
.br
.ti -1c
.RI "double \fBfspace_fit_B_factor\fP (double res_hi=0)"
.br
.RI "Determines the overall B-factor of an image\&. "
.ti -1c
.RI "int \fBfspace_weigh_ramp\fP (double resolution, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.RI "Weighs a transform with a ramp\&. "
.ti -1c
.RI "int \fBfspace_weigh_ramp\fP (double resolution, double axis, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.RI "Weighs a transform with a ramp\&. "
.ti -1c
.RI "int \fBfspace_weigh_B_factor\fP (double B, double resolution=0)"
.br
.RI "Weighs an image's amplitudes with B-factor (gaussian) curve\&. "
.ti -1c
.RI "int \fBfspace_weigh_C_curve\fP (double resolution=0)"
.br
.RI "Weighs an image's amplitudes with the carbon scattering curve\&. "
.ti -1c
.RI "int \fBfspace_weigh_LoG\fP (double resolution, double sigma)"
.br
.RI "Weighs an image's amplitudes with a Laplacian-of-Gaussian function\&. "
.ti -1c
.RI "int \fBfspace_weigh_RPS_curve\fP (\fBBplot\fP *\fBplot\fP, double resolution=0)"
.br
.RI "Weighs an image's amplitudes with a given RPS curve\&. "
.ti -1c
.RI "int \fBfspace_weigh_FSC_curve\fP (\fBBplot\fP *\fBplot\fP, double resolution=0)"
.br
.RI "Weighs an image's amplitudes with a given FSC curve\&. "
.ti -1c
.RI "int \fBfspace_weigh_gaussian\fP (long nn, \fBVector3\fP< double > sigma, int dir=0)"
.br
.RI "Weighs an image's amplitudes with an anisotropic Gaussian function\&. "
.ti -1c
.RI "\fBBimage\fP * \fBfspace_gradient\fP (\fBVector3\fP< double > sigma)"
.br
.RI "Generates a image with orthogonal gradients encded in 3-value vectors\&. "
.ti -1c
.RI "int \fBfspace_weigh\fP (\fBBimage\fP *pref, \fBBimage\fP *pmask, double resolution=0)"
.br
.RI "Weighs an image's amplitudes with the radial power spectrum of another\&. "
.ti -1c
.RI "int \fBfspace_weigh_dose\fP (long nn, double dose_per_frame, vector< double > critdose)"
.br
.ti -1c
.RI "int \fBfspace_weigh_dose\fP (double dose_per_frame, int flag=0)"
.br
.RI "Weighs an image's amplitudes with the accumulated dose\&. "
.ti -1c
.RI "int \fBfspace_weigh_accumulated_dose\fP (vector< double > dose)"
.br
.RI "Weighs an image's amplitudes with the accumulated dose\&. "
.ti -1c
.RI "int \fBfspace_normalize\fP ()"
.br
.RI "Normalizes an image's amplitudes\&. "
.ti -1c
.RI "int \fBfspace_normalize_radial\fP (\fBBimage\fP *pmask, double resolution=0, int flag=0)"
.br
.RI "Normalizes an image's amplitudes\&. "
.ti -1c
.RI "int \fBfspace_positive\fP ()"
.br
.RI "Sets the image to positive definite\&. "
.ti -1c
.RI "double \fBfriedel_check\fP ()"
.br
.RI "Checks Friedel symmetry\&. "
.ti -1c
.RI "int \fBfriedel_apply\fP ()"
.br
.RI "Applies Friedel symmetry\&. "
.ti -1c
.RI "\fBBimage\fP * \fBproject\fP (char axis, int flags=1)"
.br
.RI "Projects a 3D image to a 2D image down one of the three major axes\&. "
.ti -1c
.RI "\fBBimage\fP * \fBrotate_project\fP (\fBMatrix3\fP mat, \fBVector3\fP< double > translate, double radial_cutoff, int norm_flag=1)"
.br
.RI "Rotates a 3D map and projects it along the z-axis\&. "
.ti -1c
.RI "\fBBimage\fP * \fBproject\fP (\fBView\fP *\fBview\fP, int norm_flag=1)"
.br
.RI "Calculates a set of projections from a 3D density map\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcentral_section\fP (\fBMatrix3\fP mat, double resolution, \fBFSI_Kernel\fP *\fBkernel\fP)"
.br
.RI "Calculates a central section of a 3D fourier transform\&. "
.ti -1c
.RI "\fBBimage\fP * \fBproject\fP (\fBView\fP *\fBview\fP, double resolution, \fBFSI_Kernel\fP *\fBkernel\fP)"
.br
.RI "Calculates a set of projections as central sections from a 3D fourier transform\&. "
.ti -1c
.RI "int \fBback_project\fP (\fBBimage\fP *p, double resolution, double axis, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBresolution_prepare\fP (\fBBimage\fP *p)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBresolution_prepare\fP (\fBBimage\fP *p, \fBfft_plan\fP plan)"
.br
.ti -1c
.RI "\fBBplot\fP * \fBfsc_dpr\fP (double hi_res, double sampling_ratio=1, int flag=0)"
.br
.RI "Calculates an FSC and DPR curves from two images\&. "
.ti -1c
.RI "\fBBplot\fP * \fBfsc\fP (double hi_res, double sampling_ratio=1)"
.br
.ti -1c
.RI "\fBBplot\fP * \fBfsc\fP (\fBBimage\fP *p, double hi_res, double sampling_ratio=1)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBfsc_shell\fP (\fBBimage\fP *p, double hi_res, double *cutoff, int \fBthickness\fP, int step, int minrad, int maxrad, int \fBpad\fP=1, int smooth=0, double \fBfill\fP=0)"
.br
.RI "Determine the resolution for each concentric shell in a map\&. "
.ti -1c
.RI "\fBBimage\fP * \fBfsc_local\fP (\fBBimage\fP *p, \fBBimage\fP *pmask, double resolution, double *cutoff, int mask_level, int \fBsize\fP, int \fBpad\fP, \fBVector3\fP< long > vedge, int step=1, int taper=1, double \fBfill\fP=0)"
.br
.RI "Determine the local resolution at each masked voxel in a map\&. "
.ti -1c
.RI "\fBBimage\fP * \fBlocal_filter\fP (\fBBimage\fP *pmask, int mask_level, \fBBimage\fP *resmap, int \fBsize\fP, \fBVector3\fP< long > vedge)"
.br
.RI "Applies a local resolution filter to a map\&. "
.ti -1c
.RI "\fBBimage\fP * \fBphase_difference\fP (\fBBimage\fP *p, int type=0, double res_hi=0, double res_lo=0)"
.br
.RI "Calculates the cosine of the phase difference between two images\&. "
.ti -1c
.RI "double \fBaverage_phase_difference\fP (\fBBimage\fP *p, double res_hi, double res_lo, int weighting=1)"
.br
.RI "Calculates the average of the absolute phase difference between two images within given resolution shells\&. "
.ti -1c
.RI "int \fBphase_flip\fP (\fBBimage\fP *pd)"
.br
.RI "Flips the phases of an image based on a phase difference map\&. "
.ti -1c
.RI "double \fBcorrelate\fP (\fBBimage\fP *p)"
.br
.RI "Calculates correlation coefficient between two images\&. "
.ti -1c
.RI "double \fBcorrelate\fP (\fBBimage\fP *p, double rmin, double rmax, \fBBimage\fP *pmask=NULL, int flag=0)"
.br
.RI "Calculates a correlation coefficient between two images\&. "
.ti -1c
.RI "double \fBrotate_correlate\fP (\fBVector3\fP< double > axis, double \fBangle\fP)"
.br
.RI "Rotates a copy of an image and correlates it with the original\&. "
.ti -1c
.RI "double \fBR_factor\fP (\fBBimage\fP *p)"
.br
.RI "Calculates an R factor between two images\&. "
.ti -1c
.RI "int \fBauto_correlate\fP (double hires, double lores)"
.br
.RI "Calculates an autocorrelation map by Fast Fourier transformation\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcross_correlate\fP (\fBBimage\fP *p, double hires, double lores, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.RI "Calculates a cross-correlation map by Fast Fourier transformation\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcross_correlate\fP (\fBBimage\fP *p, \fBBimage\fP *pmask=NULL)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBcross_correlate\fP (\fBBimage\fP *p, double hires, double lores, \fBBimage\fP *pmask=NULL)"
.br
.RI "Calculates a cross-correlation map by Fast Fourier transformation\&. "
.ti -1c
.RI "double \fBcorrelation_coefficient\fP (\fBVector3\fP< double > \fBshift\fP)"
.br
.RI "Calculates a coefficient from a Fourier correlation transform given a shift\&. "
.ti -1c
.RI "\fBVector3\fP< double > \fBfind_shift_in_transform\fP (double shift_limit)"
.br
.RI "Finds the shift by brute force backtransformation for selected shifts\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcross_correlate_fspace\fP (\fBBimage\fP *p, double hires, double lores, double shift_limit)"
.br
.RI "Calculates a cross-correlation map by Fast Fourier transformation\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcross_correlate\fP (\fBBimage\fP *p, double hires, double lores, \fBBimage\fP *pmask, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBcross_correlate_two_way\fP (\fBBimage\fP *p, double hires, double lores, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.RI "Calculates a cross-correlation map by Fast Fourier transformation\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcross_correlate_validate\fP (\fBBimage\fP *p, \fBBimage\fP *pmask)"
.br
.RI "Calculates a masked cross-correlation map by Fast Fourier transformation\&. "
.ti -1c
.RI "\fBVector3\fP< double > \fBrotate_cross_correlate\fP (\fBBimage\fP *pref, \fBView\fP \fBview\fP, double hires, double lores, double search_radius, \fBBimage\fP *pmask, double &cc, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.ti -1c
.RI "double \fBrotate_cross_correlate_two_way\fP (\fBBimage\fP *pref, double \fBangle\fP, double res_hi, double res_lo, double shift_limit, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.ti -1c
.RI "int \fBfind_shift\fP (\fBBimage\fP *pref, \fBBimage\fP *pmask, double hires, double lores, double radius, double sigma, int refine_flag)"
.br
.RI "Calculates a cross-correlation map to find the shift for the pair of images\&. "
.ti -1c
.RI "\fBVector3\fP< double > \fBfind_shift\fP (\fBBimage\fP *pref, \fBBimage\fP *pmask, double hires, double lores, double radius, double sigma, int refine_flag, double &cc)"
.br
.ti -1c
.RI "\fBVector3\fP< double > \fBfind_shift\fP (\fBBimage\fP *pref, double hires, double lores, double radius, double sigma, int refine_flag, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.RI "Calculates a cross-correlation map to find the shift for the pair of images\&. "
.ti -1c
.RI "\fBVector3\fP< double > \fBfind_shift\fP (\fBBimage\fP *pref, \fBBimage\fP *pmask, double hires, double lores, double radius, double sigma, int refine_flag, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP, double &cc)"
.br
.RI "Calculates a cross-correlation map to find the shift for the pair of images\&. "
.ti -1c
.RI "\fBVector3\fP< double > \fBfind_shift\fP (long nn, \fBBimage\fP *pref, \fBBimage\fP *pmask, double hi_res, double lo_res, double shift_limit, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.RI "Calculates a cross-correlation map to find the shift for the pair of images\&. "
.ti -1c
.RI "\fBBimage\fP * \fBfind_template\fP (\fBBimage\fP *ptemp, \fBBimage\fP *pmask, double hires, double lores, int bin, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.RI "Finds one or more matches to a template\&. "
.ti -1c
.RI "int \fBfind_center\fP (\fBBimage\fP *pmask, double hires, double lores, double radius, double sigma, int refine_flag)"
.br
.RI "Finds the center of mass of an image by cross-correlation with its inverse\&. "
.ti -1c
.RI "\fBVector3\fP< double > \fBrotate_find_shift\fP (\fBMatrix3\fP mat, double hires, double lores, double radius, double sigma, int refine_flag, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP, double &cc)"
.br
.RI "Rotates and find shift by cross-correlation\&. "
.ti -1c
.RI "int \fBfind_peak\fP (double radius=1e30, double sigma=0)"
.br
.RI "Finds the peak in an image to the nearest voxel\&. "
.ti -1c
.RI "\fBVector3\fP< double > \fBfit_peak\fP ()"
.br
.RI "Fits an elliptic parabole to locate the position of the peak to sub-voxel resolution\&. "
.ti -1c
.RI "int \fBrefine_peak_new\fP ()"
.br
.RI "Refines the position of a peak to sub-voxel resolution\&. "
.ti -1c
.RI "int \fBrefine_peak\fP ()"
.br
.RI "Refines the position of a peak to sub-voxel resolution\&. "
.ti -1c
.RI "\fBBimage\fP * \fBfind_peaks\fP (long kernelsize)"
.br
.RI "Finds peaks in a map with periodic boundaries\&. "
.ti -1c
.RI "\fBVector3\fP< double > * \fBfind_peaks\fP (double excl_dist, long &ncoor, double &threshold_min, double &threshold_max, double pix_min=2, double pix_max=10)"
.br
.RI "Finds the peaks in a cross-correlation map to find template matches\&. "
.ti -1c
.RI "double \fBccmap_confidence\fP (long nn)"
.br
.RI "Calculates a confidence level to associate with a cross-correlation peak\&. "
.ti -1c
.RI "double \fBpeak_sigma\fP (long nn, \fBVector3\fP< long > coor, long kernel_size)"
.br
.RI "Calculates a sigma value for a cross-correlation peak\&. "
.ti -1c
.RI "double \fBsearch_views\fP (\fBBimage\fP *ptemp, \fBView\fP *\fBview\fP, double hires, double lores, double search_radius, \fBBimage\fP *pmask, \fBView\fP &currview, \fBVector3\fP< double > &currshift)"
.br
.RI "Searches a 2D/3D density map for a template\&. "
.ti -1c
.RI "double \fBsearch_volume_view\fP (\fBBimage\fP *ptemp, \fBView\fP \fBview\fP, double hires, double lores, \fBBimage\fP *pmask, double threshold, \fBBimage\fP *pfit)"
.br
.RI "Searches a 2D/3D density map for a template using a specific view\&. "
.ti -1c
.RI "\fBBimage\fP * \fBsearch_volume\fP (\fBBimage\fP *ptemp, \fBView\fP *\fBview\fP, double alpha, double alpha_step, double hires, double lores, \fBBimage\fP *pmask, double threshold)"
.br
.RI "Searches a 2D/3D density map for a template\&. "
.ti -1c
.RI "\fBVector3\fP< double > \fBfind_shift_in_transform\fP (long nn, \fBBimage\fP *pref, double shift_limit)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBalign_progressive_fast\fP (long nref, double shift_limit)"
.br
.RI "Aligns and sums a set of sub-images using a progressive algorithm\&. "
.ti -1c
.RI "\fBBimage\fP * \fBalign_progressive\fP (long nref, \fBBimage\fP *pmask, double hi_res, double lo_res, double shift_limit, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.RI "Aligns and sums a set of sub-images using a progressive algorithm\&. "
.ti -1c
.RI "vector< \fBVector3\fP< double > > \fBalign\fP (long ref_num, long window, long step, \fBBimage\fP *pmask, double hi_res, double lo_res, double shift_limit, double edge_width, double gauss_width, \fBVector3\fP< long > bin)"
.br
.RI "Aligns and sums a set of sub-images, first progressively and then iteratively\&. "
.ti -1c
.RI "\fBJSvalue\fP \fBalign_fast\fP (long ref_num, \fBBimage\fP *pmask, double hi_res, double lo_res, double shift_limit, double edge_width, double gauss_width)"
.br
.RI "Aligns and sums a set of sub-images, first progressively and then iteratively\&. "
.ti -1c
.RI "\fBBimage\fP * \fBfspace_sum\fP (int \fBshift\fP=0)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBfspace_shift_sum\fP ()"
.br
.ti -1c
.RI "\fBBimage\fP * \fBfspace_subset_sums\fP (int subset, int flag=0)"
.br
.ti -1c
.RI "\fBBplot\fP * \fBfspace_ssnr\fP (long nimg, double res_hi, double sampling_ratio)"
.br
.ti -1c
.RI "\fBBplot\fP * \fBfspace_subset_ssnr\fP (int subset, double res_hi, double sampling_ratio, int flag=0)"
.br
.ti -1c
.RI "double \fBcorrelate_annuli\fP (\fBBimage\fP *polref, int ann_min, int ann_max, double ang_min, double ang_max, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP, double &cc_max)"
.br
.RI "Correlate annuli of a polar image\&. "
.ti -1c
.RI "vector< double > \fBpps_angular_correlation\fP (\fBBimage\fP *pref, double res_hi, double res_lo, long nang, \fBfft_plan\fP \fBplanf\fP)"
.br
.ti -1c
.RI "double \fBalign2D_pps\fP (\fBBimage\fP *pref, double res_hi, double res_lo, double shift_limit, double angle_limit, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP)"
.br
.RI "Finds the best in-plane alignment for two 2D images using polar power spectra\&. "
.ti -1c
.RI "double \fBalign2D\fP (\fBBimage\fP *pref, double res_polar, int ann_min, int ann_max, \fBBimage\fP *prs_mask, double shift_limit, double angle_limit, \fBfft_plan\fP planf_1D, \fBfft_plan\fP planb_1D, \fBfft_plan\fP planf_2D, \fBfft_plan\fP planb_2D)"
.br
.RI "Finds the best in-plane alignment for two 2D images using polar power spectra\&. "
.ti -1c
.RI "int \fBalign2D\fP (\fBBimage\fP *pref, int ann_min, int ann_max, double res_lo, double res_hi, double shift_limit, double angle_limit)"
.br
.RI "Finds the best in-plane alignment for two 2D images using polar power spectra\&. "
.ti -1c
.RI "void \fBsimple_to_rgb\fP ()"
.br
.RI "A simple image is converted to a color image\&. "
.ti -1c
.RI "void \fBsimple_to_rgba\fP ()"
.br
.RI "A simple image is converted to a color image\&. "
.ti -1c
.RI "void \fBcolor_to_simple\fP ()"
.br
.RI "A color image is converted to a simple image\&. "
.ti -1c
.RI "void \fBrgb_to_rgba\fP ()"
.br
.RI "An alpha channel is added to a \fBRGB\fP color image\&. "
.ti -1c
.RI "void \fBrgba_to_rgb\fP ()"
.br
.RI "The alpha channel is delete from an \fBRGBA\fP color image\&. "
.ti -1c
.RI "void \fBrgb_to_cmyk\fP ()"
.br
.RI "Converts an \fBRGB\fP color image to \fBCMYK\fP\&. "
.ti -1c
.RI "void \fBcmyk_to_rgb\fP ()"
.br
.RI "Converts a \fBCMYK\fP color image to \fBRGB\fP\&. "
.ti -1c
.RI "int \fBone_color\fP (int color, double cmin, double cmax, int flag=0)"
.br
.RI "Converts a gray-scale image to a single color\&. "
.ti -1c
.RI "int \fBcolor_red\fP (double cmin, double cmax, int flag=0)"
.br
.RI "Converts a gray-scale image to red\&. "
.ti -1c
.RI "int \fBcolor_green\fP (double cmin, double cmax, int flag=0)"
.br
.RI "Converts a gray-scale image to green\&. "
.ti -1c
.RI "int \fBcolor_blue\fP (double cmin, double cmax, int flag=0)"
.br
.RI "Converts a gray-scale image to blue\&. "
.ti -1c
.RI "int \fBpure_color\fP ()"
.br
.RI "Generates a pure color image without intensity\&. "
.ti -1c
.RI "int \fBcolor_combine\fP (\fBBimage\fP *p)"
.br
.RI "Combines two colored images\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcolor_spectrum\fP (double cmin, double cmax)"
.br
.RI "Colorizes an image to a spectrum\&. "
.ti -1c
.RI "\fBBimage\fP * \fBred_white_blue\fP (double red_min, double white_min, double white_max, double blue_max)"
.br
.RI "Colorizes an image with blue positive and red negative\&. "
.ti -1c
.RI "int \fBrescale\fP (double scale, double \fBshift\fP)"
.br
.RI "Rescales the image data with a given multiplier and offset\&. "
.ti -1c
.RI "int \fBrescale\fP (long nn, double scale, double \fBshift\fP)"
.br
.RI "Rescales the image data with a given multiplier and offset\&. "
.ti -1c
.RI "int \fBrescale_to_min_max\fP (double numin, double numax)"
.br
.RI "Rescales the image data to a given minimum and maximum\&. "
.ti -1c
.RI "int \fBrescale_to_min_max\fP (long nn, double numin, double numax)"
.br
.RI "Rescales the image data to a given minimum and maximum\&. "
.ti -1c
.RI "int \fBrescale_to_avg_std\fP (double nuavg, double nustd)"
.br
.RI "Rescales the image data to a given average and standard deviation\&. "
.ti -1c
.RI "int \fBrescale_to_avg_std\fP (long nn, double nuavg, double nustd)"
.br
.RI "Rescales the image data to a given average and standard deviation\&. "
.ti -1c
.RI "int \fBrescale_to_avg_std\fP (double nuavg, double nustd, \fBBimage\fP *pmask)"
.br
.RI "Rescales the image data to a given average and standard deviation\&. "
.ti -1c
.RI "int \fBtruncate\fP (double minim, double maxim, double setmin, double setmax)"
.br
.RI "Truncates image data to a given minimum and maximum\&. "
.ti -1c
.RI "int \fBtruncate_to_min_max\fP (double minim, double maxim)"
.br
.RI "Truncates image data to a given minimum and maximum\&. "
.ti -1c
.RI "int \fBtruncate_to_avg\fP (double minim, double maxim)"
.br
.RI "Sets voxels in image data exceeding a given minimum and maximum to the average\&. "
.ti -1c
.RI "int \fBtruncate_to_background\fP (double minim, double maxim)"
.br
.RI "Sets voxels in image data exceeding a given minimum and maximum to the image background\&. "
.ti -1c
.RI "int \fBlimit_levels\fP (int nlevels)"
.br
.RI "Converts a full gray scale image to a limited level image\&. "
.ti -1c
.RI "int \fBnormalize\fP (long imgnum, double \fBaverage\fP, double stdev, int norm_type, long bins)"
.br
.RI "Normalizes a sub-image to a desired average and standard deviation\&. "
.ti -1c
.RI "int \fBnormalize\fP (double \fBaverage\fP, double stdev, int norm_type)"
.br
.RI "Normalizes a set of images to a desired average and standard deviation\&. "
.ti -1c
.RI "int \fBnormalize_local\fP (long kernel_size)"
.br
.RI "Normalizes by subtracting local average and dividing by local standard deviation\&. "
.ti -1c
.RI "int \fBnormalize_local\fP (\fBVector3\fP< long > \fBkernel\fP)"
.br
.RI "Normalizes by subtracting local average and dividing by local standard deviation\&. "
.ti -1c
.RI "void \fBsquare\fP ()"
.br
.RI "Calculates the square of an image\&. "
.ti -1c
.RI "void \fBsquare_root\fP ()"
.br
.RI "Calculates the square root of an image\&. "
.ti -1c
.RI "void \fBlogarithm\fP ()"
.br
.RI "Calculates the logarithm of the image data\&. "
.ti -1c
.RI "void \fBexponential\fP ()"
.br
.RI "Calculates the exponential of the image data\&. "
.ti -1c
.RI "int \fBgradient_correction\fP ()"
.br
.RI "Calculates and corrects for a linear gradient across an image\&. "
.ti -1c
.RI "int \fBquadric_correct\fP (vector< double > param)"
.br
.RI "Corrects for a quadric surface\&. "
.ti -1c
.RI "vector< double > \fBquadric_fit\fP ()"
.br
.RI "Fits the whole image to a quadric surface\&. "
.ti -1c
.RI "\fBBimage\fP * \fBthickness\fP (double reference, double emfp)"
.br
.RI "Calculates a thickness based on intensities with respect to a reference\&. "
.ti -1c
.RI "int \fBcalculate_background\fP (long nn, int flag)"
.br
.RI "Calculates the background for one sub-image\&. "
.ti -1c
.RI "int \fBcalculate_background\fP (int flag=0)"
.br
.RI "Calculates the background for each sub-image\&. "
.ti -1c
.RI "int \fBcalculate_background\fP (\fBBimage\fP *pmask, long nn, int flag=0)"
.br
.RI "Calculates the background for one sub-image\&. "
.ti -1c
.RI "int \fBcalculate_background\fP (\fBBimage\fP *pmask, int flag=0)"
.br
.RI "Calculates the background for each sub-image\&. "
.ti -1c
.RI "int \fBcorrect_background\fP (long nn, int flag)"
.br
.RI "Corrects the background for one sub-image\&. "
.ti -1c
.RI "int \fBcorrect_background\fP (int flag=0)"
.br
.RI "Corrects the background for each sub-image\&. "
.ti -1c
.RI "int \fBcorrect_background\fP (\fBBimage\fP *pmask, int flag=0)"
.br
.RI "Corrects the background for each sub-image\&. "
.ti -1c
.RI "int \fBsubtract_background\fP ()"
.br
.RI "Subtracts the background for each sub-image\&. "
.ti -1c
.RI "int \fBshift_background\fP (double bkg)"
.br
.RI "Sets the background for each sub-image to a given value\&. "
.ti -1c
.RI "vector< long > \fBhistogram\fP (long bins, double &scale, double &offset)"
.br
.RI "Calculates the histogram of an image\&. "
.ti -1c
.RI "\fBBplot\fP * \fBhistogram\fP (long bins)"
.br
.RI "Calculates the histogram of an image\&. "
.ti -1c
.RI "\fBBplot\fP * \fBhistogram_counts\fP (int flags=0)"
.br
.RI "Finds the peaks in a quantized image from the histogram\&. "
.ti -1c
.RI "\fBBplot\fP * \fBpercentiles\fP ()"
.br
.RI "Calculates the percentiles from the histogram of an image\&. "
.ti -1c
.RI "int \fBhistogram_minmax\fP (double &tmin, double &tmax)"
.br
.RI "Calculates minimum and maximum thresholds for truncation\&. "
.ti -1c
.RI "\fBBplot\fP * \fBhistogram_otsu_variance\fP (long bins)"
.br
.RI "Calculates the inter-set variance of the bisection of a historgram using the method of Otsu\&. "
.ti -1c
.RI "double \fBotsu_threshold\fP (long bins)"
.br
.RI "Calculates the threshold from a histogram according to Otsu\&. "
.ti -1c
.RI "vector< double > \fBotsu_variance\fP (vector< long > h)"
.br
.RI "Calculates the inter-set variance of the bisection of a historgram using the method of Otsu\&. "
.ti -1c
.RI "vector< double > \fBhistogram_multi_thresholds\fP (long bins, long number)"
.br
.RI "Calculates multiple thresholds from a histogram\&. "
.ti -1c
.RI "vector< double > \fBhistogram_gauss_fit\fP (long bins, long ngauss=1)"
.br
.RI "Fits a gaussian function to a histogram of an image\&. "
.ti -1c
.RI "vector< double > \fBhistogram_gauss_fit2\fP (long bins, long ngauss=1)"
.br
.ti -1c
.RI "\fBBplot\fP * \fBhistogram_gauss_plot\fP (long bins, long ngauss=1)"
.br
.RI "Fits a gaussian function to a histogram of an image\&. "
.ti -1c
.RI "\fBBplot\fP * \fBhistogram_poisson_fit\fP (long bins, int flag=0)"
.br
.RI "Fits a poisson function to a histogram of an image\&. "
.ti -1c
.RI "int \fBresize\fP (\fBVector3\fP< long > nusize, \fBVector3\fP< long > translate, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Resizes without interpolation or rescaling\&. "
.ti -1c
.RI "\fBBimage\fP * \fBresize_copy\fP (\fBVector3\fP< long > nusize, \fBVector3\fP< long > translate, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Resizes without interpolation or rescaling\&. "
.ti -1c
.RI "int \fBresize_wrap\fP (\fBVector3\fP< long > nusize, \fBVector3\fP< long > translate)"
.br
.RI "Resizes without interpolation or rescaling\&. "
.ti -1c
.RI "\fBBimage\fP * \fBresize_wrap_copy\fP (\fBVector3\fP< long > nusize, \fBVector3\fP< long > translate)"
.br
.RI "Resizes with wrapping without interpolation or rescaling\&. "
.ti -1c
.RI "int \fBpad\fP (long sz, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Pads an image to a new size with a given fill value\&. "
.ti -1c
.RI "int \fBpad\fP (\fBVector3\fP< long > sz, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Pads an image to a new size with a given fill value\&. "
.ti -1c
.RI "\fBBimage\fP * \fBpad_copy\fP (long sz, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Pads an image to a new size with a given fill value\&. "
.ti -1c
.RI "\fBBimage\fP * \fBpad_copy\fP (\fBVector3\fP< long > sz, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Pads an image to a new size with a given fill value\&. "
.ti -1c
.RI "int \fBshrink_wrap\fP (\fBVector3\fP< long > nusize, \fBVector3\fP< long > translate)"
.br
.RI "Shrinks an image to a new size with wrapping of the excluded edges\&. "
.ti -1c
.RI "int \fBenlarge\fP (\fBVector3\fP< long > scale)"
.br
.RI "Enlarges an image by an inetger scale\&. "
.ti -1c
.RI "\fBBimage\fP * \fBmontage\fP (int first, int cols, int rows, int skip=0, int flipy=0)"
.br
.RI "Rearranges an image into a montage of 2D slices for display\&. "
.ti -1c
.RI "int \fBshape\fP (int type, \fBVector3\fP< long > rect, \fBVector3\fP< double > start, double width, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Creates a shape in an image and fills it with a constant value\&. "
.ti -1c
.RI "int \fBshape\fP (long nn, int type, \fBVector3\fP< long > rect, \fBVector3\fP< double > start, double width, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Creates a shape in an image and fills it with a constant value\&. "
.ti -1c
.RI "int \fBline\fP (\fBVector3\fP< double > start, \fBVector3\fP< double > end, double width, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Creates a line in an image and fills it with a constant value\&. "
.ti -1c
.RI "\fBBimage\fP * \fBedge_mask\fP (int type, \fBVector3\fP< long > rect, \fBVector3\fP< double > start, double width)"
.br
.RI "Creates a mask with the edge approaching zero\&. "
.ti -1c
.RI "int \fBedge\fP (int type, \fBVector3\fP< long > rect, \fBVector3\fP< double > start, double width, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Smooths the image edge with a soft rectangular function\&. "
.ti -1c
.RI "int \fBedge\fP (long nn, int type, \fBVector3\fP< long > rect, \fBVector3\fP< double > start, double width, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Smooths the image edge with a soft rectangular function\&. "
.ti -1c
.RI "int \fBhanning_taper\fP (double \fBfill\fP=0)"
.br
.RI "Apply Hanning taper window to the image\&. "
.ti -1c
.RI "int \fBsphere\fP (\fBVector3\fP< double > \fBcenter\fP, double radius, double width=0, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Fills a sphere within an image with a uniform value\&. "
.ti -1c
.RI "int \fBcylinder\fP (\fBVector3\fP< double > \fBcenter\fP, double radius, double \fBheight\fP, double width, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Fills a cylinder within an image with a uniform value\&. "
.ti -1c
.RI "int \fBgaussian_sphere\fP (long nn, \fBVector3\fP< double > \fBcenter\fP, double sigma, double amp)"
.br
.RI "Fills a gaussian sphere within an image with a uniform value\&. "
.ti -1c
.RI "int \fBshell\fP (\fBVector3\fP< double > \fBcenter\fP, double minrad, double maxrad, double width, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Fills a shell within an image with a uniform value\&. "
.ti -1c
.RI "int \fBshell\fP (long nn, \fBVector3\fP< double > \fBcenter\fP, double minrad, double maxrad, double width, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Fills a shell within an image with a uniform value\&. "
.ti -1c
.RI "int \fBshell_wrap\fP (long nn, \fBVector3\fP< double > \fBcenter\fP, double minrad, double maxrad, double width, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Fills a shell within an image with a uniform value with wrapping\&. "
.ti -1c
.RI "int \fBbar\fP (\fBVector3\fP< double > start, \fBVector3\fP< double > end, double width, double edge_width, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Generates a bar between start and end points\&. "
.ti -1c
.RI "int \fBbar\fP (long nn, \fBVector3\fP< double > start, \fBVector3\fP< double > end, double width, double edge_width, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Generates a bar between start and end points\&. "
.ti -1c
.RI "int \fBquadric\fP (double *param)"
.br
.RI "Generates a quadric surface over the whole image\&. "
.ti -1c
.RI "int \fBchirp\fP (double freq_scale, double freq_shift=0)"
.br
.RI "Generates a chirp image\&. "
.ti -1c
.RI "int \fBfill_gaps\fP (long step)"
.br
.RI "Fill the voxels that are not calculated\&. "
.ti -1c
.RI "int \fBinterpolate_gaps\fP (long step)"
.br
.RI "Interpolate the voxels that are not calculated\&. "
.ti -1c
.RI "int \fBtransform\fP (\fBVector3\fP< double > scale, \fBVector3\fP< double > \fBorigin\fP, \fBVector3\fP< double > translate, \fBMatrix3\fP mat, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Transforms an image by translation, rotation, scaling and skewing, in place\&. "
.ti -1c
.RI "\fBBimage\fP * \fBtransform\fP (\fBVector3\fP< long > nusize, \fBVector3\fP< double > scale, \fBVector3\fP< double > \fBorigin\fP, \fBVector3\fP< double > translate, \fBMatrix3\fP mat, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Transforms an image by translation, rotation, scaling and skewing, returning a new image\&. "
.ti -1c
.RI "void \fBtransform_voxel\fP (long i, \fBBimage\fP *pt, long nn, \fBVector3\fP< double > oldorigin, \fBVector3\fP< double > nuorigin, \fBMatrix3\fP affmat, double \fBfill\fP)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBtransform\fP (long nn, \fBVector3\fP< long > nusize, \fBVector3\fP< double > scale, \fBVector3\fP< double > \fBorigin\fP, \fBVector3\fP< double > translate, \fBMatrix3\fP mat, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Transforms a sub-image by translation, rotation, scaling and skewing, returning a single new image\&. "
.ti -1c
.RI "int \fBrotate\fP ()"
.br
.RI "Rotates an image using parameters defined in the image in place\&. "
.ti -1c
.RI "int \fBrotate\fP (double \fBangle\fP)"
.br
.RI "Rotates an image around the z-axis by the given angle in place\&. "
.ti -1c
.RI "int \fBrotate\fP (\fBVector3\fP< double > axis, double \fBangle\fP)"
.br
.RI "Rotates an image using an axis and angle in place\&. "
.ti -1c
.RI "int \fBrotate\fP (\fBView\fP \fBview\fP)"
.br
.RI "Rotates an image to a specified view in place\&. "
.ti -1c
.RI "int \fBrotate\fP (\fBVector3\fP< double > translate, \fBView\fP \fBview\fP)"
.br
.RI "Rotates an image to a specified view in place\&. "
.ti -1c
.RI "int \fBrotate\fP (\fBMatrix3\fP mat)"
.br
.RI "Rotates an image using the specified matrix\&. "
.ti -1c
.RI "int \fBrotate\fP (\fBVector3\fP< double > translate, \fBMatrix3\fP mat)"
.br
.RI "Rotates an image using the specified shift and matrix\&. "
.ti -1c
.RI "\fBBimage\fP * \fBrotate\fP (\fBVector3\fP< long > nusize)"
.br
.RI "Rotates an image using parameters defined in the image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBrotate\fP (\fBVector3\fP< long > nusize, double \fBangle\fP)"
.br
.RI "Rotates an image around the z-axis by the given angle\&. "
.ti -1c
.RI "\fBBimage\fP * \fBrotate\fP (\fBVector3\fP< long > nusize, \fBVector3\fP< double > axis, double \fBangle\fP)"
.br
.RI "Rotates an image using an axis and angle\&. "
.ti -1c
.RI "\fBBimage\fP * \fBrotate\fP (\fBVector3\fP< long > nusize, \fBView\fP \fBview\fP)"
.br
.RI "Rotates an image to a specified view\&. "
.ti -1c
.RI "\fBBimage\fP * \fBrotate\fP (\fBVector3\fP< long > nusize, \fBVector3\fP< double > translate, \fBView\fP \fBview\fP)"
.br
.RI "Rotates an image to a specified view\&. "
.ti -1c
.RI "\fBBimage\fP * \fBrotate\fP (\fBVector3\fP< long > nusize, \fBMatrix3\fP mat)"
.br
.RI "Rotates an image using the specified matrix\&. "
.ti -1c
.RI "int \fBrotate_and_add\fP (\fBBimage\fP *p, \fBVector3\fP< double > \fBorigin\fP, \fBView\fP \fBview\fP)"
.br
.RI "Rotates an image to a specified view and adds it to another image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBorient\fP (\fBView\fP *views)"
.br
.RI "Calculates multiple copies oriented according to views\&. "
.ti -1c
.RI "int \fBmirror\fP ()"
.br
.RI "Inverts/mirrors each image through its origin\&. "
.ti -1c
.RI "int \fBshift\fP (\fBVector3\fP< double > vec, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Shifts an image\&. "
.ti -1c
.RI "int \fBshift\fP (long nn, \fBVector3\fP< double > vec, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Shifts one sub-image\&. "
.ti -1c
.RI "int \fBshift_wrap\fP (\fBVector3\fP< double > vec)"
.br
.RI "Shifts an image\&. "
.ti -1c
.RI "int \fBshift_wrap\fP (long nn, \fBVector3\fP< double > vec)"
.br
.RI "Shifts one sub-image with wrapping\&. "
.ti -1c
.RI "int \fBcenter\fP (int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Centers an image\&. "
.ti -1c
.RI "int \fBcenter_wrap\fP ()"
.br
.RI "Centers an image with wrapping\&. "
.ti -1c
.RI "int \fBzero_origin\fP ()"
.br
.RI "Shifts the origins to zero with wrapping\&. "
.ti -1c
.RI "\fBVector3\fP< long > \fBreciprocal_half\fP ()"
.br
.ti -1c
.RI "\fBBimage\fP * \fBscale_to_same_size\fP (\fBBimage\fP *pref)"
.br
.RI "Scales and image to the given reference\&. "
.ti -1c
.RI "\fBBimage\fP * \fBscale_to_reference\fP (\fBBimage\fP *pref, \fBBimage\fP *pmask, double scalemin, double scalemax, double step)"
.br
.RI "Scales and image to the given reference, searching for the correct scale\&. "
.ti -1c
.RI "\fBBimage\fP * \fBscale_to_reference\fP (\fBBimage\fP *pref, \fBBimage\fP *pmask=NULL)"
.br
.RI "Scales and image to the given reference, searching for the correct scale\&. "
.ti -1c
.RI "double \fBsymmetrize\fP (\fBBstring\fP &symmetry_string, int flag)"
.br
.ti -1c
.RI "double \fBsymmetrize\fP (\fBBsymmetry\fP sym, int flag)"
.br
.ti -1c
.RI "double \fBsymmetrize\fP (\fBBstring\fP &symmetry_string, \fBView\fP ref_view, int flag)"
.br
.ti -1c
.RI "double \fBsymmetrize_cyclic\fP (int cyclic, int flag)"
.br
.ti -1c
.RI "double \fBsymmetrize\fP (\fBBsymmetry\fP sym, \fBView\fP ref_view, int flag)"
.br
.RI "Applies point group symmetry to an image\&. "
.ti -1c
.RI "double \fBcheck_point_group\fP (\fBBstring\fP &check_string)"
.br
.RI "Checks for the requested symmetries\&. "
.ti -1c
.RI "double \fBfind_cyclic_point_group\fP (\fBBsymmetry\fP &sym, int binfac, double hires, double lores)"
.br
.RI "Finds the orientation for an image with a cyclic point group symmetry\&. "
.ti -1c
.RI "double \fBfind_point_group\fP (\fBBsymmetry\fP &sym, double angle_step, int binfac, double hires, double lores, int flags)"
.br
.RI "Finds the orientation for an image with a specific point group symmetry\&. "
.ti -1c
.RI "long \fBrotate_to_axis\fP (\fBBsymmetry\fP &sym, long axis, long axis_flag)"
.br
.RI "Rotates to a symmetry axis\&. "
.ti -1c
.RI "int \fBchange_symmetry\fP (\fBBsymmetry\fP &symold, \fBBsymmetry\fP &symnu, double radius, double z_slope)"
.br
.RI "Changes the symmetry order for cyclic and dihedral maps\&. "
.ti -1c
.RI "\fBMatrix3\fP \fBsymmetry_equivalent\fP (\fBBimage\fP *ptemp, \fBBimage\fP *pmask, \fBBsymmetry\fP &sym)"
.br
.RI "Finds the symmetry equivalent orientation of a particle with respect to a template\&. "
.ti -1c
.RI "\fBMatrix3\fP \fBsymmetry_equivalent_cyclic\fP (\fBBimage\fP *pref, \fBBimage\fP *pmask, \fBBsymmetry\fP &sym)"
.br
.RI "Finds the cyclic symmetry equivalent orientation of a particle with respect to a template\&. "
.ti -1c
.RI "\fBBimage\fP * \fBlevelmask_asymmetric_units\fP (\fBBsymmetry\fP &sym, int \fBindex\fP)"
.br
.RI "Calculates a multi-level mask to indicate asymmetric units\&. "
.ti -1c
.RI "int \fBreplicate_asymmetric_unit\fP (\fBBsymmetry\fP &sym)"
.br
.RI "Calculates a full map from one asymmetric unit\&. "
.ti -1c
.RI "\fBBimage\fP * \fBfind_symmetric_view\fP (\fBBimage\fP *ptemp, \fBBsymmetry\fP &sym, double phi_step, double theta_step, double alpha_step, \fBVector3\fP< double > \fBshift\fP)"
.br
.RI "Finds the view that on symmetrizing fits best to a symmetric template\&. 
.br
 "
.ti -1c
.RI "double \fBhelix_interpolate\fP (long i, double helix_rise, double helix_angle, int zmin, int zmax, double radius, int norm_flag=1)"
.br
.ti -1c
.RI "double \fBdyad_interpolate\fP (long i, int norm_flag=1)"
.br
.ti -1c
.RI "double \fBtube_interpolate\fP (long i, int h, int k, double latconst, int zmin, int zmax, double radius, int norm_flag=1)"
.br
.ti -1c
.RI "double \fBhelix_symmetrize\fP (double helix_rise, double helix_angle, int dyad_axis, int zmin, int zmax, double radius, int norm_flag=1)"
.br
.RI "Symmetrizes an image given helical symmetry parameters\&. "
.ti -1c
.RI "\fBBplot\fP * \fBseamed_helix_symmetrize\fP (double helix_rise, double helix_angle, double seam_shift, int dyad_axis, int zmin, int zmax, double radius, int norm_flag)"
.br
.RI "Symmetrizes an image given helical symmetry parameters and seam shift parameter\&. "
.ti -1c
.RI "\fBBimage\fP * \fBsymmetrize_cylinder\fP (int flag)"
.br
.RI "Calculates a cylindrically symmetrized map\&. "
.ti -1c
.RI "int \fBsymmetrize_cylinder\fP ()"
.br
.RI "Calculates a cylindrically symmetrized map\&. "
.ti -1c
.RI "double \fBtube_symmetrize\fP (int h, int k, double latconst, int zmin, int zmax, double radius, int norm_flag=1)"
.br
.RI "Symmetrizes an image given tubular lattice parameters\&. "
.ti -1c
.RI "double \fBconvert_to_helix\fP (double helix_rise, double helix_angle, \fBVector3\fP< double > offset)"
.br
.RI "Converts a map to a helix\&. "
.ti -1c
.RI "int \fBdistort_elliptically\fP (double \fBangle\fP, double \fBshift\fP)"
.br
.RI "Transforms a tubular cylinder to an elliptical profile\&. "
.ti -1c
.RI "\fBVector3\fP< double > \fBtest_helix_parameters\fP (double \fBangle\fP, double hires, double lores, \fBVector3\fP< long > mask_size, \fBVector3\fP< long > mask_start, long max_iter, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP, double &cc)"
.br
.ti -1c
.RI "\fBBplot\fP * \fBfind_helix_parameters\fP (double angle_start, double angle_end, double angle_step, int bin, double hires, double lores, double radius)"
.br
.RI "Finds the best helix parameters for helical map\&. "
.ti -1c
.RI "double \fBtest_helix_parameters\fP (double rise, double \fBangle\fP, \fBVector3\fP< long > mask_size, \fBVector3\fP< long > mask_start)"
.br
.ti -1c
.RI "\fBBplot\fP * \fBfind_helix_parameters\fP (double rise_start, double rise_end, double rise_step, double angle_start, double angle_end, double angle_step, int bin, double radius)"
.br
.RI "Finds the best helix parameters for helical map\&. "
.ti -1c
.RI "int \fBhelix_segment_correlation_one\fP (long i, double angle_start, double angle_end, double angle_step, int bin, double hires, double lores, double radius, \fBfft_plan\fP \fBplanf\fP, \fBfft_plan\fP \fBplanb\fP, double *cc)"
.br
.ti -1c
.RI "\fBBplot\fP * \fBhelix_segment_correlation\fP (int \fBthickness\fP, double angle_start, double angle_end, double angle_step, int bin, double hires, double lores, double radius)"
.br
.RI "Calculates the correlation over rotation angles between helical segments\&. "
.ti -1c
.RI "int \fBtransform_lines\fP ()"
.br
.ti -1c
.RI "\fBBimage\fP * \fBhelical_cross_section\fP (double helix_rise, double helix_angle, double scale, double hires)"
.br
.RI "Calculates a helical cross section from line transforms of a filament\&. "
.ti -1c
.RI "double \fBsnvariance\fP (double snradius)"
.br
.RI "Calculates the ratio of variance inside and outside a given radius\&. "
.ti -1c
.RI "int \fBextrude_cross_section\fP (long \fBlength\fP, double helix_rise, double helix_angle, int fill_type, double \fBfill\fP)"
.br
.RI "Extrudes a 2D cross section into a 3D continuous helix\&. "
.ti -1c
.RI "\fBBplot\fP * \fBfilament_width\fP (long width, long lim_lo, long lim_hi)"
.br
.RI "Estimates the width of a filament\&. "
.ti -1c
.RI "\fBBimage\fP * \fBfilament_density\fP (double width)"
.br
.RI "Estimates the density per pixel length of a filament\&. "
.ti -1c
.RI "\fBBimage\fP * \fBfilament_from_projections\fP (double hi_res, int flag=0)"
.br
.RI "Reconstructs a filament from a set of projections\&. "
.ti -1c
.RI "\fBBimage\fP * \fBradial\fP (long minrad, long maxrad, double rad_step=1, int wrap=0)"
.br
.RI "Calculates the radial average of an image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBradial\fP (long minrad, long maxrad, double rad_step, \fBBimage\fP *pmask, int wrap=0)"
.br
.RI "Calculates the radial average of an image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBradial\fP (long minrad, long maxrad, double rad_step, double ellipticity, double \fBangle\fP, \fBBimage\fP *pmask, int wrap=0)"
.br
.RI "Calculates the radial average of an image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBradial_symmetry_adjusted\fP (double rad_start, double rad_end, double rad_step, double spherical_fraction, \fBBsymmetry\fP &sym)"
.br
.RI "Calculates the symmetry-adjusted radial average of an image\&. "
.ti -1c
.RI "double * \fBradial_fit\fP (\fBBimage\fP *pref)"
.br
.RI "Fits a radial profile to a reference radial profile\&. "
.ti -1c
.RI "\fBBimage\fP * \fBradial_to_full\fP (\fBVector3\fP< long > nusize, \fBVector3\fP< double > \fBorigin\fP)"
.br
.RI "Generates a full 2D or 3D image from a radial profile in a 1D image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcartesian_to_spherical\fP (long nannuli, long nphi, long ntheta)"
.br
.RI "Calculates an image with spherical coordinates\&. "
.ti -1c
.RI "\fBBimage\fP * \fBcartesian_to_cylindrical\fP (long nannuli, long nphi, int flag=0)"
.br
.RI "Calculates an image with cylindrical coordinates\&. "
.ti -1c
.RI "\fBBimage\fP * \fBpolar_transform\fP (long nangles, long ann_min, long ann_max, long dann, long zmin, long zmax, long zinc)"
.br
.RI "Calculates an image with cylindrical coordinates by integration\&. "
.ti -1c
.RI "\fBBimage\fP * \fBpolar_power_spectrum\fP (double resolution, long num_angle)"
.br
.RI "Calculates the polar power spectrum of a 2D transform amplitude or intensity image\&. "
.ti -1c
.RI "int \fBline_powerspectra\fP (\fBfft_plan\fP plan)"
.br
.RI "Calculates the 1D power spectrum of each line in an image\&. "
.ti -1c
.RI "int \fBradial_shells\fP ()"
.br
.RI "Calculates an image with slices representing radial shell projections\&. "
.ti -1c
.RI "int \fBcylindrical_shells\fP ()"
.br
.RI "Calculates an image with slices representing cylindrical shell projections\&. "
.ti -1c
.RI "\fBBimage\fP * \fBradial_sections\fP (double rad_start, double rad_end, double rad_step, double spherical_fraction, \fBBsymmetry\fP &sym, int fill_type=\fBFILL_USER\fP, double \fBfill\fP=0)"
.br
.RI "Calculates an image with slices giving the radial section projections\&. "
.ti -1c
.RI "\fBBimage\fP * \fBradial_coverage\fP (double threshold, double rad_step=1)"
.br
.RI "Calculates the coverage in each radial shell\&. "
.ti -1c
.RI "\fBBimage\fP * \fBtopograph_to_surface\fP (\fBBimage\fP *psd, long nz, double \fBdensity\fP, double resolution)"
.br
.RI "Converts a 2D AFM image to a 3D density map\&. "
.ti -1c
.RI "\fBBimage\fP * \fBsurface_to_topograph\fP (double threshold, int dir=0)"
.br
.RI "Converts a 3D image to a 2D height image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBrotate_height\fP (\fBMatrix3\fP mat, \fBVector3\fP< double > translate, double threshold=0)"
.br
.RI "Rotates a 3D map and calculates the height along the z-axis\&. "
.ti -1c
.RI "\fBBimage\fP * \fBheight\fP (\fBView\fP *views, double threshold=0)"
.br
.RI "Calculates a set of height images from a 3D density map\&. "
.ti -1c
.RI "int \fBinteger_interpolation\fP (int integer_factor)"
.br
.ti -1c
.RI "int \fBinteger_interpolation\fP (int integer_factor, int odd)"
.br
.RI "Interpolates by an integer scale with a density-preserving overlapping kernel\&. "
.ti -1c
.RI "int \fBbin\fP (long b)"
.br
.ti -1c
.RI "int \fBbin\fP (\fBVector3\fP< long > bk)"
.br
.RI "Bins by an integer size in place\&. "
.ti -1c
.RI "\fBBimage\fP * \fBbin_copy\fP (long b)"
.br
.ti -1c
.RI "\fBBimage\fP * \fBbin_copy\fP (\fBVector3\fP< long > bk)"
.br
.RI "Bins by an integer size and returns a new image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBbin_around_origin\fP (int bin)"
.br
.RI "Bins by an integer size making sure the origin falls on a binned voxel, and returns a new image\&. "
.ti -1c
.RI "int \fBmedian_bin\fP (int binning)"
.br
.RI "Bins by an integer size, selecting the kernel median\&. "
.ti -1c
.RI "int \fBnoise_uniform\fP (double rmin, double rmax)"
.br
.RI "Generates an image with a uniform random distribution of densities\&. "
.ti -1c
.RI "int \fBnoise_gaussian\fP (double ravg=0, double rstd=1)"
.br
.RI "Generates an image with a gaussian random distribution of densities\&. "
.ti -1c
.RI "int \fBnoise_poisson\fP (double ravg)"
.br
.RI "Generates an image with a poisson random distribution of densities\&. "
.ti -1c
.RI "int \fBnoise_logistical\fP (double ravg, double rstd)"
.br
.RI "Generates an image with a gaussian random distribution of densities\&. "
.ti -1c
.RI "int \fBnoise_spectral\fP (double alpha)"
.br
.RI "Generates a noise map with a defined spectral decay\&. "
.ti -1c
.RI "long \fBmask\fP (\fBBimage\fP *pmask, double \fBfill\fP)"
.br
.RI "Masks an image\&. "
.ti -1c
.RI "long \fBto_mask\fP ()"
.br
.ti -1c
.RI "long \fBto_mask\fP (double threshold)"
.br
.RI "Change the image to a mask\&. "
.ti -1c
.RI "\fBBimage\fP * \fBmask_by_threshold\fP (double threshold)"
.br
.RI "Generates a mask based on an image at a given threshold\&. "
.ti -1c
.RI "\fBBimage\fP * \fBmask_by_thresholds\fP (vector< double > threshold)"
.br
.RI "Generates a mask based on an image at given thresholds\&. "
.ti -1c
.RI "\fBBimage\fP * \fBmask_by_conditional_thresholds\fP (vector< double > threshold)"
.br
.RI "Generates a mask based on a conditional hierarchy of thresholds\&. "
.ti -1c
.RI "long \fBmask_stats\fP ()"
.br
.RI "Calculates statistics for a mask\&. "
.ti -1c
.RI "long \fBmask_invert\fP ()"
.br
.RI "Inverts a mask\&. "
.ti -1c
.RI "long \fBmask_combine\fP (\fBBimage\fP *p, int operation)"
.br
.RI "Combines two masks with different operations\&. "
.ti -1c
.RI "\fBBimage\fP * \fBmask_extract\fP (\fBBimage\fP *pmask)"
.br
.RI "Zeroes everything outside the mask and return the excised feature\&. "
.ti -1c
.RI "int \fBmax_in_kernel\fP (long ksize)"
.br
.ti -1c
.RI "long \fBmask_dilate_erode\fP (unsigned char dir)"
.br
.RI "Dilates or erodes a binary mask\&. "
.ti -1c
.RI "long \fBmask_dilate\fP (long times=1)"
.br
.RI "Dilates a binary mask\&. "
.ti -1c
.RI "long \fBmask_erode\fP (long times=1)"
.br
.RI "Erodes a binary mask\&. "
.ti -1c
.RI "long \fBmask_open\fP (int times=1)"
.br
.RI "Opens a binary mask\&. "
.ti -1c
.RI "long \fBmask_close\fP (int times=1)"
.br
.RI "Closes a binary mask\&. "
.ti -1c
.RI "long \fBmask_fill\fP (\fBVector3\fP< long > voxel)"
.br
.RI "Fills an empty part of a mask indicated by the given voxel\&. "
.ti -1c
.RI "long \fBmask_shell\fP (\fBVector3\fP< double > \fBorigin\fP, double rad_min, double rad_max)"
.br
.ti -1c
.RI "long \fBmask_plane\fP (\fBVector3\fP< double > \fBorigin\fP, \fBVector3\fP< double > normal)"
.br
.RI "Generates a mask on one side of a plane\&. "
.ti -1c
.RI "long \fBmask_rectangle\fP (double \fBlength\fP, double width, double rect_angle, int wrap)"
.br
.RI "Generates a mask along an axis within a 2D image\&. "
.ti -1c
.RI "long \fBmask_symmetrize\fP (\fBBsymmetry\fP &sym)"
.br
.RI "Symetrizes a mask\&. "
.ti -1c
.RI "\fBVector3\fP< double > \fBmask_fspace_resize\fP (\fBVector3\fP< long > nusize)"
.br
.RI "Resizes a reciprocal space mask\&. "
.ti -1c
.RI "vector< double > \fBfspace_default_bands\fP (double res_lo, double res_hi)"
.br
.RI "Sets up default frequency space bands to generate a mask\&. "
.ti -1c
.RI "int \fBmask_fspace_banded\fP (vector< double > &band)"
.br
.RI "Generate reciprocal space mask based on a specification of bands\&. "
.ti -1c
.RI "long \fBmask_missing_wedge\fP (\fBVector3\fP< double > \fBorigin\fP, double tilt_axis, double tilt_neg, double tilt_pos, double resolution)"
.br
.RI "Generates a mask with a missing wedge\&. "
.ti -1c
.RI "long \fBmask_missing_pyramid\fP (\fBVector3\fP< double > \fBorigin\fP, double tilt_axis1, double tilt_axis2, double tilt_neg1, double tilt_pos1, double tilt_neg2, double tilt_pos2, double resolution)"
.br
.RI "Generates a mask with a missing pyramid\&. "
.ti -1c
.RI "long \fBmask_missing_cone\fP (\fBVector3\fP< double > \fBorigin\fP, double mis_ang, double resolution)"
.br
.RI "Generates a mask with a missing cone\&. "
.ti -1c
.RI "long \fBmask_missing_find\fP (\fBVector3\fP< double > ori, double resolution, \fBBstring\fP &mis_type)"
.br
.RI "Generates a missing mask from an example image\&. "
.ti -1c
.RI "long \fBmask_pack_plane\fP (\fBMatrix3\fP mat, double hi_res, double scale)"
.br
.RI "Packs a 2D mask into a 3D reciprocal space volume\&. 
.br
 "
.ti -1c
.RI "double \fBvariance_threshold\fP (double lowvar)"
.br
.RI "Calculates a threshold for a local variance image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBvariance_mask\fP (long kernel_size, double lowvar=1e\-6, int bkg_flag=0)"
.br
.RI "Calculates a mask based on local variance\&. "
.ti -1c
.RI "\fBBimage\fP * \fBtile_mask\fP (long step)"
.br
.RI "Converts a mask to a tiled multilevel mask\&. "
.ti -1c
.RI "long \fBmask_split\fP (long voxels_per_level)"
.br
.RI "Converts a mask to a multilevel mask with a given number of voxels per level\&. "
.ti -1c
.RI "long \fBlevelmask_collapse\fP ()"
.br
.RI "Collapse a multi-level mask to a binary mask\&. "
.ti -1c
.RI "long \fBlevelmask_add\fP (\fBBimage\fP *pmask, int add_level=1)"
.br
.RI "Adds a bilevel mask to a level mask\&. "
.ti -1c
.RI "long \fBlevelmask_dilate\fP (int times)"
.br
.RI "Dilates a level mask\&. "
.ti -1c
.RI "long \fBlevelmask_dilate\fP ()"
.br
.RI "Dilates a level mask\&. "
.ti -1c
.RI "long \fBlevelmask_select\fP (\fBBstring\fP &select_list, int flag=0)"
.br
.RI "Retains the selected levels in a multi-level mask\&. "
.ti -1c
.RI "long \fBlevelmask_combine\fP (\fBBstring\fP &select_list)"
.br
.RI "Combines the selected levels in a multi-level mask and renumber\&. "
.ti -1c
.RI "long \fBlevelmask_select\fP (long nn, \fBVector3\fP< long > voxel)"
.br
.RI "Retains the selected levels in a multi-level mask\&. "
.ti -1c
.RI "long \fBlevelmask_select\fP (\fBBimage\fP *pmask)"
.br
.RI "Selects regions overlapping a mask\&. "
.ti -1c
.RI "long \fBlevelmask_switch\fP (long index1, long index2)"
.br
.RI "Switches two segments in a multi-level mask\&. "
.ti -1c
.RI "int \fBlevel_masked_stats\fP (\fBBimage\fP *pmask)"
.br
.RI "Caclulates statistics for all the regions defined by a multi-level mask\&. "
.ti -1c
.RI "long \fBlevelmask_symmetrize\fP (\fBBsymmetry\fP &sym)"
.br
.RI "Symetrizes a multi-level mask\&. "
.ti -1c
.RI "\fBBimage\fP * \fBlevel_mask_extract\fP (\fBBimage\fP *pmask, int fill_type=0, double \fBfill\fP=0)"
.br
.RI "Extracts all the regions associated with a multi-level mask\&. "
.ti -1c
.RI "double \fBlevelmask_average_region_size\fP ()"
.br
.RI "Calculates the average size of regions in a level mask\&. "
.ti -1c
.RI "long \fBlevelmask_clean\fP ()"
.br
.RI "Removes empty levels from a multi-level mask\&. "
.ti -1c
.RI "long \fBlevelmask_colorize\fP ()"
.br
.RI "Colorizes a multi-level mask with random color assignments\&. "
.ti -1c
.RI "\fBBimage\fP * \fBlevelmask_color_by_size\fP ()"
.br
.RI "Color a multi-level mask based on the volumes of regions\&. "
.ti -1c
.RI "int \fBlevelmask_region_size\fP ()"
.br
.RI "Convert a mask to reflect region sizes\&. "
.ti -1c
.RI "\fBBplot\fP * \fBlevelmask_size_histogram\fP ()"
.br
.RI "Color a multi-level mask based on the volumes of regions\&. "
.ti -1c
.RI "\fBMatrix\fP \fBmask_interface_matrix\fP (int img_num)"
.br
.RI "Calculates the interfaces between regions\&. "
.ti -1c
.RI "long \fBmask_region_interfaces\fP (int reg_num)"
.br
.RI "Reports the whole interface matrix or interfaces for one region only\&. "
.ti -1c
.RI "long \fBmask_merge_delete\fP (long min_size, long min_if)"
.br
.RI "Calculates the interfaces between regions and deletes/merges small ones\&. "
.ti -1c
.RI "long \fBapply_soft_mask\fP (long nn, \fBBimage\fP *pmask, int fill_type, double \fBfill\fP)"
.br
.RI "Applies a soft mask to a sub-image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBregions\fP (double threshold, int sign)"
.br
.RI "Segments an image into contiguous regions\&. "
.ti -1c
.RI "long \fBregion_assign\fP (\fBBimage\fP *pmask, long idx, long region_number, double threshold, int sign)"
.br
.RI "Finds all the pixels that are part of the same region\&. "
.ti -1c
.RI "int \fBregion_threshold_series\fP (double threshold_first, double threshold_last, double threshold_step)"
.br
.RI "Segments a map through a series of thresholds and reports results\&. "
.ti -1c
.RI "long \fBregion_flood\fP (\fBBimage\fP *pmask, double threshold_hi, double threshold_lo, double threshold_step, int fill_borders)"
.br
.RI "Creates and expands a region map from a starting to ending threshold value\&. "
.ti -1c
.RI "long \fBcheck_neighbors\fP (long idx)"
.br
.RI "Check neighbors in region map and assign a value if a neighbor is assigned\&. "
.ti -1c
.RI "\fBBimage\fP * \fBtrack_gradient\fP (double threshold, int flag=0)"
.br
.RI "Generates a segmented image from peaks above a threshold value\&. "
.ti -1c
.RI "\fBBimage\fP * \fBregion_peaks\fP (long kernel_size, double threshold, int flood=0, int wrap=0)"
.br
.RI "Generates a segmented image from peaks above a threshold value\&. "
.ti -1c
.RI "long \fBblobs\fP (double threshold, double min_size, double max_size, double setvalue, int sign)"
.br
.RI "Identifies contiguous regions above a given threshold (blobs) and eliminate those less than a minimum size\&. "
.ti -1c
.RI "int \fBfilter_extremes\fP ()"
.br
.RI "Filters the extremes out of a micrograph image\&. "
.ti -1c
.RI "int \fBfilter_extremes\fP (int mod_flag)"
.br
.RI "Filters the extremes out of an image\&. "
.ti -1c
.RI "int \fBfilter_extremes\fP (double tmin, double tmax, int \fBkernel\fP=3)"
.br
.RI "Filters the extremes out of an image by replacing with adjacent averages\&. "
.ti -1c
.RI "long \fBreplace_maxima\fP (double threshold)"
.br
.RI "Replaces maxima above a threshold using local averages\&. "
.ti -1c
.RI "double \fBmass_threshold\fP (long img_num, double mol_weight, double rho)"
.br
.RI "Finds the density threshold associated with a particular molecular weight\&. "
.ti -1c
.RI "double \fBmass_at_threshold\fP (long img_num, double threshold, double rho)"
.br
.RI "Calculates the mass from the density threshold\&. "
.ti -1c
.RI "\fBBimage\fP * \fBinternal_volume\fP (double threshold)"
.br
.RI "Calculates the internal volume of a shell\&. "
.ti -1c
.RI "\fBBimage\fP * \fBinternal_volume\fP (double threshold, int mask_out_freq)"
.br
.RI "Calculates the internal volume of a shell\&. "
.ti -1c
.RI "\fBBimage\fP * \fBkmeans_segment\fP (long nregion=2, long max_iter=10, double ratio=1)"
.br
.RI "Segments an image based on K-means\&. "
.ti -1c
.RI "\fBGSgraph\fP \fBgraph_setup\fP (int connect_type)"
.br
.RI "Initializing voxels and edges for graph-based segmentation\&. "
.ti -1c
.RI "\fBGSgraph\fP \fBgraph_segment\fP (int type=1, int connect_type=0, double complexity=0, long min_size=0)"
.br
.RI "Graph-based segmentation of an image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBgraph_segments_to_image\fP (\fBGSgraph\fP &g)"
.br
.RI "Converting a graph-based segmentation to an image\&. "
.ti -1c
.RI "\fBBimage\fP * \fBgraph_segments_to_mask\fP (\fBGSgraph\fP &g)"
.br
.RI "Converting a graph-based segmentation to a multi-level mask\&. "
.ti -1c
.RI "int \fBsuperpixels_update\fP (\fBBimage\fP *pmask, vector< long > vstep, double colorweight, vector< \fBBsuperpixel\fP > &seg)"
.br
.ti -1c
.RI "vector< \fBBsuperpixel\fP > \fBsuperpixels_from_mask\fP (long cc, long step)"
.br
.RI "Create superpixels from a multilevel mask\&. "
.ti -1c
.RI "vector< \fBBsuperpixel\fP > \fBsuperpixels\fP (long step, double colorweight=0\&.2, long iterations=10, double stop=1)"
.br
.RI "Segment the image into superpixels\&. "
.ti -1c
.RI "vector< \fBBsuperpixel\fP > \fBsuperpixels\fP (long step, double colorweight=0\&.2, long iterations=10, long bin_levels=1, double stop=1)"
.br
.ti -1c
.RI "int \fBimpose_superpixels\fP (\fBBimage\fP *pmask, vector< \fBBsuperpixel\fP > &seg, int impose)"
.br
.RI "Impose superpixel features onto an image\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBBimage\fP * \fBnext\fP"
.br
.ti -1c
.RI "\fBBsub_image\fP * \fBimage\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
General image parameter class\&. 


.PP
.nf
All floating point coordinates are in angstroms and converted 
using the voxel units parameters.

.fi
.PP
 
.PP
Definition at line 161 of file Bimage\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Bimage::Bimage ()"

.PP
Initializes an image\&. 
.PP
.nf
The internal initialization function is called.

.fi
.PP
 
.PP
Definition at line 43 of file Bimage\&.cpp\&.
.SS "Bimage::Bimage (const \fBBimage\fP & p)"

.PP
The copy constructor\&. 
.PP
.nf
The internal copy function is called.

.fi
.PP
 
.PP
Definition at line 57 of file Bimage\&.cpp\&.
.SS "Bimage::Bimage (\fBBstring\fP & fn, int readdata, int img_select)"

.PP
Reads an image from a file\&. 
.PP
.nf
The internal initialization function is called.

.fi
.PP
 
.PP
Definition at line 69 of file Bimage\&.cpp\&.
.SS "Bimage::Bimage (\fBDataType\fP type, \fBCompoundType\fP ctype, long nx, long ny, long nz, long nn)"

.PP
Initializes an image\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP data type\&. 
.br
\fIctype\fP compound type\&. 
.br
\fInx\fP x dimension\&. 
.br
\fIny\fP y dimension\&. 
.br
\fInz\fP z dimension\&. 
.br
\fInn\fP number of sub-images\&. 
.PP
.nf
The internal initialization function is called.
The basic properties and size is set up and the data allocated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 91 of file Bimage\&.cpp\&.
.SS "Bimage::Bimage (\fBDataType\fP type, \fBCompoundType\fP ctype, \fBVector3\fP< long > size, long nn)"

.PP
Initializes an image\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP data type\&. 
.br
\fIctype\fP compound type\&. 
.br
\fIsize\fP image size\&. 
.br
\fInn\fP number of sub-images\&. 
.PP
.nf
The internal initialization function is called.
The basic properties and size is set up and the data allocated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 112 of file Bimage\&.cpp\&.
.SS "Bimage::Bimage (\fBDataType\fP type, \fBCompoundType\fP ctype, vector< long > size, long nn)"

.PP
Initializes an image\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP data type\&. 
.br
\fIctype\fP compound type\&. 
.br
\fIsize\fP image size\&. 
.br
\fInn\fP number of sub-images\&.
.RE
.PP
The internal initialization function is called\&. The basic properties and size is set up and the data allocated\&. 
.PP
Definition at line 132 of file Bimage\&.cpp\&.
.SS "Bimage::Bimage (\fBDataType\fP type, long nc, long nx, long ny, long nz, long nn)"

.PP
Initializes a generic multi-channel image\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP data type\&. 
.br
\fInc\fP number of channels\&. 
.br
\fInx\fP x dimension\&. 
.br
\fIny\fP y dimension\&. 
.br
\fInz\fP z dimension\&. 
.br
\fInn\fP number of sub-images\&. 
.PP
.nf
The internal initialization function is called.
The basic properties and size is set up and the data allocated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 154 of file Bimage\&.cpp\&.
.SS "Bimage::Bimage (\fBDataType\fP type, long nc, \fBVector3\fP< long > size, long nn)"

.PP
Initializes a generic multi-channel image\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP data type\&. 
.br
\fInc\fP number of channels\&. 
.br
\fIsize\fP image size\&. 
.br
\fInn\fP number of sub-images\&. 
.PP
.nf
The internal initialization function is called.
The basic properties and size is set up and the data allocated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 175 of file Bimage\&.cpp\&.
.SS "Bimage::Bimage (\fBMatrix\fP & mat, long scale)"

.PP
Initializes an image from a 2D matrix\&. 
.PP
\fBParameters\fP
.RS 4
\fImat\fP matrix\&. 
.br
\fIscale\fP integer scale for enlarging the image\&. 
.PP
.nf
The internal initialization function is called.
The basic properties and size is set up and the data allocated.
The matrix contents are transferred with dimension scaling.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 194 of file Bimage\&.cpp\&.
.SS "Bimage::~Bimage ()"

.PP
Image destructor\&. 
.PP
.nf
All properties and associated data are deallocated.

.fi
.PP
 
.PP
Definition at line 222 of file Bimage\&.cpp\&.
.SH "Member Function Documentation"
.PP 
.SS "void Bimage::add (\fBBimage\fP * p)"

.PP
Adds another image to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP image to be added\&. 
.PP
.nf
Requirement: The images must have the same size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3653 of file Bimage\&.cpp\&.
.SS "void Bimage::add (\fBBimage\fP * p, double scale, double shift)"

.PP
Adds another image to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP image to be added\&. 
.br
\fIscale\fP density scale to other image 
.br
\fIshift\fP density shift to other image\&. 
.PP
.nf
Requirement: The images must have the same size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3728 of file Bimage\&.cpp\&.
.SS "void Bimage::add (double v)"

.PP
Adds a constant value to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIv\fP constant to be added\&. 
.RE
.PP

.PP
Definition at line 3434 of file Bimage\&.cpp\&.
.SS "void Bimage::add (double xx, double yy, double zz, long nn, double v)"

.PP
Adds a value at a given location to neigboring data elements\&. 
.PP
\fBParameters\fP
.RS 4
\fIxx\fP x location\&. 
.br
\fIyy\fP y location\&. 
.br
\fIzz\fP z location\&. 
.br
\fInn\fP image number (4 th dimension)\&. 
.br
\fIv\fP value to add\&. 
.PP
.nf
Inverse of trilinear interpolation.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1275 of file Bimage\&.cpp\&.
.SS "void Bimage::add (long j, \fBComplex\fP< double > cv)\fC [inline]\fP"

.PP
Definition at line 317 of file Bimage\&.h\&.
.SS "void Bimage::add (long j, double v)\fC [inline]\fP"

.PP
Definition at line 316 of file Bimage\&.h\&.
.SS "void Bimage::add (long nn, \fBBimage\fP * p)"

.PP
Adds another image to a sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fI*p\fP image to be added\&. 
.PP
.nf
Requirement: The images must have the same size.
If the FOM block is defined, it is used to accumulate a sum of:
    the FOM block of the added image if it exists,
    or otherwise the square of the data added.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3706 of file Bimage\&.cpp\&.
.SS "void Bimage::add (long nn, \fBBimage\fP * p, double scale, double shift)"

.PP
Adds another image to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fI*p\fP image to be added\&. 
.br
\fIscale\fP density scale to other image 
.br
\fIshift\fP density shift to other image\&. 
.PP
.nf
Requirement: The images must have the same size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3755 of file Bimage\&.cpp\&.
.SS "vector< \fBVector3\fP< double > > Bimage::align (long ref_num, long window, long step, \fBBimage\fP * pmask, double hi_res, double lo_res, double shift_limit, double edge_width, double gauss_width, \fBVector3\fP< long > aln_bin)"

.PP
Aligns and sums a set of sub-images, first progressively and then iteratively\&. 
.PP
\fBParameters\fP
.RS 4
\fIref_num\fP reference sub-image\&. 
.br
\fIwindow\fP moving sum window\&. 
.br
\fIstep\fP moving sum interval\&. 
.br
\fI*pmask\fP cross-correlation mask\&. 
.br
\fIhi_res\fP high resolution limit\&. 
.br
\fIlo_res\fP low resolution limit\&. 
.br
\fIshift_limit\fP limit on extent of search for shift\&. 
.br
\fIedge_width\fP width of smoothing edge\&. 
.br
\fIgauss_width\fP decay coefficient for smoothing edge\&. 
.br
\fIaln_bin\fP 3-value vector indicating binning level\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<\fBVector3<double>\fP> vector of shifts\&. 
.PP
.nf
The images are first aligned using a progressive algorith starting with 
the indicated reference image.
The images are then aligned iteratively using the average image to 
improve the average.
The image is extensively modified and should not be used for further processing.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 253 of file Bimage_align\&.cpp\&.
.SS "double Bimage::align2D (\fBBimage\fP * pref, double res_polar, int ann_min, int ann_max, \fBBimage\fP * prs_mask, double shift_limit, double angle_limit, \fBfft_plan\fP planf_1D, \fBfft_plan\fP planb_1D, \fBfft_plan\fP planf_2D, \fBfft_plan\fP planb_2D)"

.PP
Finds the best in-plane alignment for two 2D images using polar power spectra\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pref\fP reference 2D image\&. 
.br
\fIres_polar\fP polar resolution limit\&. 
.br
\fIann_min\fP minimum annulus (>=0)\&. 
.br
\fIann_max\fP maximum annulus (< image radius)\&. 
.br
\fI*prs_mask\fP dual mask\&. 
.br
\fIshift_limit\fP maximum shift from nominal origin of box\&. 
.br
\fIangle_limit\fP maximum rotation from original in-plane rotation angle\&. 
.br
\fIplanf_1D\fP FFT forward plan for polar images\&. 
.br
\fIplanb_1D\fP FFT backward plan for polar images\&. 
.br
\fIplanf_2D\fP FFT forward plan for 2D images\&. 
.br
\fIplanb_2D\fP FFT backward plan for 2D images\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double correlation coefficient\&. 
.PP
.nf
Both the image and reference is converted to polar images using the 
current origins. The annuli of the polar images are cross-correlated
to find the rotation angle. The reference is rotated and cross-correlated
with the image to determine a new origin for the image. This is iterated
untill the rotation angle and origin of the image does not change any more,
or a maximum number of iterations.
The cross-correlation is done with the provided mask..
The correlation coefficient return is the cross-correlation peak.
The input images must be equal-sized square 2D images.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1478 of file Bimage_align\&.cpp\&.
.SS "int Bimage::align2D (\fBBimage\fP * pref, int ann_min, int ann_max, double res_lo, double res_hi, double shift_limit, double angle_limit)"

.PP
Finds the best in-plane alignment for two 2D images using polar power spectra\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pref\fP reference 2D image\&. 
.br
\fIann_min\fP minimum annulus (>=0)\&. 
.br
\fIann_max\fP maximum annulus (< image radius)\&. 
.br
\fIres_lo\fP low resolution limit (angstrom)\&. 
.br
\fIres_hi\fP high resolution limit (angstrom)\&. 
.br
\fIshift_limit\fP maximum shift from nominal origin of box\&. 
.br
\fIangle_limit\fP maximum rotation from original in-plane rotation angle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double correlation coefficient\&. 
.PP
.nf
This is a simplified interface to the other function Bimage::align2D.
All the fourier transform and rotation functions are handled internally.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1567 of file Bimage_align\&.cpp\&.
.SS "double Bimage::align2D_pps (\fBBimage\fP * pref, double res_hi, double res_lo, double shift_limit, double angle_limit, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Finds the best in-plane alignment for two 2D images using polar power spectra\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pref\fP reference 2D image\&. 
.br
\fIres_hi\fP high resolution limit\&. 
.br
\fIres_lo\fP low resolution limit\&. 
.br
\fIshift_limit\fP maximum shift from nominal origin of box\&. 
.br
\fIangle_limit\fP maximum rotation from original in-plane rotation angle\&. 
.br
\fIplanf\fP FFT forward plan\&. 
.br
\fIplanb\fP FFT backward plan\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double correlation coefficient\&. 
.PP
.nf
The rotation angle is found by cross-correlating the annuli
of the polar transforms of the power spectra of the image and the
reference image. If the full asu flag is not set, the annular cross-correlation
is done both forwards and backwards to detect mirror images, with the sign 
of the angle indicating which direction is best (>0 => forwards, <0 => backwards).
The resolution limit specified in the image is used to low-pass filter 
the cross-correlation. The shift is then determined by cross-correlation 
after rotating the reference image, as well as its 180° rotation to deal with
that ambiguity in the power spectrum.
The correlation coefficient return is the cross-correlation peak.
The input images must be equal-sized square 2D images.
The origin and rotation angle is returned in the image structure.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1389 of file Bimage_align\&.cpp\&.
.SS "\fBJSvalue\fP Bimage::align_fast (long ref_num, \fBBimage\fP * pmask, double hi_res, double lo_res, double shift_limit, double edge_width, double gauss_width)"

.PP
Aligns and sums a set of sub-images, first progressively and then iteratively\&. 
.PP
\fBParameters\fP
.RS 4
\fIref_num\fP reference sub-image\&. 
.br
\fI*pmask\fP cross-correlation mask\&. 
.br
\fIhi_res\fP high resolution limit\&. 
.br
\fIlo_res\fP low resolution limit\&. 
.br
\fIshift_limit\fP limit on extent of search for shift\&. 
.br
\fIedge_width\fP width of smoothing edge\&. 
.br
\fIgauss_width\fP decay coefficient for smoothing edge\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double average shift\&. 
.PP
.nf
The images are first aligned using a progressive algorith starting with 
the indicated reference image.
The images are then aligned iteratively using the average image to 
improve the average.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 529 of file Bimage_align\&.cpp\&.
.SS "\fBBimage\fP * Bimage::align_progressive (long nref, \fBBimage\fP * pmask, double hi_res, double lo_res, double shift_limit, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Aligns and sums a set of sub-images using a progressive algorithm\&. 
.PP
\fBParameters\fP
.RS 4
\fInref\fP reference sub-image\&. 
.br
\fI*pmask\fP cross-correlation mask\&. 
.br
\fIhi_res\fP high resolution limit\&. 
.br
\fIlo_res\fP low resolution limit\&. 
.br
\fIshift_limit\fP limit on extent of search for shift\&. 
.br
\fIplanf\fP plan for forward Fourier transform\&. 
.br
\fIplanb\fP plan for backward Fourier transform\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* summed reference image\&. 
.PP
.nf
The images are aligned against the reference images with progressive
addition to reference to decrease noise.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 30 of file Bimage_align\&.cpp\&.
.SS "\fBBimage\fP * Bimage::align_progressive_fast (long nref, double shift_limit)"

.PP
Aligns and sums a set of sub-images using a progressive algorithm\&. 
.PP
\fBParameters\fP
.RS 4
\fInref\fP reference sub-image\&. 
.br
\fIshift_limit\fP limit on extent of search for shift\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* summed reference image\&. 
.PP
.nf
The images are aligned against the reference images with progressive
addition to reference to decrease noise.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 140 of file Bimage_align\&.cpp\&.
.SS "long Bimage::alloc_size () const\fC [inline]\fP"

.PP
Definition at line 262 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::aniso_average (long ksize, double w)"

.PP
Calculates an anisotropic average within a kernel based on the local gradient\&. 
.PP
\fBParameters\fP
.RS 4
\fIksize\fP kernel radius\&. 
.br
\fIw\fP gradient weight (0 reverts to isotropic)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new image\&. 
.RE
.PP

.PP
Definition at line 1352 of file Bimage_filter\&.cpp\&.
.SS "long Bimage::apply_soft_mask (long nn, \fBBimage\fP * pmask, int fill_type, double fill)"

.PP
Applies a soft mask to a sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fIpmask\fP soft mask: [0,1]\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP value of edge voxels\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is multiplied with the mask, filling in the remainder 
with the fill value.
Requirement: The mask must range from 0 to 1.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2557 of file Bimage_mask\&.cpp\&.
.SS "int Bimage::assemble_tiles (\fBBimage\fP * pt, int flag = \fC0\fP)"

.PP
Assembles overlapping tiles into this image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pt\fP multi-image containing tiles\&. 
.br
\fIflag\fP flag to set overlap handling\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The origin in each tile specifies the starting location.
Where tiles overlap, the integration is determined by the flag:
0 = simple addition with averaging afterwards.
1 = a gradual transition from one tile to the other.
2 = place just the central part of each tile.
The original data in the image is overwritten.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 433 of file Bimage_combine\&.cpp\&.
.SS "int Bimage::auto_correlate (double hires, double lores)"

.PP
Calculates an autocorrelation map by Fast Fourier transformation\&. 
.PP
\fBParameters\fP
.RS 4
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
FFTW library (www.fftw.org).
A multi-image 1D, 2D and 3D data set is transformed forward, the 
transform multiplied by its complex conjugate, followed by backward 
transformation and rescaling by 1/(N*N). Data beyond the resolution 
set in the image structure are zeroed. Therefore the correct setting 
of units and resolution in the image are required. Defaults for the 
units are usually 1 Angstrom/voxel and a zero resolution would
include the whole image (i.e., no resolution limitation).
The resultant image is Float.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 265 of file Bimage_correlate\&.cpp\&.
.SS "double Bimage::average ()\fC [inline]\fP"

.PP
Definition at line 546 of file Bimage\&.h\&.
.SS "void Bimage::average (double d)\fC [inline]\fP"

.PP
Definition at line 551 of file Bimage\&.h\&.
.SS "double Bimage::average (long cc, double xf, double yf, double zf, long nn, double iscale)"

.PP
Averages in 3D when scaling is less than 1\&. 
.PP
\fBParameters\fP
.RS 4
\fIcc\fP channel\&. 
.br
\fIxf\fP x location\&. 
.br
\fIyf\fP y location\&. 
.br
\fIzf\fP z location\&. 
.br
\fInn\fP image number\&. 
.br
\fIiscale\fP inverse scale\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double average\&. 
.PP
.nf
All neighboring voxels in x, y and z are averaged and result returned.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1380 of file Bimage\&.cpp\&.
.SS "double Bimage::average2D (long cc, double xf, double yf, double zf, long nn, double iscale)"

.PP
Averages in the xy plane when scaling is less than 1\&. 
.PP
\fBParameters\fP
.RS 4
\fIcc\fP channel\&. 
.br
\fIxf\fP x location\&. 
.br
\fIyf\fP y location\&. 
.br
\fIzf\fP z location\&. 
.br
\fInn\fP image number\&. 
.br
\fIiscale\fP inverse scale\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double average\&. 
.PP
.nf
All neighboring voxels in x and y are averaged and result returned.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1343 of file Bimage\&.cpp\&.
.SS "void Bimage::average_images ()\fC [inline]\fP"

.PP
Definition at line 735 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::average_images (bool sd)"

.PP
Averages all sub-images and optionally calculates standard deviation image\&. 
.PP
\fBParameters\fP
.RS 4
\fIsd\fP flag to calculate linked standard deviation image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* average image\&. 
.RE
.PP

.PP
Definition at line 3533 of file Bimage\&.cpp\&.
.SS "double Bimage::average_phase_difference (\fBBimage\fP * p, double res_hi, double res_lo, int weighting = \fC1\fP)"

.PP
Calculates the average of the absolute phase difference between two images within given resolution shells\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP real space reference image\&. 
.br
\fIres_hi\fP upper resolution limit\&. 
.br
\fIres_lo\fP lower resolution limit\&. 
.br
\fIweighting\fP weighting type: 0, none; 1, p1-amp; 2, p2-amp; 3, both amps 
.RE
.PP
\fBReturns\fP
.RS 4
double average of the cosine of the phase difference\&. 
.PP
.nf
Both images are Fourier transformed and the absolute phase
difference calculated and averaged.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2201 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::back_project (\fBBimage\fP * p, double resolution, double axis, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Definition at line 437 of file Bimage_project\&.cpp\&.
.SS "void Bimage::background (double bkg)\fC [inline]\fP"

.PP
Definition at line 559 of file Bimage\&.h\&.
.SS "double Bimage::background (long nn)\fC [inline]\fP"

.PP
Definition at line 553 of file Bimage\&.h\&.
.SS "void Bimage::background (long nn, double bkg)\fC [inline]\fP"

.PP
Definition at line 556 of file Bimage\&.h\&.
.SS "int Bimage::bar (long nn, \fBVector3\fP< double > start, \fBVector3\fP< double > end, double width, double edge_width, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Generates a bar between start and end points\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fIstart\fP start of bar\&. 
.br
\fIend\fP end of bar\&. 
.br
\fIwidth\fP width of bar\&. 
.br
\fIedge_width\fP bar edge width\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
A bar is generated with the given fill value from the start point
to the end point and with a defined width and gaussian edge.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 829 of file Bimage_edit\&.cpp\&.
.SS "int Bimage::bar (\fBVector3\fP< double > start, \fBVector3\fP< double > end, double width, double edge_width, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Generates a bar between start and end points\&. 
.PP
\fBParameters\fP
.RS 4
\fIstart\fP start of bar\&. 
.br
\fIend\fP end of bar\&. 
.br
\fIwidth\fP width of bar\&. 
.br
\fIedge_width\fP bar edge width\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
A bar is generated with the given fill value from the start point
to the end point and with a defined width and gaussian edge.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 803 of file Bimage_edit\&.cpp\&.
.SS "int Bimage::bin (long b)\fC [inline]\fP"

.PP
Definition at line 1346 of file Bimage\&.h\&.
.SS "int Bimage::bin (\fBVector3\fP< long > bk)"

.PP
Bins by an integer size in place\&. 
.PP
\fBParameters\fP
.RS 4
\fIbk\fP 3-value vector of integer bin factors\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
An image is binned by an integer size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 232 of file Bimage_bin\&.cpp\&.
.SS "\fBBimage\fP * Bimage::bin_around_origin (int bin)"

.PP
Bins by an integer size making sure the origin falls on a binned voxel, and returns a new image\&. 
.PP
\fBParameters\fP
.RS 4
\fIbin\fP integer bin factor\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new image\&. 
.PP
.nf
An image is binned by an integer size, square in 2D and cubic in 3D.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 332 of file Bimage_bin\&.cpp\&.
.SS "\fBBimage\fP* Bimage::bin_copy (long b)\fC [inline]\fP"

.PP
Definition at line 1351 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::bin_copy (\fBVector3\fP< long > bk)"

.PP
Bins by an integer size and returns a new image\&. 
.PP
\fBParameters\fP
.RS 4
\fIbk\fP 3-value vector of integer bin factors\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new image\&. 
.PP
.nf
An image is binned by an integer size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 268 of file Bimage_bin\&.cpp\&.
.SS "\fBBimage\fP * Bimage::blend (\fBBimage\fP * p, long number)"

.PP
Blends the two images, creating a new set of sub-images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.br
\fInumber\fP number of images in the series\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new image structure, NULL if error\&. 
.PP
.nf
A number of images are created by blending the two input images in
different ratios. The input images become the first and last sub-images of 
the new image structure, with the intermediate images changing over from
the first to the last:
        new_data = (1-fraction)*data1 + fraction*data2
where fraction = index/(number - 1)
At least 3 new sub-images are packed into the new image. 
All of the header information in the first image is copied into the new image.
Both images are converted to floating point.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 106 of file Bimage_combine\&.cpp\&.
.SS "long Bimage::blobs (double threshold, double min_size, double max_size, double setvalue, int sign)"

.PP
Identifies contiguous regions above a given threshold (blobs) and eliminate those less than a minimum size\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP threshold to define contiguous regions\&. 
.br
\fImin_size\fP minimum number of voxels to keep a region\&. 
.br
\fImax_size\fP maximum number of voxels to keep a region\&. 
.br
\fIsetvalue\fP value to assign to deleted regions (typically set to threshold)\&. 
.br
\fIsign\fP sign controlling direction of thresholding\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of voxels set to threshold\&. 
.PP
.nf
All contiguous regions in an image are indexed and their sizes 
calculated. Whether a region is contiguous is defined by a
threshold. Regions smaller than a minimum number of voxels are
set to the threshold value. The input image is modified and
left as a floating point image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 568 of file Bimage_segment\&.cpp\&.
.SS "int Bimage::calculate_background (\fBBimage\fP * pmask, int flag = \fC0\fP)"

.PP
Calculates the background for each sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP foreground mask\&. 
.br
\fIflag\fP flag to specify where to calculate the background: [0,1] 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
If the mask is specified, it is used to define the part of the 
image to be used for background calculation (where the mask is zero).

.fi
.PP
 
.RE
.PP

.PP
Definition at line 168 of file Bimage_background\&.cpp\&.
.SS "int Bimage::calculate_background (\fBBimage\fP * pmask, long nn, int flag = \fC0\fP)"

.PP
Calculates the background for one sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP foreground mask\&. 
.br
\fInn\fP sub-image\&. 
.br
\fIflag\fP flag to specify where to calculate the background: [0,1] 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
If the mask is specified, it is used to define the part of the 
image to be used for background calculation (where the mask is zero).

.fi
.PP
 
.RE
.PP

.PP
Definition at line 124 of file Bimage_background\&.cpp\&.
.SS "int Bimage::calculate_background (int flag = \fC0\fP)"

.PP
Calculates the background for each sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fIflag\fP flag to specify where to calculate the background: [0,3] 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
The background is taken as the average of the values outside the
circle or sphere enclosed by the image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 91 of file Bimage_background\&.cpp\&.
.SS "int Bimage::calculate_background (long nn, int flag)"

.PP
Calculates the background for one sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fIflag\fP flag to specify where to calculate the background: [0,3] 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
The background is taken as the average of the values for:
flag=0,1    outside the circle or sphere enclosed by the image
flag=2      inside the circle or sphere enclosed by the image
flag=3      inside the half-radius circle in the center of the image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 27 of file Bimage_background\&.cpp\&.
.SS "\fBBimage\fP * Bimage::cartesian_to_cylindrical (long nannuli, long nphi, int flag = \fC0\fP)"

.PP
Calculates an image with cylindrical coordinates\&. 
.PP
\fBParameters\fP
.RS 4
\fInannuli\fP number of annuli\&. 
.br
\fInphi\fP number of phi angles\&. 
.br
\fIflag\fP switch: annulus-angle-z (0), angle-annulus-z (1), z-annulus-angle (2) 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* cylindrical image\&. 
.PP
.nf
The image is converted to cylindrical form with a specified number of 
annuli and angles. 
A point vector p = {x,y,z} with respect to the image origin (typically
the center of the image) is converted to cylindrical coordinates as follows:
    The distance from the z-origin gives the annulus:
        |p| = sqrt(x*x+y*y)
    Phi is the rotation angle around the z-axis, starting at the x-axis:
        phi = atan(y/x)
    The z-coordinate remains unchanged.
The new dimensions are mapped as follows with their maximum ranges:
    |p|   ===> x_dimension (0 - max(x_size,y_size,z_size)
    phi   ===> y_dimension (0 - 2*PI)
    z     ===> z_dimension
The sampling within these ranges are given by the calling function.
The sampling must be isotropic.
The origins within the sub-image structures are used.
The interpolation routine actually calculates the old cartesian 
coordinates for each set of cylindrical coordinates.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 589 of file Bimage_polar\&.cpp\&.
.SS "\fBBimage\fP * Bimage::cartesian_to_spherical (long nannuli, long nphi, long ntheta)"

.PP
Calculates an image with spherical coordinates\&. 
.PP
\fBParameters\fP
.RS 4
\fInannuli\fP number of annuli\&. 
.br
\fInphi\fP number of phi angles\&. 
.br
\fIntheta\fP number of theta angles\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* spherical image\&. 
.PP
.nf
The image is converted to polar form with a specified number of annuli
and angles in one (a 2D image) or two (a 3D map) directions. The 
angular convention is consistent with the Euler angles used for 3D
image processing. 
A point vector p = {x,y,z} with respect to the image origin (typically
the center of the image) is converted to polar coordinates as follows:
    The size of the vector gives the annulus:
        |p| = sqrt(x*x+y*y+z*z)
    Phi is the rotation angle around the z-axis, starting at the x-axis:
        phi = atan(y/x)
    Theta is the angle between the positive z-axis and the point vector:
        theta = acos(z/|p|)
The new dimensions are mapped as follows with their maximum ranges:
    |p|   ===> x_dimension (0 - max(x_size,y_size,z_size)
    phi   ===> y_dimension (0 - 2*PI)
    theta ===> z_dimension (0 - PI)
The sampling within these ranges are given by the calling function.
The sampling must be isotropic.
The origins within the sub-image structures are used.
The interpolation routine actually calculates the old cartesian 
coordinates for each set of spherical coordinates.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 498 of file Bimage_polar\&.cpp\&.
.SS "void Bimage::catenate (long m, \fBBimage\fP ** p)"

.PP
Catenates an array of images of the same size into a multi-image structure\&. 
.PP
\fBParameters\fP
.RS 4
\fIm\fP number of images in the array\&. 
.br
\fI**p\fP array of images\&. 
.PP
.nf
The images must all have the same dimensions.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 52 of file Bimage_combine\&.cpp\&.
.SS "double Bimage::ccmap_confidence (long nn)"

.PP
Calculates a confidence level to associate with a cross-correlation peak\&. 
.PP
\fBAuthor\fP
.RS 4
Bernard Heymann and Xiange Zheng 
.RE
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double P value\&. 
.PP
.nf
The highest two peak maxima are found and used to calculate a
confidence level for the hypothesis that the second highest peak is
different from the first. The two maxima are found by a kernel search
which implicitly assumes that the values associated with a peak
monotonically decays with distance from the peak.
Fisher's z-transform is used to calculate the confidence level:
    P = erfc((zmax - zmax2)/(2*z_sigma))
where
    zmax, zmax2: z-transforms of the highest two peaks.
    z_sigma: standard deviation of the z-transform of the cc map.
The P value is returned

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1952 of file Bimage_correlate\&.cpp\&.
.SS "int Bimage::center (int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Centers an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIfill_type\fP fill type for filling empty regions\&. 
.br
\fIfill\fP value to fill in empty regions\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.RE
.PP

.PP
Definition at line 694 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::center_wrap ()"

.PP
Centers an image with wrapping\&. 
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.RE
.PP

.PP
Definition at line 708 of file Bimage_transform\&.cpp\&.
.SS "\fBBimage\fP * Bimage::central_section (\fBMatrix3\fP mat, double resolution, \fBFSI_Kernel\fP * kernel)"

.PP
Calculates a central section of a 3D fourier transform\&. 
.PP
\fBParameters\fP
.RS 4
\fImat\fP 3x3 rotation or skewing matrix\&. 
.br
\fIresolution\fP high resolution limit\&. 
.br
\fI*kernel\fP frequency space interpolation kernel\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new 2D central section\&. 
.PP
.nf
The orientation of the central section is defined by a rotation matrix
and the interpolation is done with a reciprocal space kernel.
The rotation origin is obtained from the map origin.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 287 of file Bimage_project\&.cpp\&.
.SS "int Bimage::change_symmetry (\fBBsymmetry\fP & symold, \fBBsymmetry\fP & symnu, double radius, double z_slope)"

.PP
Changes the symmetry order for cyclic and dihedral maps\&. 
.PP
\fBParameters\fP
.RS 4
\fI*symold\fP original symmetry\&. 
.br
\fI*symnu\fP new symmetry\&. 
.br
\fIradius\fP radius in voxels of repeating units\&. 
.br
\fIz_slope\fP slope along z to adjust radius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
If the radius is zero, the change in symmetry is done with proportional
shifts that distorts the units in the map.
If the radius is positive, it is used to determine the radial shift for
each unit, giving much less distortion than the proportional shifts.
Variation of the radius of the specimen along z can be handled with
a non-zero z slope parameter.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 585 of file Bimage_symmetry\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::change_transform_size (\fBVector3\fP< long > nusize)"

.PP
Resizes a 'standard' transform\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP new image size\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBVector3<double>\fP scale\&. 
.PP
.nf
A standard transform is resized by inserting or removing
rows or columns in the middle of the data set.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 248 of file Bimage_fft\&.cpp\&.
.SS "void Bimage::change_type (char * string)"

.PP
Get the data type from a string\&. 
.PP
\fBParameters\fP
.RS 4
\fI*string\fP string describing the data type\&. 
.RE
.PP

.PP
Definition at line 1805 of file Bimage\&.cpp\&.
.SS "void Bimage::change_type (char letter)"

.PP
Get the data type indicated by a single letter code\&. 
.PP
\fBParameters\fP
.RS 4
\fIletter\fP letter indicating data type\&. 
.PP
.nf
This function is used in optional command-line arguments to indicate 
a new data type for an image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1775 of file Bimage\&.cpp\&.
.SS "void Bimage::change_type (\fBDataType\fP nutype)"

.PP
Change the data to the new type\&. 
.PP
\fBParameters\fP
.RS 4
\fInutype\fP new data type\&. 
.RE
.PP

.PP
Definition at line 1840 of file Bimage\&.cpp\&.
.SS "long Bimage::channels ()\fC [inline]\fP"

.PP
Definition at line 379 of file Bimage\&.h\&.
.SS "void Bimage::channels (long cc)\fC [inline]\fP"

.PP
Definition at line 380 of file Bimage\&.h\&.
.SS "int Bimage::channels_to_images ()"

.SS "void Bimage::check ()"

.PP
Checks an image for reasonable properties\&. 
.PP
Definition at line 430 of file Bimage\&.cpp\&.
.SS "bool Bimage::check_compoundtype (long nc, \fBCompoundType\fP ct)"

.PP
Definition at line 335 of file Bimage\&.cpp\&.
.SS "bool Bimage::check_if_same_image_size (\fBBimage\fP * p)"

.PP
Check if two images are the same size\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP image to check\&. 
.RE
.PP
\fBReturns\fP
.RS 4
bool 1 if yes, 0 if no\&. 
.PP
.nf
The function returns the answer and leaves the calling function to 
deal with the result.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 603 of file Bimage\&.cpp\&.
.SS "bool Bimage::check_if_same_size (\fBBimage\fP * p)"

.PP
Check if two images are the same size\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP image to check\&. 
.RE
.PP
\fBReturns\fP
.RS 4
bool 1 if yes, 0 if no\&. 
.PP
.nf
The function returns the answer and leaves the calling function to 
deal with the result.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 577 of file Bimage\&.cpp\&.
.SS "long Bimage::check_neighbors (long idx)"

.PP
Check neighbors in region map and assign a value if a neighbor is assigned\&. 
.PP
\fBParameters\fP
.RS 4
\fIidx\fP index in multi-image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long new value assigned\&. 
.RE
.PP

.PP
Definition at line 387 of file Bimage_segment\&.cpp\&.
.SS "double Bimage::check_point_group (\fBBstring\fP & check_string)"

.PP
Checks for the requested symmetries\&. 
.PP
\fBParameters\fP
.RS 4
\fI&check_string\fP string with requested point groups\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double symmetry correlation coefficient\&. 
.PP
.nf
Requirement: The input map must be in standard orientation for the symmetry.
For each different symmetry operation, the map is rotated and compared by
real space correlation to the original. 

.fi
.PP
 
.RE
.PP

.PP
Definition at line 112 of file Bimage_symmetry\&.cpp\&.
.SS "void Bimage::check_resolution (double & resolution)"

.PP
Checks that the resolution falls within reasonable limits\&. 
.PP
\fBParameters\fP
.RS 4
\fI&resolution\fP resolution (modified)\&. 
.PP
.nf
The resolution is set to between half the real size and the Nyquist frequency.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 646 of file Bimage\&.cpp\&.
.SS "void Bimage::check_sampling ()"

.PP
Checks that the sampling is properly specified\&. 
.PP
.nf
If the sampling is zero or less it is set to 1.
If a dimension size is one, the sampling is set to 1.

.fi
.PP
 
.PP
Definition at line 627 of file Bimage\&.cpp\&.
.SS "int Bimage::chirp (double freq_scale, double freq_shift = \fC0\fP)"

.PP
Generates a chirp image\&. 
.PP
\fBParameters\fP
.RS 4
\fIfreq_scale\fP frequency scale\&. 
.br
\fIfreq_shift\fP frequency shift (radians)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 923 of file Bimage_edit\&.cpp\&.
.SS "void Bimage::clear ()\fC [inline]\fP"

.PP
Definition at line 716 of file Bimage\&.h\&.
.SS "\fBCMYK\fP< double > Bimage::cmyk (long j)"

.PP
Returns a color value at the given index\&. 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.RE
.PP
\fBReturns\fP
.RS 4
CMYK<double> the color value\&. 
.PP
.nf
The index refers to compound values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1092 of file Bimage\&.cpp\&.
.SS "void Bimage::cmyk_to_rgb ()"

.PP
Converts a \fBCMYK\fP color image to \fBRGB\fP\&. 
.PP
Definition at line 206 of file Bimage_color\&.cpp\&.
.SS "int Bimage::color_blue (double cmin, double cmax, int flag = \fC0\fP)"

.PP
Converts a gray-scale image to blue\&. 
.PP
\fBParameters\fP
.RS 4
\fIcmin\fP lower grayscale boundary\&. 
.br
\fIcmax\fP upper grayscale boundary\&. 
.br
\fIflag\fP sets the type of conversion 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
A grayscale image is converted to blue between the given minimum and maximum.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 337 of file Bimage_color\&.cpp\&.
.SS "int Bimage::color_combine (\fBBimage\fP * p)"

.PP
Combines two colored images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
Each pair of voxels is summed and the result truncated to 255.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 382 of file Bimage_color\&.cpp\&.
.SS "int Bimage::color_green (double cmin, double cmax, int flag = \fC0\fP)"

.PP
Converts a gray-scale image to green\&. 
.PP
\fBParameters\fP
.RS 4
\fIcmin\fP lower grayscale boundary\&. 
.br
\fIcmax\fP upper grayscale boundary\&. 
.br
\fIflag\fP sets the type of conversion 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
A grayscale image is converted to green between the given minimum and maximum.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 322 of file Bimage_color\&.cpp\&.
.SS "int Bimage::color_red (double cmin, double cmax, int flag = \fC0\fP)"

.PP
Converts a gray-scale image to red\&. 
.PP
\fBParameters\fP
.RS 4
\fIcmin\fP lower grayscale boundary\&. 
.br
\fIcmax\fP upper grayscale boundary\&. 
.br
\fIflag\fP sets the type of conversion 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
A grayscale image is converted to red between the given minimum and maximum.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 307 of file Bimage_color\&.cpp\&.
.SS "\fBBimage\fP * Bimage::color_spectrum (double cmin, double cmax)"

.PP
Colorizes an image to a spectrum\&. 
.PP
\fBParameters\fP
.RS 4
\fIcmin\fP lower grayscale boundary\&. 
.br
\fIcmax\fP upper grayscale boundary\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* color scale image\&. 
.PP
.nf
A grayscale image is converted to RGB and colored from blue (low) to 
red (high). Only the values between the given minimum and maximum is used.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 415 of file Bimage_color\&.cpp\&.
.SS "void Bimage::color_to_simple ()"

.PP
A color image is converted to a simple image\&. 
.PP
.nf
The new value for each voxel is the average of the RGB color values.

.fi
.PP
 
.PP
Definition at line 94 of file Bimage_color\&.cpp\&.
.SS "void Bimage::combine_channels (long nc, \fBCompoundType\fP ct = \fC\fBTSimple\fP\fP)"

.PP
Combines images as channels\&. 
.PP
\fBParameters\fP
.RS 4
\fInc\fP number of channels to create\&. 
.br
\fIct\fP compound type\&. 
.PP
.nf
The input image is replaced with a new image.
If the compound type is single value, the compound type
is inferred from the number of channels.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2020 of file Bimage\&.cpp\&.
.SS "int Bimage::combined_complex_product ()"

.PP
Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images\&. 
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Requirement: Fourier transform of two images packed into one complex
    data block with the function Bimage::pack_two_in_complex and then
    transformed with the function Bimage::fft.
The Friedel relationships in transforms from real space images are
exploited to transform two images simultaneously and then extract
the individual transforms from the complex data set.
This function extracts the individual transforms and calculates the 
complex conjugate product used in cross-correlation.
The result is scaled by the total power of the two transforms, yielding 
the correlation coefficient when the product is backtransformed into 
the cross-correlation map.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 878 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::combined_complex_product (\fBBimage\fP * pmask)"

.PP
Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP binary mask (only 0 and 1), NULL if not desired\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Requirement: Fourier transform of two images packed into one complex
    data block with the function Bimage::pack_two_in_complex and then
    transformed with the function Bimage::fft.
The Friedel relationships in transforms from real space images are
exploited to transform two images simultaneously and then extract
the individual transforms from the complex data set.
This function extracts the individual transforms and calculates the 
complex conjugate product used in cross-correlation.
The result is scaled by the total power of the two transforms, yielding 
the correlation coefficient when the product is backtransformed into 
the cross-correlation map.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 966 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::combined_complex_product (double hires, double lores)"

.PP
Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images\&. 
.PP
\fBParameters\fP
.RS 4
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Requirement: Fourier transform of two images packed into one complex
    data block with the function Bimage::pack_two_in_complex and then
    transformed with the function Bimage::fft.
The Friedel relationships in transforms from real space images are
exploited to transform two images simultaneously and then extract
the individual transforms from the complex data set.
This function extracts the individual transforms and calculates the 
complex conjugate product used in cross-correlation.
The result is scaled by the total power of the two transforms within
the resolution limits, yielding the correlation coefficient when
the product is backtransformed into the cross-correlation map.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 991 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::combined_complex_product (double hires, double lores, \fBBimage\fP * pmask)"

.PP
Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images\&. 
.PP
\fBParameters\fP
.RS 4
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fI*pmask\fP binary mask (only 0 and 1), NULL if not desired\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Requirement: Fourier transform of two images packed into one complex
    data block with the function Bimage::pack_two_in_complex and then
    transformed with the function Bimage::fft.
The Friedel relationships in transforms from real space images are
exploited to transform two images simultaneously and then extract
the individual transforms from the complex data set.
This function extracts the individual transforms and calculates the 
complex conjugate product used in cross-correlation.
The result is scaled by the total power of the two transforms within
the resolution limits, yielding the correlation coefficient when
the product is backtransformed into the cross-correlation map.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1016 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::combined_complex_product_implicit_mask (double hires, double lores)"

.PP
Calculates the complex conjugate product of a complex image resulting from combining and Fourier transforming two real space images\&. 
.PP
\fBParameters\fP
.RS 4
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Requirement: Fourier transform of two images packed into one complex
    data block with the function Bimage::pack_two_in_complex and then
    transformed with the function Bimage::fft.
The Friedel relationships in transforms from real space images are
exploited to transform two images simultaneously and then extract
the individual transforms from the complex data set.
This function extracts the individual transforms and calculates the 
complex conjugate product used in cross-correlation.
An implicit mask is assumed: Only non-zero values in both transforms are considered.
The result is scaled by the total power of the two transforms within
the resolution limits, yielding the correlation coefficient when
the product is backtransformed into the cross-correlation map.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1155 of file Bimage_complex\&.cpp\&.
.SS "bool Bimage::compatible (\fBBimage\fP * p)"

.PP
Check if this image has the same number of channels and data type as another\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP reference image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
bool 1 if yes, 0 if no\&. 
.PP
.nf
The function returns the answer and leaves the calling function to 
deal with the result.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 664 of file Bimage\&.cpp\&.
.SS "\fBComplex\fP< double > Bimage::complex (long j)"

.PP
Returns a complex value at the given index\&. 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Complex<double> the complex floating point value\&. 
.PP
.nf
The index refers to compound values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1036 of file Bimage\&.cpp\&.
.SS "int Bimage::complex_apply_dual_mask (\fBBimage\fP * pmask)"

.PP
Applies a dual mask to a complex image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP mask (converted to floating point)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
The mask is applied to an image, generating two images, the first 
with values retained where the mask is positive, and the second with
values where the mask is negative.
The input image is replaced and the second is created and linked to
the first.
Requirement: The two input images must be the same size.
No statistics are calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 646 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::complex_apply_mask (\fBBimage\fP * pmask)"

.PP
Applies a mask to a complex image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP mask (converted to floating point)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Wherever the mask is <= 0, the data is set to zero.
Requirement: The two images must be the same size.
No statistics are calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 586 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::complex_apply_negative_mask (\fBBimage\fP * pmask)"

.PP
Applies a negative mask to a complex image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP mask (converted to floating point)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Wherever the mask is >= 0, the data is set to zero.
Requirement: The two images must be the same size.
No statistics are calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 615 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::complex_bandpass (double hires, double lores)"

.PP
Bandpasses a Fourier transform\&. 
.PP
\fBParameters\fP
.RS 4
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Requirement: a complex Fourier transform.
All data outside the band limits are set to zero.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 680 of file Bimage_complex\&.cpp\&.
.SS "void Bimage::complex_conjugate ()"

.PP
Calculates the complex conjugate image\&. 
.PP
Definition at line 230 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::complex_conjugate_product (\fBBimage\fP * p)"

.PP
Calculates the product of a complex image with the conjugate of a second\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP complex image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Complex conjugate product:
    (a + ib)*(c - id) = (a*c + b*d) + i(b*c - a*d).
Requirement: The two images must be the same size.
No statistics are calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 507 of file Bimage_complex\&.cpp\&.
.SS "\fBBimage\fP * Bimage::complex_conjugate_product_one2many (\fBBimage\fP * p)"

.PP
Calculates the product of a complex image with the conjugate of a second\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP complex image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Complex conjugate product:
    (a + ib)*(c - id) = (a*c + b*d) + i(b*c - a*d).
Requirement: The two images must be the same size.
No statistics are calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 555 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::complex_multiply (\fBBimage\fP * p)"

.PP
Calculates the product of a complex image with a simple image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP simple image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Requirement: The two images must be the same size.
No statistics are calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 447 of file Bimage_complex\&.cpp\&.
.SS "double Bimage::complex_normalize ()"

.PP
Normalizes the power in a complex image\&. 
.PP
\fBReturns\fP
.RS 4
double power\&. 
.PP
.nf
The first element is set to zero.
The image is scaled by the remaining total power, i.e., the sum of the intensities.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 272 of file Bimage_complex\&.cpp\&.
.SS "double Bimage::complex_power ()"

.PP
Calculates the power in a complex image\&. 
.PP
\fBReturns\fP
.RS 4
double power\&. 
.PP
.nf
The first element is set to zero.
The image is scaled by the remaining total power, i.e., the sum of the intensities.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 247 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::complex_product (\fBBimage\fP * p)"

.PP
Calculates the complex product of two complex images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP complex image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Complex product:
    (a + ib)*(c + id) = (a*c - b*d) + i(b*c + a*d).
Requirement: The two images must be the same size.
No statistics are calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 477 of file Bimage_complex\&.cpp\&.
.SS "void Bimage::complex_to_amplitudes ()"

.PP
The amplitudes from a complex image is written to a simple image\&. 
.PP
Definition at line 161 of file Bimage_complex\&.cpp\&.
.SS "void Bimage::complex_to_imaginary ()"

.PP
The imaginary part of a complex image is written to a simple image\&. 
.PP
Definition at line 118 of file Bimage_complex\&.cpp\&.
.SS "void Bimage::complex_to_intensities ()"

.PP
The intensities from a complex image is written to a simple image\&. 
.PP
Definition at line 139 of file Bimage_complex\&.cpp\&.
.SS "void Bimage::complex_to_phases ()"

.PP
The phases from a complex image is written to a simple image\&. 
.PP
Definition at line 208 of file Bimage_complex\&.cpp\&.
.SS "void Bimage::complex_to_real ()"

.PP
The real part of a complex image is written to a simple image\&. 
.PP
Definition at line 97 of file Bimage_complex\&.cpp\&.
.SS "void Bimage::complex_to_signed_amplitudes ()"

.PP
The signed amplitudes from a complex image is written to a simple image\&. 
.PP
Definition at line 183 of file Bimage_complex\&.cpp\&.
.SS "\fBCompoundType\fP Bimage::compound_type ()\fC [inline]\fP"

.PP
Definition at line 359 of file Bimage\&.h\&.
.SS "long Bimage::compound_type (\fBCompoundType\fP ct)"

.PP
Definition at line 351 of file Bimage\&.cpp\&.
.SS "long Bimage::compound_type_size ()\fC [inline]\fP"

.PP
Definition at line 363 of file Bimage\&.h\&.
.SS "\fBBstring\fP Bimage::compound_type_string ()"

.PP
Get the string representation of a datatype\&. 
.PP
\fBReturns\fP
.RS 4
\fBBstring\fP string representation of a datatype\&. 
.RE
.PP

.PP
Definition at line 1724 of file Bimage\&.cpp\&.
.SS "double Bimage::convert_to_helix (double helix_rise, double helix_angle, \fBVector3\fP< double > offset)"

.PP
Converts a map to a helix\&. 
.PP
\fBParameters\fP
.RS 4
\fIhelix_rise\fP rise per asymmetric unit 
.br
\fIhelix_angle\fP rotation angle per asymmetric unit\&. 
.br
\fIoffset\fP offset in the xy plane\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double 0\&. 
.PP
.nf
The data is offset from the central axis based on helical parameters along the axis.
The data is rotated around the offset vector based on the helix rise 
and helix angle by an angle:
                  distance * (1 - cos(helix_angle))
    angle2 = atan ---------------------------------
                            helix_rise

.fi
.PP
 
.RE
.PP

.PP
Definition at line 721 of file Bimage_helix\&.cpp\&.
.SS "int Bimage::convolve (\fBBimage\fP * pkernel)"

.PP
Convolves an image with an arbitrary size convolution filter\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pkernel\fP kernel encoded as an image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
The kernel is multiplied with each area surrounding the current voxel
with wrapping to avoid image edge effects.
The convolution is threaded if compiled with OpenMP.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 592 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::convolve_chunk (\fBBimage\fP * pkernel, float * nudata, long i, long len)"

.PP
Definition at line 511 of file Bimage_filter\&.cpp\&.
.SS "\fBVector3\fP<long> Bimage::coordinates (long i)\fC [inline]\fP"

.PP
Definition at line 451 of file Bimage\&.h\&.
.SS "void Bimage::coordinates (long i, long & nc, long & nx, long & ny, long & nz, long & nn)\fC [inline]\fP"

.PP
Definition at line 440 of file Bimage\&.h\&.
.SS "void Bimage::coordinates (long i, long & nx, long & ny, long & nz)\fC [inline]\fP"

.PP
Definition at line 424 of file Bimage\&.h\&.
.SS "void Bimage::coordinates (long i, long & nx, long & ny, long & nz, long & nn)\fC [inline]\fP"

.PP
Definition at line 431 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::copy ()"

.PP
Copies the header information and data of an image into a new image structure\&. 
.PP
\fBReturns\fP
.RS 4
Bimage* copied image, NULL if copy failed\&. 
.RE
.PP

.PP
Definition at line 2766 of file Bimage\&.cpp\&.
.SS "\fBBimage\fP * Bimage::copy (long nu_nimg)"

.PP
Copies the header information and data of an image into a new image structure\&. 
.PP
\fBParameters\fP
.RS 4
\fInu_nimg\fP new number of images (if < 1, keep the old number) 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* copied image, NULL if copy failed\&. 
.RE
.PP

.PP
Definition at line 2792 of file Bimage\&.cpp\&.
.SS "\fBBimage\fP* Bimage::copy_header ()\fC [inline]\fP"

.PP
Definition at line 666 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::copy_header (long nu_nimg)"

.PP
Copy an image structure into a new one\&. 
.PP
\fBParameters\fP
.RS 4
\fInu_nimg\fP new number of images (if < 1, keep the old number) 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* the new image structure, NULL if copy failed\&. 
.PP
.nf
All information from an old image structure is copied into a new one.
This takes care of the internal arrays in the structure.
The data pointer is left to point to the original data.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2826 of file Bimage\&.cpp\&.
.SS "int Bimage::correct_background (\fBBimage\fP * pmask, int flag = \fC0\fP)"

.PP
Corrects the background for each sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP foreground mask\&. 
.br
\fIflag\fP flag to specify where to calculate the background: [0,3] 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The background is taken as the average of the values outside the
circle or sphere enclosed by the image.
If the mask is specified, it is used to define the foreground of the 
image. The correction then includes the area outside the circle or 
sphere as well as the area where the mask is zero.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 298 of file Bimage_background\&.cpp\&.
.SS "int Bimage::correct_background (int flag = \fC0\fP)"

.PP
Corrects the background for each sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fIflag\fP flag to specify where to calculate the background: [0,1] 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
The background is taken as the average of the values outside the
circle or sphere enclosed by the image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 260 of file Bimage_background\&.cpp\&.
.SS "int Bimage::correct_background (long nn, int flag)"

.PP
Corrects the background for one sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fIflag\fP flag to specify where to calculate the background: [0,3] 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
The background is taken as the average of the values outside the
circle or sphere enclosed by the image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 202 of file Bimage_background\&.cpp\&.
.SS "double Bimage::correlate (\fBBimage\fP * p)"

.PP
Calculates correlation coefficient between two images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP image to correlate with\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double correlation coefficient, -1 if not run\&. 
.PP
.nf
The correlation between two images is calculated and normalized as:
               sum((image1 - avg1)*(image2 - avg2))
    CC = -------------------------------------------------
         sqrt(sum(image1 - avg1)^2 * sum(image2 - avg2)^2)
.
Both images are converted to floating point.
Only the first image is used.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 36 of file Bimage_correlate\&.cpp\&.
.SS "double Bimage::correlate (\fBBimage\fP * p, double rmin, double rmax, \fBBimage\fP * pmask = \fCNULL\fP, int flag = \fC0\fP)"

.PP
Calculates a correlation coefficient between two images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.br
\fIrmin\fP minimum radius (pixel units)\&. 
.br
\fIrmax\fP maximum radius (pixel units)\&. 
.br
\fI*pmask\fP mask (can be NULL)\&. 
.br
\fIflag\fP flag to modify second image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double correlation coefficient, -1 if error\&. 
.PP
.nf
The correlation between two images is calculated and normalized as:
             sum((image1 - avg1)*(image2 - avg2))
    CC = -------------------------------------------------
         sqrt(sum(image1 - avg1)^2 * sum(image2 - avg2)^2)

.fi
.PP
 
.RE
.PP

.PP
Definition at line 90 of file Bimage_correlate\&.cpp\&.
.SS "double Bimage::correlate_annuli (\fBBimage\fP * polref, int ann_min, int ann_max, double ang_min, double ang_max, \fBfft_plan\fP planf, \fBfft_plan\fP planb, double & cc_max)"

.PP
Correlate annuli of a polar image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*polref\fP reference image polar power spectrum transform\&. 
.br
\fIann_min\fP low resolution cutoff (in inverse pixels)\&. 
.br
\fIann_max\fP high resolution cutoff (in inverse pixels)\&. 
.br
\fIang_min\fP minimum angle to test for (radians)\&. 
.br
\fIang_max\fP maximum angle to test for (radians)\&. 
.br
\fIplanf\fP FFT forward plan\&. 
.br
\fIplanb\fP FFT backward plan\&. 
.br
\fI&cc_max\fP pointer to correlation coefficient for return\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double angle\&. 
.PP
.nf
The input images must be transformed polar images, with each annulus
corresponding to a row in the image.
The polar image annuli between the given limits are cross-correlated
one by one, and a sum of all annuli calculated, weighted by annulus index.
The maximum value in the annulus sum corresponds to the best fit angle.
Both image and mirror image are assessed, yielding a negative angle
when the mirror image gives a larger correlation.
FFTW library (www.fftw.org).

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1187 of file Bimage_align\&.cpp\&.
.SS "double Bimage::correlation_coefficient (\fBVector3\fP< double > shift)"

.PP
Calculates a coefficient from a Fourier correlation transform given a shift\&. 
.PP
\fBParameters\fP
.RS 4
\fIshift\fP real space shift\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double correlation coefficient\&. 
.PP
.nf
The input image is a cross-correlation transform.
A brute force backtransform integration is done for the given shift to 
calculate the corresponding correlation coefficient.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 466 of file Bimage_correlate\&.cpp\&.
.SS "\fBBimage\fP* Bimage::cross_correlate (\fBBimage\fP * p, \fBBimage\fP * pmask = \fCNULL\fP)\fC [inline]\fP"

.PP
Definition at line 983 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::cross_correlate (\fBBimage\fP * p, double hires, double lores, \fBBimage\fP * pmask, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"
write_img('pccp\&.mrc', pc, 0);
.PP
Definition at line 599 of file Bimage_correlate\&.cpp\&.
.SS "\fBBimage\fP * Bimage::cross_correlate (\fBBimage\fP * p, double hires, double lores, \fBBimage\fP * pmask = \fCNULL\fP)"

.PP
Calculates a cross-correlation map by Fast Fourier transformation\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.br
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fI*pmask\fP binary mask (only 0 and 1), NULL if not desired\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* cross-correlation image\&. 
.PP
.nf
FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D real space data sets are 
packed into a complex data set and transformed forward. The transform
is unpacked before the first transform is multiplied with the complex 
conjugate of the second transform. This is then back-transformed to 
obtain the cross-correlation map in real space.
The low resolution limit can be 0, in which case no limits are applied.
The resultant cross-correlation image data type is floating point.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 417 of file Bimage_correlate\&.cpp\&.
.SS "\fBBimage\fP * Bimage::cross_correlate (\fBBimage\fP * p, double hires, double lores, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Calculates a cross-correlation map by Fast Fourier transformation\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.br
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fIplanf\fP forward transform plan\&. 
.br
\fIplanb\fP backward transform plan\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* cross-correlation image\&. 
.PP
.nf
FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D real space data sets are 
packed into a complex data set and transformed forward. The transform
is unpacked before the first transform is multiplied with the complex 
conjugate of the second transform. This is then back-transformed to 
obtain the cross-correlation map in real space.
Zero-valued data in the transforms are implicitly excluded.
The low resolution limit can be 0, in which case no limits are applied.
The resultant cross-correlation image data type is floating point.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 363 of file Bimage_correlate\&.cpp\&.
.SS "\fBBimage\fP * Bimage::cross_correlate_fspace (\fBBimage\fP * p, double hires, double lores, double shift_limit)"

.PP
Calculates a cross-correlation map by Fast Fourier transformation\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.br
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fIshift_limit\fP maximum real space shift\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* cross-correlation image\&. 
.PP
.nf
FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D real space data sets are 
packed into a complex data set and transformed forward. The transform
is unpacked before the first transform is multiplied with the complex 
conjugate of the second transform. This is then back-transformed to 
obtain the cross-correlation map in real space.
The low resolution limit can be 0, in which case no limits are applied.
The resultant cross-correlation image data type is floating point.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 561 of file Bimage_correlate\&.cpp\&.
.SS "\fBBimage\fP * Bimage::cross_correlate_two_way (\fBBimage\fP * p, double hires, double lores, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Calculates a cross-correlation map by Fast Fourier transformation\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.br
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fIplanf\fP FFT forward plan\&. 
.br
\fIplanb\fP FFT backward plan\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* cross-correlation image\&. 
.PP
.nf
FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D real space data sets are 
packed into a complex data set and transformed forward. The transform
is bandpass filtered to the given resolution limits and unpacked.
The two transforms are normalized, and multiplied in two ways:
    prod1 = data1 * data2.conjugate
    prod2 = data1 * data2
The second product represents a cross-correlation with a 180 degree 
rotation of the second image.
Both are back-transformed to obtain the two cross-correlation map in real space.
The one with the highest maximum is selected to return.
The resultant cross-correlation image data type is floating point.
The angle in the cross-correlation image is set to zero if the first
map is selected, otherwise it is set to PI.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 669 of file Bimage_correlate\&.cpp\&.
.SS "\fBBimage\fP * Bimage::cross_correlate_validate (\fBBimage\fP * p, \fBBimage\fP * pmask)"

.PP
Calculates a masked cross-correlation map by Fast Fourier transformation\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.br
\fI*pmask\fP binary mask (only 0 and 1), NULL if not desired\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* cross-correlation image\&. 
.PP
.nf
FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D real space data sets are 
packed into a complex data set and transformed forward. The transform
is unpacked and masked with mask image before the first transform is
multiplied with the complex conjugate of the second transform. This is 
then back-transformed to obtain the cross-correlation map in real space.
The mask must be composed of 0 and 1, and is converted to floating point.
The mask can be omitted (NULL).
The resultant cross-correlation image data type is floating point.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 750 of file Bimage_correlate\&.cpp\&.
.SS "int Bimage::cylinder (\fBVector3\fP< double > center, double radius, double height, double width, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Fills a cylinder within an image with a uniform value\&. 
.PP
\fBParameters\fP
.RS 4
\fIcenter\fP three vector center of cylinder\&. 
.br
\fIradius\fP cylinder radius\&. 
.br
\fIheight\fP cylinder heigth\&. 
.br
\fIwidth\fP gaussian width of smoothing function\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
All voxels within a cylinder at a given location are set to a given fill value.
The height is along the z-direction.
The new data replaces the old data.
The default center is {0,0,0}.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 539 of file Bimage_edit\&.cpp\&.
.SS "int Bimage::cylindrical_shells ()"

.PP
Calculates an image with slices representing cylindrical shell projections\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The 3D image is converted so that the sections contain 2D projections
of cylindrical shells. The projection in slice i is defined for:
    i >= sqrt(x^2 + y^2)
The first projection is placed at the z origin and radiates out into
both positive and negative directions.
Sampling in x and y is not changed.
The sampling must be isotropic.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 925 of file Bimage_polar\&.cpp\&.
.SS "unsigned char* Bimage::data_alloc ()\fC [inline]\fP"

.PP
Definition at line 266 of file Bimage\&.h\&.
.SS "unsigned char * Bimage::data_alloc (\fBDataType\fP type, \fBCompoundType\fP ctype, long nx, long ny, long nz, long nn)"

.PP
Allocate image data with size parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP data type\&. 
.br
\fIctype\fP compound type\&. 
.br
\fInx\fP x dimension\&. 
.br
\fIny\fP y dimension\&. 
.br
\fInz\fP z dimension\&. 
.br
\fInn\fP number of sub-images\&. 
.RE
.PP
\fBReturns\fP
.RS 4
unsigned char* pointer to data\&. 
.PP
.nf
The image parameters are set and a new data block allocated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 854 of file Bimage\&.cpp\&.
.SS "unsigned char * Bimage::data_alloc (long nbytes)"

.PP
Allocate image data\&. 
.PP
\fBParameters\fP
.RS 4
\fInbytes\fP number of bytes to allocate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
unsigned char* pointer to data\&. 
.PP
.nf
Any old data block is deleted.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 808 of file Bimage\&.cpp\&.
.SS "unsigned char* Bimage::data_alloc_and_clear ()\fC [inline]\fP"

.PP
Definition at line 267 of file Bimage\&.h\&.
.SS "unsigned char* Bimage::data_alloc_and_clear (\fBDataType\fP type, \fBCompoundType\fP ctype, long nx, long ny, long nz, long nn)\fC [inline]\fP"

.PP
Definition at line 272 of file Bimage\&.h\&.
.SS "unsigned char* Bimage::data_alloc_and_clear (long nbytes)\fC [inline]\fP"

.PP
Definition at line 269 of file Bimage\&.h\&.
.SS "unsigned char * Bimage::data_assign (unsigned char * nudata)"

.PP
Assign image data\&. 
.PP
\fBParameters\fP
.RS 4
\fI*nudata\fP allocated data pointer\&. 
.RE
.PP
\fBReturns\fP
.RS 4
unsigned char* pointer to data\&. 
.PP
.nf
Note: The size of the data block must correspond to the image dimensions!

.fi
.PP
 
.RE
.PP

.PP
Definition at line 884 of file Bimage\&.cpp\&.
.SS "void Bimage::data_delete ()"

.PP
Deallocates the image data\&. 
.PP
Definition at line 906 of file Bimage\&.cpp\&.
.SS "long Bimage::data_offset ()\fC [inline]\fP"

.PP
Definition at line 283 of file Bimage\&.h\&.
.SS "void Bimage::data_offset (long doff)\fC [inline]\fP"

.PP
Definition at line 284 of file Bimage\&.h\&.
.SS "unsigned char* Bimage::data_pointer ()\fC [inline]\fP"

.PP
Definition at line 279 of file Bimage\&.h\&.
.SS "unsigned char* Bimage::data_pointer (long offset)\fC [inline]\fP"

.PP
Definition at line 280 of file Bimage\&.h\&.
.SS "void Bimage::data_pointer (unsigned char * ptr)\fC [inline]\fP"

.PP
Definition at line 281 of file Bimage\&.h\&.
.SS "long Bimage::data_size ()\fC [inline]\fP"

.PP
Definition at line 265 of file Bimage\&.h\&.
.SS "\fBDataType\fP Bimage::data_type ()\fC [inline]\fP"

.PP
Definition at line 357 of file Bimage\&.h\&.
.SS "void Bimage::data_type (\fBDataType\fP dt)\fC [inline]\fP"

.PP
Definition at line 358 of file Bimage\&.h\&.
.SS "long Bimage::data_type_bits () const"

.PP
Returns the size of the datatype in bits\&. 
.PP
\fBReturns\fP
.RS 4
long data type size in bits\&. 
.PP
.nf
The Bit type returns 1.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1591 of file Bimage\&.cpp\&.
.SS "double Bimage::data_type_max ()"

.PP
Get the maximum of a datatype\&. 
.PP
\fBReturns\fP
.RS 4
double maximum value\&. 
.PP
.nf
This function is used for returning the maximum value
a data type can hold.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1672 of file Bimage\&.cpp\&.
.SS "double Bimage::data_type_min ()"

.PP
Get the minimum of a datatype\&. 
.PP
\fBReturns\fP
.RS 4
double minimum value\&. 
.PP
.nf
This function is used for returning the minimum value
a data type can hold.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1642 of file Bimage\&.cpp\&.
.SS "long Bimage::data_type_size () const"

.PP
Returns the size of the datatype in bytes\&. 
.PP
\fBReturns\fP
.RS 4
long data type size\&. 
.PP
.nf
The Bit type returns 1.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1616 of file Bimage\&.cpp\&.
.SS "\fBBstring\fP Bimage::data_type_string ()"

.PP
Get the string representation of a datatype\&. 
.PP
\fBReturns\fP
.RS 4
\fBBstring\fP string representation of a datatype\&. 
.RE
.PP

.PP
Definition at line 1698 of file Bimage\&.cpp\&.
.SS "\fBVector3\fP<double> Bimage::default_origin ()\fC [inline]\fP"

.PP
Definition at line 596 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::defocus_scale (long nn, double df, double df2, double iCL2, int fill_type)"

.PP
Definition at line 225 of file Bimage_powerspectrum\&.cpp\&.
.SS "long Bimage::delete_images (\fBBstring\fP list, int retain = \fC0\fP)"

.PP
Retains or deletes sub-images from a multi-image structure\&. 
.PP
\fBParameters\fP
.RS 4
\fIlist\fP list of sub-images to retain or delete\&. 
.br
\fIretain\fP 0=delete list, 1=retain list\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long error code (<0 means failure) or number of sub-images remaining\&. 
.PP
.nf
Sub-images specified in a list are either retained or deleted.
The new data replaces the old data.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2212 of file Bimage\&.cpp\&.
.SS "double Bimage::density (long nn, \fBVector3\fP< double > coord, double radius)\fC [inline]\fP"

.PP
Definition at line 722 of file Bimage\&.h\&.
.SS "double Bimage::density (long nn, \fBVector3\fP< double > coord, double radius, double & sigma)"

.PP
Calculates the density in a sphere around a coordinate in an image\&. 
.PP
\fBAuthor\fP
.RS 4
Daniel Nemecek and Bernard Heymann 
.RE
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image number\&. 
.br
\fIcoord\fP position of density in map (voxels)\&. 
.br
\fIradius\fP spherical radius\&. 
.br
\fIsigma\fP standard deviation result\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double average density\&. 
.PP
.nf
The density origin is positioned on the component.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3207 of file Bimage\&.cpp\&.
.SS "int Bimage::distort_elliptically (double angle, double shift)"

.PP
Transforms a tubular cylinder to an elliptical profile\&. 
.PP
\fBParameters\fP
.RS 4
\fIangle\fP angle of elliptical maximum\&. 
.br
\fIshift\fP outward shift at elliptical maximum radius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The density is shifted towards or away from the origin by a specific
amount and in a direction determined by an elliptical profile.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 779 of file Bimage_helix\&.cpp\&.
.SS "void Bimage::divide (\fBBimage\fP * p, double scale = \fC1\fP, double shift = \fC0\fP)"

.PP
Divides the first image by the second\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP other image\&. 
.br
\fIscale\fP density scale to apply to other image 
.br
\fIshift\fP density shift to apply to other image\&. 
.PP
.nf
The image is divided by the other with exceptions:
    image /= other*scale + shift
Both images are converted to floating point.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3854 of file Bimage\&.cpp\&.
.SS "void Bimage::divide_one (\fBBimage\fP * p, double scale = \fC1\fP, double shift = \fC0\fP)"

.PP
Divides the first image by the first sub-image of the second\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP other image\&. 
.br
\fIscale\fP density scale to apply to other image 
.br
\fIshift\fP density shift to apply to other image\&. 
.PP
.nf
The image is divided by the other with exceptions:
    image /= other*scale + shift
Both images are converted to floating point.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3907 of file Bimage\&.cpp\&.
.SS "double Bimage::dyad_interpolate (long i, int norm_flag = \fC1\fP)"

.PP
Definition at line 56 of file Bimage_helix\&.cpp\&.
.SS "int Bimage::edge (int type, \fBVector3\fP< long > rect, \fBVector3\fP< double > start, double width, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Smooths the image edge with a soft rectangular function\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP type of edge: 0=rectangle, 1=oval, 2=cylinder 
.br
\fIrect\fP three-value size of the area to be smoothed\&. 
.br
\fIstart\fP three-value start for smoothing\&. 
.br
\fIwidth\fP gaussian width of smoothing function\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP value of edge voxels\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The edge of the image is smoothed with a function:
                    v_old(x,y,z) + fill*exp(1.618*dist/width)
    v_new(x,y,z) = ------------------------------------------
                           1 + exp(1.618*dist/width)
where   fill is the desired edge value.
        dist is the distance to the rectangular boundary defined by 
            the input size and start
        width is the gaussian width (softness)
With very small values of the gaussian width, the edge approaches a
step function.
With negative width values, the area filled is outside the shape.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 393 of file Bimage_edit\&.cpp\&.
.SS "int Bimage::edge (long nn, int type, \fBVector3\fP< long > rect, \fBVector3\fP< double > start, double width, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Smooths the image edge with a soft rectangular function\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fItype\fP type of edge: 0=rectangle, 1=oval, 2=cylinder 
.br
\fIrect\fP three-value size of the area to be smoothed\&. 
.br
\fIstart\fP three-value start for smoothing\&. 
.br
\fIwidth\fP gaussian width of smoothing function\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP value of edge voxels\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The edge of the image is smoothed with a function:
                    v_old(x,y,z) + fill*exp(1.618*dist/width)
    v_new(x,y,z) = ------------------------------------------
                           1 + exp(1.618*dist/width)
where   fill is the desired edge value.
        dist is the distance to the rectangular boundary defined by 
            the input size and start
        width is the gaussian width (softness)
With very small values of the gaussian width, the edge approaches a
step function.
With negative width values, the area filled is outside the shape.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 439 of file Bimage_edit\&.cpp\&.
.SS "\fBBimage\fP * Bimage::edge_mask (int type, \fBVector3\fP< long > rect, \fBVector3\fP< double > start, double width)"

.PP
Creates a mask with the edge approaching zero\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP type of edge: 0=rectangle, 1=oval, 2=cylinder 
.br
\fIrect\fP three-value size of the area to be masked\&. 
.br
\fIstart\fP three-value start for mask\&. 
.br
\fIwidth\fP gaussian width of smoothing function\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new soft mask\&. 
.PP
.nf
The edge of the image is smoothed with a function:
                                1
    v_new(x,y,z) =  -------------------------
                    1 + exp(1.618*dist/width)
where   dist is the distance to the boundary defined by 
            the input size and start
        width is the gaussian width (softness)
With very small values of the gaussian width, the edge approaches a
step function.
With negative width values, the area filled is outside the shape.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 305 of file Bimage_edit\&.cpp\&.
.SS "int Bimage::enlarge (\fBVector3\fP< long > scale)"

.PP
Enlarges an image by an inetger scale\&. 
.PP
\fBParameters\fP
.RS 4
\fIscale\fP three-value scale\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
An image is enlarged by integer amounts.
The new data replaces the old data.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 499 of file Bimage_resize\&.cpp\&.
.SS "long Bimage::erase (string tag)\fC [inline]\fP"

.PP
Definition at line 227 of file Bimage\&.h\&.
.SS "void Bimage::exponential ()"

.PP
Calculates the exponential of the image data\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is first converted to floating point.
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 762 of file Bimage_rescale\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract (long n1, long n2)"

.PP
Extracts a set of sub-images into new image structure\&. 
.PP
\fBParameters\fP
.RS 4
\fIn1\fP first sub-image to extract\&. 
.br
\fIn2\fP last sub-image to extract\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* the new image structure, NULL if copy failed\&. 
.RE
.PP

.PP
Definition at line 40 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract (long nn)"

.PP
Extracts one sub-image into new image structure\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number to extract\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* the new image structure, NULL if copy failed\&. 
.RE
.PP

.PP
Definition at line 21 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP* Bimage::extract (long nn, \fBVector3\fP< double > loc, \fBVector3\fP< long > size, \fBVector3\fP< double > origin)\fC [inline]\fP"

.PP
Definition at line 672 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::extract (long nn, \fBVector3\fP< double > loc, \fBVector3\fP< long > size, \fBVector3\fP< double > ori, \fBMatrix3\fP mat)"

.PP
Extracts a region of one sub-image into new image structure\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number to extract\&. 
.br
\fIloc\fP extraction location\&. 
.br
\fIsize\fP extraction size\&. 
.br
\fIori\fP extraction origin\&. 
.br
\fImat\fP orientation matrix\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* the new image structure, NULL if copy failed\&. 
.RE
.PP

.PP
Definition at line 108 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP* Bimage::extract (long nn, \fBVector3\fP< double > loc, \fBVector3\fP< long > size, \fBVector3\fP< double > origin, \fBView\fP view)\fC [inline]\fP"

.PP
Definition at line 679 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::extract (long nn, \fBVector3\fP< long > coords, \fBVector3\fP< long > size, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Extracts a region of one sub-image into new image structure\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number to extract\&. 
.br
\fIcoords\fP extraction start\&. 
.br
\fIsize\fP extraction size\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* the new image structure, NULL if copy failed\&. 
.RE
.PP

.PP
Definition at line 69 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract_filament (long img_num, double width, int axis, long nspline, \fBVector3\fP< double > * spline)"

.PP
Extracts a filament defined by a series of coordinates\&. 
.PP
\fBParameters\fP
.RS 4
\fIimg_num\fP image number from which to extract filament\&. 
.br
\fIwidth\fP width of filament image to extract\&. 
.br
\fIaxis\fP helical axis alignment: x=1, y=2, z=3\&. 
.br
\fInspline\fP number of coordinates in spline curve\&. 
.br
\fI*spline\fP spline curve\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* one filament image\&. 
.PP
.nf
A single filament is extracted and returned.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1283 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract_line (long nn, \fBVector3\fP< double > start, \fBVector3\fP< double > end, long width)"

.PP
Extracts a line from an image into a new image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number from which to extract\&. 
.br
\fIstart\fP 3-vector start of line\&. 
.br
\fIend\fP 3-vector end of line\&. 
.br
\fIwidth\fP width of integration perpendicular to line\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* extracted line image (1D)\&. 
.PP
.nf
The line values extracted are the interpolated values along the vector
defined by start and end coordinates..

.fi
.PP
 
.RE
.PP

.PP
Definition at line 656 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract_magnify (long nn, \fBVector3\fP< long > center, \fBVector3\fP< long > ext_size, double scale)"

.PP
Extracts a region from an image to magnify\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number to extract\&. 
.br
\fIcenter\fP center of region to magnify\&. 
.br
\fIext_size\fP size of region to magnify\&. 
.br
\fIscale\fP dimensional scaling\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* extracted slice for 2D and 3 slices for 3D\&. 
.PP
.nf
Only the desired region is extracted from the original image and
resized based on the given scale argument.
The dynamic range is rescaled using the image display minimum and 
maximum:
    new_data = data*255/(max-min)
with truncation of the data below 0 and above 255.
Bit data are converted to 0 (black) and 255 (white).
RGB data are rescaled as for gray scale images.
Complex data types are converted to intensities.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1027 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract_shell (long nn, double minrad, double maxrad)"

.PP
Extracts a shell from an image into a new image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number from which to extract, -1 indicates all images\&. 
.br
\fIminrad\fP minimum shell radius\&. 
.br
\fImaxrad\fP maximum shell radius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* extracted image\&. 
.PP
.nf
A single image (only one sub-image) is extracted from a given sub-image
in an image structure, starting at a specified point and with a 
specified size.
The old data is not affected.
Statistics for the extracted image are calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 193 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract_show (int aflag)"

.PP
Converts a slice from an image to a 2D plane for display\&. 
.PP
\fBParameters\fP
.RS 4
\fIaflag\fP averaging flag\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* extracted slice\&. 
.PP
.nf
Only the desired image slice is extracted from the original image and
resized based on the given scale argument.
The image, slice and scale values are encoded in the image structure.
The dynamic range is rescaled using the image display minimum and maximum:
    new_data = data*255/(max-min)
with truncation of the data below 0 and above 255.
Bit data are converted to 0 (black) and 255 (white).
RGB data are rescaled as for gray scale images.
Complex data types are converted to intensities.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 969 of file Bimage_extract\&.cpp\&.
.SS "int Bimage::extract_show_chunk (\fBBimage\fP * pshow, int aflag, long i, long len)"

.PP
Definition at line 851 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract_slice (long nz)"

.PP
Extracts a given slice or slices from an image\&. 
.PP
\fBParameters\fP
.RS 4
\fInz\fP slice number to extract\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* extracted slice(s)\&. 
.PP
.nf
Only the desired slices are extracted from the original image.
The dynamic range is rescaled using the image display minimum and 
maximum:
    new_data = data*255/(max-min)
with truncation of the data below 0 and above 255.
Bit data are converted to 0 (black) and 255 (white).
RGB data are rescaled as for gray scale images.
Complex data types are converted to intensities.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1191 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract_tetrahedron (\fBVector3\fP< double > * tet, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Extracts a tetrahedral part of the image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*tet\fP four 3-value vectors defining the tetrahedron\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
All voxels outside a tetrahedron defined by four points or vectors 
are set to a given fill value.
The new data replaces the old data.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 693 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract_tile_stack (\fBVector3\fP< long > coords, \fBVector3\fP< long > tile_size, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Extracts a stack of tiles at a specified position from an image into a new image\&. 
.PP
\fBParameters\fP
.RS 4
\fIcoords\fP coordinates for the tile origins\&. 
.br
\fItile_size\fP 3-vector size of extracted image\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* p extracted stack of tiles\&. 
.PP
.nf
A stack of tiles of specified size are extracted from all the sub-images
in an image structure, using given coordinates for the tiles.
The origins of the tiles are inserted into the sub-image origin fields.
The old data is not affected.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 575 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP ** Bimage::extract_tile_stacks (vector< \fBVector3\fP< long >> & coords, \fBVector3\fP< long > tile_size)"

.PP
Extracts stacks of tiles at a specified positions from an image into an array of new images\&. Extracts a set of tiles at specified positions from an image into a new image\&. 
.PP
\fBParameters\fP
.RS 4
\fIcoords\fP coordinates for the tile origins\&. 
.br
\fItile_size\fP 3-vector size of extracted image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<Bimage*> extracted stacks of tiles\&. 
.PP
.nf
Stacks of tiles of specified size are extracted from all the sub-images
in an image structure, using given coordinates for the tiles.
The origins of the tiles are inserted into the sub-image origin fields.
The old data is not affected.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 607 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract_tiles (long nn, \fBVector3\fP< long > start, \fBVector3\fP< long > region, \fBVector3\fP< long > tile_size, \fBVector3\fP< long > step_size, int exceed)"

.PP
Extracts a set of tiles from an image into a new image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number from which to extract\&. 
.br
\fIstart\fP 3-vector start for first tile to be extracted\&. 
.br
\fIregion\fP 3-vector size of part of image to be extracted (0 = whole image)\&. 
.br
\fItile_size\fP 3-vector size of extracted image\&. 
.br
\fIstep_size\fP 3-vector size of tile intervals\&. 
.br
\fIexceed\fP flag to allow tiles to exceed the input image size\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* extracted set of sub-images\&. 
.PP
.nf
A set of tiles of specified size are extracted from a given sub-image
in an image structure, starting from a point and generating
as many tiles as would fit into the image size given. If the image size
given is zero, then the whole image is used. The origins of the tiles
are inserted into the sub-image origin fields.
The old data is not affected.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 465 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract_tiles (long nn, \fBVector3\fP< long > tile_size, double fraction = \fC0\&.2\fP)"

.PP
Extracts a set of tiles from an image into a new image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number from which to extract\&. 
.br
\fItile_size\fP 3-vector size of extracted image\&. 
.br
\fIfraction\fP overlap fraction to aim for\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* extracted set of sub-images\&. 
.PP
.nf
A set of tiles of specified size are extracted from a given sub-image
in an image structure. The tiles are located with overlap (~20% of tile width)
with the aim of covering the whole image but not exceeding it.
The origins of the tiles are inserted into the sub-image origin fields.
The old data is not affected.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 517 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract_tiles (long nn, vector< \fBVector3\fP< long >> & coords, \fBVector3\fP< long > tile_size)"

.PP
Extracts a set of tiles at specified positions from an image into a new image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number from which to extract, -1 indicates all images\&. 
.br
\fIcoords\fP coordinates for the tile origins\&. 
.br
\fItile_size\fP 3-vector size of extracted image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* p extracted set of sub-images\&. 
.PP
.nf
A set of tiles of specified size are extracted from a given sub-image 
in an image structure, using given coordinates for the tiles, which have
to fit into the image size. The origins of the tiles are inserted into 
the sub-image origin fields.
The old data is not affected.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 400 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::extract_wrap (long nn, \fBVector3\fP< double > loc, \fBVector3\fP< long > size, \fBVector3\fP< double > ori, \fBMatrix3\fP mat)"

.PP
Extracts a region of one sub-image into new image structure with wrapping\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number to extract\&. 
.br
\fIloc\fP extraction location\&. 
.br
\fIsize\fP extraction size\&. 
.br
\fIori\fP extraction origin\&. 
.br
\fImat\fP orientation matrix\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* the new image structure, NULL if copy failed\&. 
.RE
.PP

.PP
Definition at line 151 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP* Bimage::extract_wrap (long nn, \fBVector3\fP< long > size, \fBMatrix3\fP mat)\fC [inline]\fP"

.PP
Definition at line 685 of file Bimage\&.h\&.
.SS "int Bimage::extrude_cross_section (long length, double helix_rise, double helix_angle, int fill_type, double fill)"

.PP
Extrudes a 2D cross section into a 3D continuous helix\&. 
.PP
\fBParameters\fP
.RS 4
\fIlength\fP length in z\&. 
.br
\fIhelix_rise\fP helical subunit rise in angstrom\&. 
.br
\fIhelix_angle\fP helical subunit rotation in radians\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP value of edge voxels\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The helical axis is at the origin and alongthe a axis.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1596 of file Bimage_helix\&.cpp\&.
.SS "int Bimage::fft ()\fC [inline]\fP"

.PP
Definition at line 855 of file Bimage\&.h\&.
.SS "int Bimage::fft (\fBfft_direction\fP dir)"

.PP
Fast Fourier transforms an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIdir\fP direction of transformation (FFTW_FORWARD or FFTW_BACKWARD) 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
FFTW library (www.fftw.org).
A multi-image 1D, 2D and 3D data set is transformed forward or backward 
and rescaled by 1/sqrt(N).  The forward transformation has a negative 
signed exponent in the kernel and the backward transform a positive
sign. The transformation is done in place and the resultant data are 
returned within the original image structure.  For forward transforms, 
the resultant data type is complex float, while for backward transforms, 
it is Float.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 49 of file Bimage_fft\&.cpp\&.
.SS "int Bimage::fft (\fBfft_direction\fP dir, bool norm_flag)"

.PP
Fast Fourier transforms an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIdir\fP direction of transformation (FFTW_FORWARD or FFTW_BACKWARD) 
.br
\fInorm_flag\fP normalization: 0=none, 1=sqrtN, 2=N\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
FFTW library (www.fftw.org).
A multi-image 1D, 2D and 3D data set is transformed forward or backward 
and optionally rescaled by 1/sqrt(N) or N.  The forward transformation 
has a negative signed exponent in the kernel and the backward transform 
a positive sign. The transformation is done in place and the resultant 
data are returned within the original image structure.
For both directions the resultant image is complex.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 80 of file Bimage_fft\&.cpp\&.
.SS "int Bimage::fft (\fBfft_plan\fP plan, bool norm_flag = \fC1\fP)"

.PP
Fast Fourier transforms an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIplan\fP Fourier transform plan\&. 
.br
\fInorm_flag\fP normalization: 0=none, 1=sqrtN, 2=N\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
FFTW library (www.fftw.org).
A multi-image 1D, 2D and 3D data set is transformed forward or backward 
and optionally rescaled by 1/sqrt(N) or N.  The forward transformation 
has a negative signed exponent in the kernel and the backward transform 
a positive sign. The transformation is done in place and the resultant 
data are returned within the original image structure.
For both directions the resultant image is complex.
Requirement: The plan must be derived from the same size image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 179 of file Bimage_fft\&.cpp\&.
.SS "int Bimage::fft_back ()\fC [inline]\fP"

.PP
Definition at line 856 of file Bimage\&.h\&.
.SS "int Bimage::fft_back (\fBfft_plan\fP plan, bool norm_flag = \fC1\fP)\fC [inline]\fP"

.PP
Definition at line 863 of file Bimage\&.h\&.
.SS "\fBfft_plan\fP Bimage::fft_setup (\fBfft_direction\fP dir, int opt = \fC0\fP)"

.PP
Sets up a plan for fast Fourier transforms\&. 
.PP
\fBParameters\fP
.RS 4
\fIdir\fP direction of transformation (FFTW_FORWARD or FFTW_BACKWARD) 
.br
\fIopt\fP optimization (0=FFTW_ESTIMATE, 1=FFTW_MEASURE, 2=FFTW_PATIENT, 3=FFTW_EXHAUSTIVE)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
fft_plan FFTW plan\&. 
.PP
.nf
FFTW library (www.fftw.org).
The size and direction determines the plan.
Both FFTW versions 2 and 3 are supported.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 29 of file Bimage_fft\&.cpp\&.
.SS "\fBBimage\fP * Bimage::filament_density (double width)"

.PP
Estimates the density per pixel length of a filament\&. 
.PP
\fBParameters\fP
.RS 4
\fIwidth\fP filament width (pixels)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* one dimensional image with line integrals\&. 
.PP
.nf
The filament axis must be along the long axis (x or y).
The filament width must be about half of the image width.
The background is calculated for each line from the regions 
outside the width of the filament and subtracted from all
values in the line.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1753 of file Bimage_helix\&.cpp\&.
.SS "\fBBimage\fP * Bimage::filament_from_projections (double hi_res, int flag = \fC0\fP)"

.PP
Reconstructs a filament from a set of projections\&. 
.PP
\fBParameters\fP
.RS 4
\fIhi_res\fP high resolution limit\&. 
.br
\fIflag\fP 0=sequential, 1=random\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* reconstructed filament\&. 
.PP
.nf
The views are set at equally spaced angles around the z-axis.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1813 of file Bimage_helix\&.cpp\&.
.SS "\fBBplot\fP * Bimage::filament_width (long width, long lim_lo, long lim_hi)"

.PP
Estimates the width of a filament\&. 
.PP
\fBParameters\fP
.RS 4
\fIwidth\fP window size\&. 
.br
\fIlim_lo\fP minimum filament width\&. 
.br
\fIlim_hi\fP maximum filament width\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bplot* plot of filament widths\&. 
.PP
.nf
The filament axis must be along the y axis.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1648 of file Bimage_helix\&.cpp\&.
.SS "string& Bimage::file_name ()\fC [inline]\fP"

.PP
Definition at line 232 of file Bimage\&.h\&.
.SS "void Bimage::file_name (string s)\fC [inline]\fP"

.PP
Definition at line 231 of file Bimage\&.h\&.
.SS "void Bimage::fill (double v)\fC [inline]\fP"

.PP
Definition at line 717 of file Bimage\&.h\&.
.SS "int Bimage::fill_gaps (long step)"

.PP
Fill the voxels that are not calculated\&. 
.PP
\fBParameters\fP
.RS 4
\fIstep\fP step increment for voxels with proper values\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 if error\&. 
.PP
.nf
The step size used to calculate sparse voxels is here used to determine
a kernel size for the filling operation. For each sparse voxel, all the
neighbors within the kernel are filled with the center value.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 958 of file Bimage_edit\&.cpp\&.
.SS "\fBTypePointer\fP Bimage::fill_value (double v)"

.PP
Definition at line 1098 of file Bimage\&.cpp\&.
.SS "int Bimage::filter_average (long kernel_size)"

.PP
Applies an averaging filter to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIkernel_size\fP length of kernel edge (typically 3)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 if error\&. 
.PP
.nf
A kernel of a given size is passed over the image and the average
value within the kernel assigned to the central voxel.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 207 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::filter_average (\fBVector3\fP< long > k)"

.PP
Definition at line 213 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::filter_bilateral (double sigma1, double sigma2, int kernel_type, long kernel_radius)"

.PP
Denoise an image with combined gaussian distance and density difference kernel\&. 
.PP
\fBParameters\fP
.RS 4
\fIsigma1\fP sigma for distance weighting function\&. 
.br
\fIsigma2\fP sigma for density difference weighting function\&. 
.br
\fIkernel_type\fP kernel type for range filter\&. 
.br
\fIkernel_radius\fP kernel radius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The kernel is multiplied with each area surrounding the current voxel.
Kernel types:
    1.  Gaussian
    2.  Lorentzian
    3.  Tukey

.fi
.PP
 
.RE
.PP

.PP
Definition at line 902 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::filter_bilateral_chunk (\fBBimage\fP * pkernel, double sigma2, int kernel_type, float * nudata, long i, long len, int first)"

.PP
Definition at line 789 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::filter_by_difference (\fBBimage\fP * p)"

.PP
Calculates an anisotropic average within a kernel based on the local gradient\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP image to compare with\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 1382 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::filter_dog (double sigma1, double sigma2)"

.PP
Convolves the image with a difference of gausians kernel\&. 
.PP
\fBParameters\fP
.RS 4
\fIsigma1\fP sigma for the inner gaussian\&. 
.br
\fIsigma2\fP sigma for the outer gaussian\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.RE
.PP

.PP
Definition at line 760 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::filter_extremes ()"

.PP
Filters the extremes out of a micrograph image\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
Segmentation is used to identify large contiguous regions of high
and low values, and these regions are set to the average.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 651 of file Bimage_segment\&.cpp\&.
.SS "int Bimage::filter_extremes (double tmin, double tmax, int kernel = \fC3\fP)"

.PP
Filters the extremes out of an image by replacing with adjacent averages\&. 
.PP
\fBParameters\fP
.RS 4
\fItmin\fP minimum\&. 
.br
\fItmax\fP maximum\&. 
.br
\fIkernel\fP kernel edge size\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
Pixels smaller than the minimum or larger than the maximum are set to
the average within a defined kernel.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 705 of file Bimage_segment\&.cpp\&.
.SS "int Bimage::filter_extremes (int mod_flag)"

.PP
Filters the extremes out of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fImod_flag\fP modification flag (0=set to avg, 1=set to min_max)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
A histogram of an image is calculated.  The first minimum in the first
quarter of the histogram and the last minimum in the last quarter
are taken to define the small and large outliers.  Pixel outside
these minima are then either set to average or to minimum or maximum
(depending on the mod_flag argument) to remove the outliers.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 680 of file Bimage_segment\&.cpp\&.
.SS "int Bimage::filter_gaussian (long kernel_size, double sigma = \fC0\fP)"

.PP
Applies a gaussian filter to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIkernel_size\fP length of kernel edge\&. 
.br
\fIsigma\fP gaussian decay\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 if error\&. 
.PP
.nf
The image is comvolved with a Gaussian kernel.
If the sigma value is zero, it is set to a sixth of the kernel size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 441 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::filter_ortho (int type)"

.PP
Convolves the image with an orthogonal kernel with wrapping\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP type of kernel: 0=gradient magnitude, 1=laplacian\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
The gradient kernel is:
    0  0  0    0 -1  0    0  0  0
    0 -1  0   -1  0  1    0  1  0
    0  0  0    0  1  0    0  0  0

The Laplacian filter kernel for a 3D volume is:
    0  0  0    0  1  0    0  0  0
    0  1  0    1 -6  1    0  1  0
    0  0  0    0  1  0    0  0  0
For 1D and 2D the central value is -2 and -4 respectively.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 663 of file Bimage_filter\&.cpp\&.
.SS "\fBBimage\fP * Bimage::filter_peak (long kernel_size)"

.PP
Finds the peaks in an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIkernel_size\fP length of kernel edge (typically 3)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 if error\&. 
.PP
.nf
A kernel of a given size is passed over the image and if the central
voxel is the maximum, it is kept, otherwise it is set to background.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1194 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::filter_rank (long kernel_size, double rank)"

.PP
Applies a median filter to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIkernel_size\fP length of kernel edge (typically 3)\&. 
.br
\fIrank\fP which value in the kernel to retain\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 if error\&. 
.PP
.nf
A kernel of a given size is passed over the image and the median
value within the kernel assigned to the central voxel.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1140 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::filter_rank_chunk (long kernel_size, double rank, float * nudata, long i, long len)"

.PP
Definition at line 1059 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::filter_rolling_ball (long radius, double scale)"

.PP
Apply a rolling ball filter\&. 
.PP
\fBParameters\fP
.RS 4
\fIradius\fP radius of rolling ball\&. 
.br
\fIscale\fP density scale\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 954 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::filter_sinc ()"

.PP
Weighs an image with a sinc function\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
This filter compensates for trilinear interpolation during reconstruction.
The origin must be properly defined.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 484 of file Bimage_filter\&.cpp\&.
.SS "\fBBimage\fP* Bimage::find (\fBBstring\fP fn)\fC [inline]\fP"

.PP
Definition at line 236 of file Bimage\&.h\&.
.SS "int Bimage::find_center (\fBBimage\fP * pmask, double hires, double lores, double radius, double sigma, int refine_flag)"

.PP
Finds the center of mass of an image by cross-correlation with its inverse\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP binary mask (only 0 and 1)\&. 
.br
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fIradius\fP search radius (if < 1, default 1e30)\&. 
.br
\fIsigma\fP attenuation around radius\&. 
.br
\fIrefine_flag\fP set to refine shift to subpixel resolution\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D data sets are transformed 
forward, the first transform multiplied by the complex conjugate of
the second transform, followed by backward transformation and 
rescaling by 1/(N*N). Data beyond the resolution set in the first 
image structure are not used. Therefore the correct setting 
of units and resolution in the image are required. Defaults for the 
units are usually 1 Angstrom/voxel and a zero resolution would
include the whole image (i.e., no resolution limitation).
A shift vector for each pair of images is calculated to
determine the cross-correlation peak to sub-pixel resolution.
Note: The first image is the reference and the shift returned is to
    transform the second to fit the first.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1237 of file Bimage_correlate\&.cpp\&.
.SS "double Bimage::find_cyclic_point_group (\fBBsymmetry\fP & sym, int binfac, double hires, double lores)"

.PP
Finds the orientation for an image with a cyclic point group symmetry\&. 
.PP
\fBParameters\fP
.RS 4
\fIsym\fP point group\&. 
.br
\fIbinfac\fP binning for faster searching (limited to 1,2,3)\&. 
.br
\fIhires\fP high resolution limit in angstroms\&. 
.br
\fIlores\fP low resolution limit in angstroms\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double symmetry correlation coefficient\&. 
.PP
.nf
The cyclic point group symmetry operation is applied to an image using
the reference symmetry axis, aslo the 2D rotation axis (default {0,0,1}). 

.fi
.PP
 
.RE
.PP

.PP
Definition at line 234 of file Bimage_symmetry\&.cpp\&.
.SS "\fBBplot\fP * Bimage::find_helix_parameters (double angle_start, double angle_end, double angle_step, int bin, double hires, double lores, double radius)"

.PP
Finds the best helix parameters for helical map\&. 
.PP
\fBParameters\fP
.RS 4
\fIangle_start\fP start value for angle\&. 
.br
\fIangle_end\fP end value for angle\&. 
.br
\fIangle_step\fP step size for angle\&. 
.br
\fIbin\fP bin image for faster searching (limited to 1,2,3)\&. 
.br
\fIhires\fP high resolution limit in angstroms\&. 
.br
\fIlores\fP low resolution limit in angstroms\&. 
.br
\fIradius\fP radius for mask (voxels)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bplot* plot with search results\&. 
.PP
.nf
An incremental search is done for the rotation angle, with the rise
inferred from the cross-correlation shift.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 873 of file Bimage_helix\&.cpp\&.
.SS "\fBBplot\fP * Bimage::find_helix_parameters (double rise_start, double rise_end, double rise_step, double angle_start, double angle_end, double angle_step, int bin, double radius)"

.PP
Finds the best helix parameters for helical map\&. 
.PP
\fBParameters\fP
.RS 4
\fIrise_start\fP start value for rise\&. 
.br
\fIrise_end\fP end value for rise\&. 
.br
\fIrise_step\fP step size for rise\&. 
.br
\fIangle_start\fP start value for angle\&. 
.br
\fIangle_end\fP end value for angle\&. 
.br
\fIangle_step\fP step size for angle\&. 
.br
\fIbin\fP bin image for faster searching (limited to 1,2,3)\&. 
.br
\fIradius\fP radius for mask (voxels)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bplot* plot with search results\&. 
.PP
.nf
An incremental search is done for the rise and rotation angle.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1056 of file Bimage_helix\&.cpp\&.
.SS "int Bimage::find_peak (double radius = \fC1e30\fP, double sigma = \fC0\fP)"

.PP
Finds the peak in an image to the nearest voxel\&. 
.PP
\fBParameters\fP
.RS 4
\fIradius\fP search radius (if < 1, default 1e30)\&. 
.br
\fIsigma\fP attenuation around radius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
An image is searched for the global maximum (typically used to find
the shift vector in a cross-correlation map).
The peak vectors returned are in actual pixel coordinates (no wrapping).
The location around which to search is taken from the image origins.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1342 of file Bimage_correlate\&.cpp\&.
.SS "\fBVector3\fP< double > * Bimage::find_peaks (double excl_dist, long & ncoor, double & threshold_min, double & threshold_max, double pix_min = \fC2\fP, double pix_max = \fC10\fP)"

.PP
Finds the peaks in a cross-correlation map to find template matches\&. 
.PP
\fBParameters\fP
.RS 4
\fIexcl_dist\fP exclusion distance between peaks\&. 
.br
\fI&ncoor\fP number of coordinates\&. 
.br
\fI&threshold_min\fP minimum threshold to choose peaks\&. 
.br
\fI&threshold_max\fP maximum threshold to choose peaks\&. 
.br
\fIpix_min\fP minimum peak width\&. 
.br
\fIpix_max\fP maximum peak width\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBVector3<double>\fP* list of coordinates\&. 
.PP
.nf
The map is searched in increments of the particle radius to identify
peaks above the threshold and within a box the size of the
particle radius. The identified peaks are further examined to eliminate 
ones that are too close to a higher scoring peak. The acceptable distance
between peaks is set to 1.8 times the particle radius.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1830 of file Bimage_correlate\&.cpp\&.
.SS "\fBBimage\fP * Bimage::find_peaks (long kernelsize)"

.PP
Finds peaks in a map with periodic boundaries\&. 
.PP
\fBParameters\fP
.RS 4
\fIkernelsize\fP size of kernel side (must be ≥3)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* image with peaks\&. 
.PP
.nf
A peak is defined as the local maximum within a specified kernel, where the
maximum is also larger than a given threshold. This assumes that the region
around a peak decreases monotonically on the scale length of the size of
the kernel. With kernel edge of 3 (+-1 in all directions), the values around
the peak shows a strict monotonicity with distance from the peak maximum.
The peak positions and values are returned in the new image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1741 of file Bimage_correlate\&.cpp\&.
.SS "double Bimage::find_point_group (\fBBsymmetry\fP & sym, double angle_step, int binfac, double hires, double lores, int flags)"

.PP
Finds the orientation for an image with a specific point group symmetry\&. 
.PP
\fBParameters\fP
.RS 4
\fIsym\fP point group\&. 
.br
\fIangle_step\fP angular step size for search\&. 
.br
\fIbinfac\fP binning for faster searching (limited to 1,2,3)\&. 
.br
\fIhires\fP high resolution limit in angstroms\&. 
.br
\fIlores\fP low resolution limit in angstroms\&. 
.br
\fIflags\fP flag to search only for minor axes\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double symmetry correlation coefficient\&. 
.PP
.nf
The point group symmetry operations are applied to an image with an
orientation defined by the reference symmetry axis (default {0,0,1}). 

.fi
.PP
 
.RE
.PP

.PP
Definition at line 299 of file Bimage_symmetry\&.cpp\&.
.SS "int Bimage::find_shift (\fBBimage\fP * pref, \fBBimage\fP * pmask, double hires, double lores, double radius, double sigma, int refine_flag)"

.PP
Calculates a cross-correlation map to find the shift for the pair of images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pref\fP reference image\&. 
.br
\fI*pmask\fP binary mask (only 0 and 1)\&. 
.br
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fIradius\fP search radius (if < 1, default 1e30)\&. 
.br
\fIsigma\fP attenuation around radius\&. 
.br
\fIrefine_flag\fP set to refine shift to subpixel resolution\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D data sets are transformed 
forward, the first transform multiplied by the complex conjugate of
the second transform, followed by backward transformation and 
rescaling by 1/(N*N). Data beyond the resolution set in the first 
image structure are not used. Therefore the correct setting 
of units and resolution in the image are required. Defaults for the 
units are usually 1 Angstrom/voxel and a zero resolution would
include the whole image (i.e., no resolution limitation).
A shift vector for each pair of images is calculated to
determine the cross-correlation peak to sub-pixel resolution.
Note: The first image is the reference and the shift returned is to
    transform the second to fit the first.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 931 of file Bimage_correlate\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::find_shift (\fBBimage\fP * pref, \fBBimage\fP * pmask, double hires, double lores, double radius, double sigma, int refine_flag, double & cc)"

.PP
Definition at line 970 of file Bimage_correlate\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::find_shift (\fBBimage\fP * pref, \fBBimage\fP * pmask, double hires, double lores, double radius, double sigma, int refine_flag, \fBfft_plan\fP planf, \fBfft_plan\fP planb, double & cc)"

.PP
Calculates a cross-correlation map to find the shift for the pair of images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pref\fP reference image\&. 
.br
\fI*pmask\fP binary mask (only 0 and 1)\&. 
.br
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fIradius\fP search radius (if < 1, default 1e30)\&. 
.br
\fIsigma\fP attenuation around radius\&. 
.br
\fIrefine_flag\fP set to refine shift to subpixel resolution\&. 
.br
\fIplanf\fP forward Fourier transform plan\&. 
.br
\fIplanb\fP backward Fourier transform plan\&. 
.br
\fI&cc\fP correlation coefficient 
.RE
.PP
\fBReturns\fP
.RS 4
\fBVector3<double>\fP shift\&. 
.PP
.nf
FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D data sets are transformed 
forward, the first transform multiplied by the complex conjugate of
the second transform, followed by backward transformation and 
rescaling by 1/(N*N). Data beyond the resolution set in the first 
image structure are not used. Therefore the correct setting 
of units and resolution in the image are required. Defaults for the 
units are usually 1 Angstrom/voxel and a zero resolution would
include the whole image (i.e., no resolution limitation).
A shift vector for each pair of images is calculated to
determine the cross-correlation peak to sub-pixel resolution.
Note: The first image is the reference and the shift returned is to
    transform the second to fit the first.

Only the first sub-image shift is calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1093 of file Bimage_correlate\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::find_shift (\fBBimage\fP * pref, double hires, double lores, double radius, double sigma, int refine_flag, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Calculates a cross-correlation map to find the shift for the pair of images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pref\fP reference image\&. 
.br
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fIradius\fP search radius (if < 1, default 1e30)\&. 
.br
\fIsigma\fP attenuation around radius\&. 
.br
\fIrefine_flag\fP set to refine shift to subpixel resolution\&. 
.br
\fIplanf\fP forward Fourier transform plan\&. 
.br
\fIplanb\fP backward Fourier transform plan\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBVector3<double>\fP shift\&. 
.PP
.nf
FFTW library (www.fftw.org).
Two equally sized multi-image 1D, 2D and 3D data sets are transformed 
forward, the first transform multiplied by the complex conjugate of
the second transform, followed by backward transformation and 
rescaling by 1/(N*N). Data beyond the resolution set in the first 
image structure are not used. Therefore the correct setting 
of units and resolution in the image are required. Defaults for the 
units are usually 1 Angstrom/voxel and a zero resolution would
include the whole image (i.e., no resolution limitation).
A shift vector for each pair of images is calculated to
determine the cross-correlation peak to sub-pixel resolution.
Note: The first image is the reference and the shift returned is to
    transform the second to fit the first.

Only the first sub-image shift is calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1030 of file Bimage_correlate\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::find_shift (long nn, \fBBimage\fP * pref, \fBBimage\fP * pmask, double hi_res, double lo_res, double shift_limit, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Calculates a cross-correlation map to find the shift for the pair of images\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image to align\&. 
.br
\fI*pref\fP reference image\&. 
.br
\fI*pmask\fP binary mask for cross-correlation (only 0 and 1)\&. 
.br
\fIhi_res\fP high resolution limit\&. 
.br
\fIlo_res\fP low resolution limit\&. 
.br
\fIshift_limit\fP search radius (if < 1, default 1e30)\&. 
.br
\fIplanf\fP forward Fourier transform plan\&. 
.br
\fIplanb\fP backward Fourier transform plan\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double correlation coefficient\&. 
.PP
.nf
The shift is returned as the origin of each sub-image relative to
the reference origin.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1146 of file Bimage_correlate\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::find_shift_in_transform (double shift_limit)"

.PP
Finds the shift by brute force backtransformation for selected shifts\&. 
.PP
\fBParameters\fP
.RS 4
\fIshift_limit\fP maximum real space shift\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBVector3<double>\fP best shift\&. 
.PP
.nf
The input image is a cross-correlation transform.
A brute force integration is done for the given shift to calculate
the corresponding correlation coefficient.
The correlation coefficient is return in the FOM field of the sub-image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 501 of file Bimage_correlate\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::find_shift_in_transform (long nn, \fBBimage\fP * pref, double shift_limit)"

.PP
Definition at line 83 of file Bimage_align\&.cpp\&.
.SS "\fBBimage\fP * Bimage::find_symmetric_view (\fBBimage\fP * ptemp, \fBBsymmetry\fP & sym, double phi_step, double theta_step, double alpha_step, \fBVector3\fP< double > shift)"

.PP
Finds the view that on symmetrizing fits best to a symmetric template\&. 
.br
 
.PP
\fBParameters\fP
.RS 4
\fI*ptemp\fP symmetric template\&. 
.br
\fI&sym\fP symmetry\&. 
.br
\fIphi_step\fP phi angle step size (radians)\&. 
.br
\fItheta_step\fP theta angle step size (radians)\&. 
.br
\fIalpha_step\fP rotation angle step size (radians)\&. 
.br
\fIshift\fP shift to impose before symmetrization\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* image rotated to the best view\&. 
.PP
.nf
The orientation parameters, view vector, angle of rotation and origin,
of each image is packed into 3D reciprocal space.
An image is used in the reconstruction if its selection flag has been set.
The fill value is taken from image's background value.  

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1045 of file Bimage_symmetry\&.cpp\&.
.SS "\fBBimage\fP * Bimage::find_template (\fBBimage\fP * ptemp, \fBBimage\fP * pmask, double hires, double lores, int bin, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Finds one or more matches to a template\&. 
.PP
\fBParameters\fP
.RS 4
\fI*ptemp\fP template image\&. 
.br
\fI*pmask\fP reciprocal space mask\&. 
.br
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fIbin\fP level of image binning\&. 
.br
\fIplanf\fP forward Fourier transform plan\&. 
.br
\fIplanb\fP backward Fourier transform plan\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* cross-correlation map\&. 
.PP
.nf
A template is cross-correlated with the input image including
bandpass filtering to target the size of the template particle.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1179 of file Bimage_correlate\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::fit_peak ()"

.PP
Fits an elliptic parabole to locate the position of the peak to sub-voxel resolution\&. 
.PP
\fBReturns\fP
.RS 4
\fBVector3<double>\fP shift from input origin\&. 
.PP
.nf
The peak is expected to be near the middle of the image, close to the input origin.
The function fits a 10-parameter parabola to the image.
The shift is retrieved from the parameters by matrix inversion.
The refined peak returned is the offset from the input origin.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1433 of file Bimage_correlate\&.cpp\&.
.SS "void Bimage::fix_type ()"

.PP
Determines the replacement data type\&. 
.PP
\fBReturns\fP
.RS 4
DataType replacement data type\&. 
.PP
.nf
An integer data type is switched between signed and unsigned.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1750 of file Bimage\&.cpp\&.
.SS "\fBFourierType\fP Bimage::fourier_type ()\fC [inline]\fP"

.PP
Definition at line 375 of file Bimage\&.h\&.
.SS "void Bimage::fourier_type (\fBFourierType\fP tf)\fC [inline]\fP"

.PP
Definition at line 376 of file Bimage\&.h\&.
.SS "int Bimage::friedel_apply ()"

.PP
Applies Friedel symmetry\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The Friedel-related voxels are converted to polar form and the 
in difference in amplitude and phase calculated (taking into account
the phases should differ by sign). The voxels are then set to the
average and its conjugate.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2021 of file Bimage_fspace\&.cpp\&.
.SS "double Bimage::friedel_check ()"

.PP
Checks Friedel symmetry\&. 
.PP
\fBReturns\fP
.RS 4
double overall RMSD or residual\&. 
.PP
.nf
The differences between the complex and polar forms of Friedel-related 
voxels are calculated and accumulated as squared sums weighted by their
average intensities. The residuals are then calculated as 
root-mean-square-deviations.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1959 of file Bimage_fspace\&.cpp\&.
.SS "\fBBplot\fP * Bimage::fsc (\fBBimage\fP * p, double hi_res, double sampling_ratio = \fC1\fP)"

.PP
Definition at line 325 of file Bimage_resolution\&.cpp\&.
.SS "\fBBplot\fP * Bimage::fsc (double hi_res, double sampling_ratio = \fC1\fP)"

.PP
Definition at line 245 of file Bimage_resolution\&.cpp\&.
.SS "\fBBplot\fP * Bimage::fsc_dpr (double hi_res, double sampling_ratio = \fC1\fP, int flag = \fC0\fP)"

.PP
Calculates an FSC and DPR curves from two images\&. 
.PP
\fBParameters\fP
.RS 4
\fIhi_res\fP high resolution limit\&. 
.br
\fIsampling_ratio\fP radial sampling ratio (1 for per voxel sampling)\&. 
.br
\fIflag\fP if 1 calculate only the FSC\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bplot* FSC curve\&. 
.PP
.nf
FRC: Fourier ring/shell correlation 
-----------------------------------
Saxton & Baumeister (1982) J. Microscopy 127, 127-138 
de la Fraga et al. (1995) Ultramicroscopy 60, 385-391 
           sum(|F1|*|F2|) 
FRC/FSC = --------------------------------- 
          sqrt( sum(|F1|^2) * sum(|F2|^2) ) 

.fi
.PP
 
.RE
.PP

.PP
Definition at line 92 of file Bimage_resolution\&.cpp\&.
.SS "\fBBimage\fP * Bimage::fsc_local (\fBBimage\fP * p, \fBBimage\fP * pmask, double hi_res, double * cutoff, int mask_level, int size, int pad, \fBVector3\fP< long > vedge, int step = \fC1\fP, int taper = \fC1\fP, double fill = \fC0\fP)"

.PP
Determine the local resolution at each masked voxel in a map\&. 
.PP
\fBAuthor\fP
.RS 4
Giovanni Cardone and Bernard Heymann 
.RE
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.br
\fI*pmask\fP mask\&. 
.br
\fIhi_res\fP high resolution limit\&. 
.br
\fI*cutoff\fP correlation threshold(s)\&. 
.br
\fImask_level\fP mask level index\&. 
.br
\fIsize\fP kernel size\&. 
.br
\fIpad\fP padding factor\&. 
.br
\fIvedge\fP edge size\&. 
.br
\fIstep\fP voxel step size\&. 
.br
\fItaper\fP kernel tapering function\&. 
.br
\fIfill\fP background fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* local resolution image\&. 
.PP
.nf
For each voxel specified in the mask, within the edge limits, and at
the step size given, two kernels are extracted from the two input maps.
These kernels are then compared to determine the resolution based FSC.
The resultant resolution value is then written into a new map.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 592 of file Bimage_resolution\&.cpp\&.
.SS "\fBBimage\fP * Bimage::fsc_shell (\fBBimage\fP * p, double hi_res, double * cutoff, int thickness, int step, int minrad, int maxrad, int pad = \fC1\fP, int smooth = \fC0\fP, double fill = \fC0\fP)"

.PP
Determine the resolution for each concentric shell in a map\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.br
\fIhi_res\fP high resolution limit\&. 
.br
\fI*cutoff\fP correlation threshold(s)\&. 
.br
\fIthickness\fP shell thickness\&. 
.br
\fIstep\fP step size between shells\&. 
.br
\fIminrad\fP minimum radius\&. 
.br
\fImaxrad\fP maximum radius\&. 
.br
\fIpad\fP padding factor\&. 
.br
\fIsmooth\fP flag for edge smooting\&. 
.br
\fIfill\fP background fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* a 1D image containing the shell resolutions\&. 
.RE
.PP

.PP
Definition at line 415 of file Bimage_resolution\&.cpp\&.
.SS "int Bimage::fspace_2D_interpolate (\fBComplex\fP< float > cv, \fBVector3\fP< double > m, double part_weight, int interp_type)"

.PP
Interpolates a 2D image for packing ito a 3D reciprocal space volume\&. 
.br
 
.PP
\fBParameters\fP
.RS 4
\fIcv\fP complex value from 2D transform\&. 
.br
\fIm\fP location in 3D relative to origin\&. 
.br
\fIpart_weight\fP weight to assign to value (usually 1)\&. 
.br
\fIinterp_type\fP interpolation type (0=nearest neighbor, 1=weighted nearest neigbor, 2=trilinear)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.RE
.PP

.PP
Definition at line 25 of file Bimage_reconstruct\&.cpp\&.
.SS "int Bimage::fspace_amp_one ()"

.PP
Sets all amplitudes to one\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
If the image is a not a Fourier transform, it is transformed, modified,
and backtransformed. If the image is a Fourier transform, it is just
modified. The resultant image is floating point for real space or
complex for reciprocal space.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 323 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_amp_threshold (double threshold)"

.PP
Filters the amplitudes of the Fourier transform of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP Miminum amplitude to accept\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered. The filtering sets all amplitudes below the given threshold
to zero. The resultant image is floating point for real space or
complex for reciprocal space.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 368 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_background ()"

.PP
Calculates the background for a Fourier transform\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. The background is taken to be the area outside Nyquest\&. 
.RE
.PP

.PP
Definition at line 46 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_bandpass (double res_hi, double res_lo, double width, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Applies a bandpass filter to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIres_hi\fP high resolution limit\&. 
.br
\fIres_lo\fP low resolution limit\&. 
.br
\fIwidth\fP gaussian width of edge\&. 
.br
\fIplanf\fP forward Fourier transform plan\&. 
.br
\fIplanb\fP backward Fourier transform plan\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered. The filtering sets all values with frequencies above the
given high resolution limit and below the given low resolution limit
to zero.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 525 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_bandpass (double res_hi, double res_lo = \fC0\fP, double width = \fC0\fP)"

.PP
Applies a bandpass filter to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIres_hi\fP high resolution limit\&. 
.br
\fIres_lo\fP low resolution limit\&. 
.br
\fIwidth\fP gaussian width of edge\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered. The filtering sets all values with frequencies above the
given high resolution limit and below the given low resolution limit
to zero.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 496 of file Bimage_fspace\&.cpp\&.
.SS "vector< double > Bimage::fspace_default_bands (double res_lo, double res_hi)"

.PP
Sets up default frequency space bands to generate a mask\&. 
.PP
\fBParameters\fP
.RS 4
\fIres_lo\fP low resolution limit (angstrom)\&. 
.br
\fIres_hi\fP high resolution limit (angstrom)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<double> array of band specifications\&. 
.PP
.nf
The band argument is a list of pairs of values, each pair indicating
a resolution shell (in angstrom) and a flag indicating whether the 
following shells should be:
    0: excluded - also the high resolution limit
    1: included in the FOM
    -1: included in the cross-validation FOM
The high resolution limit for the mask is set in the image structure.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 814 of file Bimage_mask\&.cpp\&.
.SS "double Bimage::fspace_fit_B_factor (double res_hi = \fC0\fP)"

.PP
Determines the overall B-factor of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIres_hi\fP high resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double B-factor\&. 
.PP
.nf
The input image must a real space image. A radial power spectrum
is calculated and fitted to the linearized version of the function:
    f^2 = scale * F^2 * exp(-B_factor/2 * s^2)
where:
    f:  scattering profile for carbon
    F:  radial average amplitude
    s:  reciprocal space distance
    scale:  arbitrary scale
The linear form of the function is:
    4*(log(f) - log(F)) = 2*log(scale) - B * s^2

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1128 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_frequency_filter (double freq, double sigma)"

.PP
Applies a frequency filter to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIfreq\fP frequency or inverse frequency\&. 
.br
\fIsigma\fP gaussian envelope width around frequency\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered.
The filter imposes a guassian envelope at the given frequency.
If the frequency value is greater than one, it is assumed to be given
as the inverse.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 611 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_frequency_filter (double freq, double sigma, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Applies a frequency filter to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIfreq\fP frequency or inverse frequency\&. 
.br
\fIsigma\fP gaussian envelope width around frequency\&. 
.br
\fIplanf\fP forward Fourier transform plan\&. 
.br
\fIplanb\fP backward Fourier transform plan\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered.
The filter imposes a guassian envelope at the given frequency.
If the frequency value is greater than one, it is assumed to be given
as the inverse.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 640 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_gabor_filter (\fBVector3\fP< double > freq, double fsigma, double psigma)"

.PP
Applies a Gabor filter to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIfreq\fP frequency or inverse frequency location\&. 
.br
\fIfsigma\fP gaussian envelope width in the direction of the frequency vector\&. 
.br
\fIpsigma\fP gaussian envelope width perpendicular to the frequency vector\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered.
The filter imposes a guassian envelope at the given frequency location.
If the frequency vector size is greater than one, it is assumed to be given
as the inverse.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 716 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_gabor_filter (\fBVector3\fP< double > freq, double fsigma, double psigma, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Applies a Gabor filter to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIfreq\fP frequency or inverse frequency direction location\&. 
.br
\fIfsigma\fP gaussian envelope width in the direction of the frequency vector\&. 
.br
\fIpsigma\fP gaussian envelope width perpendicular to the frequency vector\&. 
.br
\fIplanf\fP forward Fourier transform plan\&. 
.br
\fIplanb\fP backward Fourier transform plan\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
If the image is a not a Fourier transform, it is transformed, filtered,
and backtransformed. If the image is a Fourier transform, it is just
filtered.
The filter imposes a guassian envelope at the given frequency location.
If the frequency vector size is greater than one, it is assumed to be given
as the inverse.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 746 of file Bimage_fspace\&.cpp\&.
.SS "\fBBimage\fP * Bimage::fspace_gradient (\fBVector3\fP< double > sigma)"

.PP
Generates a image with orthogonal gradients encded in 3-value vectors\&. 
.PP
\fBParameters\fP
.RS 4
\fIsigma\fP Gaussian sigma values\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is Fourier transformed if needed.
An anisotropic weight function is calculated at each voxel and applied to the transform.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1594 of file Bimage_fspace\&.cpp\&.
.SS "\fBComplex\fP< double > Bimage::fspace_interpolate (long img_num, \fBVector3\fP< double > m, \fBFSI_Kernel\fP * kernel)"

.PP
Calculates the complex value at an image location by kernel-based interpolation\&. 
.PP
\fBParameters\fP
.RS 4
\fIimg_num\fP sub-image number\&. 
.br
\fIm\fP location in image\&. 
.br
\fIkernel\fP interpolation kernel\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Complex<double> interpolated value\&. The kernel lookup table must be precalculated\&. 
.RE
.PP

.PP
Definition at line 85 of file Bimage_fspace\&.cpp\&.
.SS "long Bimage::fspace_maximum_radius (double resolution, double sampling_ratio = \fC1\fP)"

.PP
Calculates the maximum radius in frequency space from a given resolution\&. 
.PP
\fBParameters\fP
.RS 4
\fIresolution\fP high resolution limit\&. 
.br
\fIsampling_ratio\fP frequency space sampling (default 1 pixel/sample)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long maximum radius\&. 
.PP
.nf
The maximum radius is either the physical image size divided by the resolution,
or Nyquist frequency.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 26 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_normalize ()"

.PP
Normalizes an image's amplitudes\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 1854 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_normalize_radial (\fBBimage\fP * pmask, double resolution = \fC0\fP, int flag = \fC0\fP)"

.PP
Normalizes an image's amplitudes\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP reciprocal space mask (0 & 1, indicating inclusion of structure factors)\&. 
.br
\fIresolution\fP high resolution limit\&. 
.br
\fIflag\fP flag to calculate power (0) or amplitude (1)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 1882 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_pack_2D (\fBBimage\fP * p, \fBMatrix3\fP mat, double hi_res, double lo_res, \fBVector3\fP< double > scale, double part_weight = \fC1\fP, int interp_type = \fC0\fP)"

.PP
Packs a 2D Fourier transform into a 3D reciprocal space volume\&. 
.br
 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP 2D particle image transform\&. 
.br
\fImat\fP rotation matrix\&. 
.br
\fIhi_res\fP high resolution limit\&. 
.br
\fIlo_res\fP low resolution limit (infinite if 0)\&. 
.br
\fIscale\fP scale of reconstruction and particle magnification\&. 
.br
\fIpart_weight\fP weight of particle (usually 1)\&. 
.br
\fIinterp_type\fP interpolation type (0=nearest neighbor, 1=weighted nearest neigbor, 2=trilinear)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
The rotation matrix is used to determine the plane in reciprocal space
to which the 2D transform data is added. The map is assumed to be cubic
and the 2D transform square. The orientation parameters must be written
into the image structure. 

.fi
.PP
 
.RE
.PP

.PP
Definition at line 107 of file Bimage_reconstruct\&.cpp\&.
.SS "int Bimage::fspace_pack_2D (\fBBimage\fP * p, \fBView\fP asu_view, \fBBsymmetry\fP & sym, double hi_res, double lo_res, \fBVector3\fP< double > scale, double part_weight = \fC1\fP, int interp_type = \fC0\fP)"

.PP
Packs a 2D Fourier transform into a 3D reciprocal space volume\&. 
.br
 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP 2D particle image transform\&. 
.br
\fIasu_view\fP view of asymmetric unit\&. 
.br
\fI*sym\fP point group symmetry\&. 
.br
\fIhi_res\fP high resolution limit\&. 
.br
\fIlo_res\fP low resolution limit (infinite if 0)\&. 
.br
\fIscale\fP scale of reconstruction and particle magnification\&. 
.br
\fIpart_weight\fP weight of particle (usually 1)\&. 
.br
\fIinterp_type\fP interpolation type (0=nearest neighbor, 1=weighted nearest neigbor, 2=trilinear)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
The rotation matrix is used to determine the plane in reciprocal space
to which the 2D transform data is added. The map is assumed to be cubic
and the 2D transform square. The orientation parameters must be written
into the image structure.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 174 of file Bimage_reconstruct\&.cpp\&.
.SS "long Bimage::fspace_pack_2D_into_central_section (\fBBimage\fP * p, long ft_size, double scale, double hi_res, double lo_res, \fBMatrix3\fP matr, \fBMatrix3\fP mat)"

.PP
Packs a 2D Fourier transform into a central section of a 3D reciprocal space volume\&. 
.br
 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP 2D particle image transform\&. 
.br
\fIft_size\fP Fourier transform size\&. 
.br
\fIscale\fP scale of reconstruction and particle magnification\&. 
.br
\fIhi_res\fP high resolution limit\&. 
.br
\fIlo_res\fP low resolution limit (infinite if 0)\&. 
.br
\fImatr\fP central section orientation matrix\&. 
.br
\fImat\fP image orientation matrix\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
The rotation matrix is used to determine the plane in reciprocal space
to which the 2D transform data is added in reference to the rotation
matrix of the central section. The map is assumed to be cubic
and the 2D transform square. The orientation parameters must be written
into the image structure. 

.fi
.PP
 
.RE
.PP
\fBVector3<double>\fP vn(mat[2][0]/mat[2][2], mat[2][1]/mat[2][2], 0);
.PP
matr = matr\&.transpose();
.PP
m = mat * iv; m[2] = m\&.scalar(vn); m = matr * m;
.PP
Definition at line 212 of file Bimage_reconstruct\&.cpp\&.
.SS "int Bimage::fspace_pack_3D (\fBBimage\fP * p, double hi_res = \fC0\fP, double threshold = \fC0\fP)"

.PP
Packs a 3D Fourier transform into a 3D reciprocal space volume\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP 3D particle image transform\&. 
.br
\fIhi_res\fP high resolution limit\&. 
.br
\fIthreshold\fP threshold to exclude low intensities\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
The image is added up to the high resolution limit and excluding
low intensities as defined by the threshold.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 314 of file Bimage_reconstruct\&.cpp\&.
.SS "int Bimage::fspace_positive ()"

.PP
Sets the image to positive definite\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. Scales the amplitudes to give a zero (DC) value of one\&. 
.RE
.PP

.PP
Definition at line 1918 of file Bimage_fspace\&.cpp\&.
.SS "vector< double > Bimage::fspace_radial (long nn, long maxrad, int flag = \fC0\fP)"

.PP
Calculates the radial power spectrum from a Fourier transform\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image number\&. 
.br
\fImaxrad\fP maximum radius (i\&.e\&., high resolution limit)\&. 
.br
\fIflag\fP flag to calculate power (0) or amplitude (1), and not normalize (2)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double* radial power spectrum in the form of a 1D image\&.
.RE
.PP
A radial average of a 2D or 3D Fourier transform is calculated\&. An interpolative method is used where the value of a voxel is distributed between the two nearest radial annuli\&. The final sum in an annulus is normalized by the number of voxels contributing to the annulus sum\&. 
.PP
Definition at line 959 of file Bimage_fspace\&.cpp\&.
.SS "\fBBimage\fP * Bimage::fspace_radial_power (double resolution, double sampling_ratio = \fC1\fP)"

.PP
Calculates the radial power spectrum from a Fourier transform\&. 
.PP
\fBParameters\fP
.RS 4
\fIresolution\fP high resolution limit\&. 
.br
\fIsampling_ratio\fP frequency space sampling (default 1 pixel/sample)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* radial power spectrum in the form of a 1D image\&. 
.PP
.nf
A radial average of a 2D or 3D Fourier transform is calculated.  
An interpolative method is used where the value of 
a voxel is distributed between the two nearest radial annuli.
The final sum in an annulus is normalized by the number of voxels 
contributing to the annulus sum.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 833 of file Bimage_fspace\&.cpp\&.
.SS "long Bimage::fspace_reconstruction_add (\fBBimage\fP * p)"

.PP
Adds all components to a reconstruction\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP frequency space reconstruction to add\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long 0\&. 
.PP
.nf
The FOM block contains the sum of powers, the next image conatins the
weight sum, and the next image FOM block contains the sum of the
weight squared.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 384 of file Bimage_reconstruct\&.cpp\&.
.SS "long Bimage::fspace_reconstruction_snr ()"

.PP
Calculates the SNR map\&. 
.PP
\fBReturns\fP
.RS 4
long coverage\&. 
.PP
.nf
The FOM block contains the sum of powers, the next image conatins the
weight sum, and the next image FOM block contains the sum of the
weight squared.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 536 of file Bimage_reconstruct\&.cpp\&.
.SS "int Bimage::fspace_reconstruction_stats (double resolution, double sampling_ratio = \fC1\fP)"

.PP
Calculates Fourier shell statistics\&. 
.PP
\fBParameters\fP
.RS 4
\fIresolution\fP high resolution limit\&. 
.br
\fIsampling_ratio\fP frequency space sampling (default 1 pixel/sample)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The average FOM and number of FOM values in each resolution shell is determined.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 452 of file Bimage_reconstruct\&.cpp\&.
.SS "long Bimage::fspace_reconstruction_weigh ()"

.PP
Weighs a reconstruction\&. 
.PP
\fBReturns\fP
.RS 4
long coverage\&. 
.PP
.nf
The FOM block contains the sum of powers, the next image conatins the
weight sum, and the next image FOM block contains the sum of the
weight squared.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 412 of file Bimage_reconstruct\&.cpp\&.
.SS "\fBBimage\fP * Bimage::fspace_resize (\fBBimage\fP * pref)"

.PP
Resizes an image in frequency space to avoid interpolation\&. 
.PP
\fBParameters\fP
.RS 4
\fIpref\fP reference\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* resized image\&. The image is first resized to approximate the real size of the reference map\&. 
.RE
.PP

.PP
Definition at line 253 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_resize (double scale, double res_hi, double res_lo)"

.PP
Resizes an image in frequency space to avoid interpolation\&. 
.PP
\fBParameters\fP
.RS 4
\fIscale\fP isotropic scaling\&. 
.br
\fIres_hi\fP high resolution limit\&. 
.br
\fIres_lo\fP low resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 202 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_scale (long nn, vector< double > & scale, \fBBimage\fP * pmask = \fCNULL\fP)"

.PP
Definition at line 1061 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_scale (vector< double > & scale, \fBBimage\fP * pmask = \fCNULL\fP)"

.PP
Definition at line 1043 of file Bimage_fspace\&.cpp\&.
.SS "\fBBimage\fP* Bimage::fspace_shift_sum ()\fC [inline]\fP"

.PP
Definition at line 1056 of file Bimage\&.h\&.
.SS "int Bimage::fspace_sqrt_amp ()"

.PP
Change the amlitudes to their square roots\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 424 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_square_amp ()"

.PP
Change the amlitudes to their squares\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 455 of file Bimage_fspace\&.cpp\&.
.SS "\fBBplot\fP * Bimage::fspace_ssnr (long nimg, double res_hi, double sampling_ratio)"

.PP
Definition at line 906 of file Bimage_align\&.cpp\&.
.SS "\fBBplot\fP * Bimage::fspace_subset_ssnr (int subset, double res_hi, double sampling_ratio, int flag = \fC0\fP)"

.PP
Definition at line 1035 of file Bimage_align\&.cpp\&.
.SS "\fBBimage\fP * Bimage::fspace_subset_sums (int subset, int flag = \fC0\fP)"

.PP
Definition at line 731 of file Bimage_align\&.cpp\&.
.SS "\fBBimage\fP * Bimage::fspace_sum (int shift = \fC0\fP)"

.PP
Definition at line 689 of file Bimage_align\&.cpp\&.
.SS "int Bimage::fspace_translate (long nn, \fBVector3\fP< double > shift)"

.PP
Translates an image in frequency space to avoid interpolation\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image to transform\&. 
.br
\fIshift\fP 3-value real space shift vector\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 175 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_translate (\fBVector3\fP< double > shift)"

.PP
Translates an image in frequency space to avoid interpolation\&. 
.PP
\fBParameters\fP
.RS 4
\fIshift\fP 3-value real space shift vector\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.RE
.PP

.PP
Definition at line 147 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh (\fBBimage\fP * pref, \fBBimage\fP * pmask, double resolution = \fC0\fP)"

.PP
Weighs an image's amplitudes with the radial power spectrum of another\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pref\fP reference image\&. 
.br
\fI*pmask\fP reciprocal space mask (0 & 1, indicating inclusion of structure factors)\&. 
.br
\fIresolution\fP high resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The two images must be of the same dimensions.
The radial power spectra of the two images are calculated
and used to calculate the ratio of the second to the first in each shell.
This ratio is then used to rescale the amplitudes of the first image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1810 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh (vector< double > & curve, int flag = \fC0\fP)"

.PP
Definition at line 1020 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh_accumulated_dose (vector< double > dose)"

.PP
Weighs an image's amplitudes with the accumulated dose\&. 
.PP
\fBParameters\fP
.RS 4
\fIdose\fP array containing accumulated dose and parameters\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The amplitudes are weighed using:
1. with 2 parameters: the formula of Grant and Grigorieff (2015).
2. with 3 parameters: exponential decay.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1786 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh_B_factor (double B, double resolution = \fC0\fP)"

.PP
Weighs an image's amplitudes with B-factor (gaussian) curve\&. 
.PP
\fBParameters\fP
.RS 4
\fIB\fP B factor\&. 
.br
\fIresolution\fP high resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is Fourier transformed and weighed with a gaussian curve:
    Fnew = F*exp(-B*s2/4)

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1317 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh_C_curve (double resolution = \fC0\fP)"

.PP
Weighs an image's amplitudes with the carbon scattering curve\&. 
.PP
\fBParameters\fP
.RS 4
\fIresolution\fP high resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is Fourier transformed and the radial power spectrum calculated.
The ratio between the C curve and the average amplitudes in each shell
is calculated and used to rescale the amplitudes of the image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1360 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh_dose (double dose_per_frame, int flag = \fC0\fP)"

.PP
Weighs an image's amplitudes with the accumulated dose\&. 
.PP
\fBParameters\fP
.RS 4
\fIdose_per_frame\fP electron dose per frame\&. 
.br
\fIflag\fP 0=Grant, 1=exponential decay\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is Fourier transformed and the amplitudes weighed using 
the formula of Grant and Grigorieff (2015) or an exponential decay curve.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1722 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh_dose (long nn, double dose_per_frame, vector< double > critdose)"

.PP
Definition at line 1685 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh_FSC_curve (\fBBplot\fP * plot, double resolution = \fC0\fP)"

.PP
Weighs an image's amplitudes with a given FSC curve\&. 
.PP
\fBParameters\fP
.RS 4
\fI*plot\fP FSC plot\&. 
.br
\fIresolution\fP high resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is Fourier transformed and the radial power spectrum calculated.
The ratio between the square root of the FSC curve and the average 
amplitudes in each shell is calculated and used to rescale the amplitudes 
of the image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1493 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh_gaussian (long nn, \fBVector3\fP< double > sigma, int dir = \fC0\fP)"

.PP
Weighs an image's amplitudes with an anisotropic Gaussian function\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image index\&. 
.br
\fIsigma\fP Gaussian sigma values\&. 
.br
\fIdir\fP derivative direction: 0=none, 1=x, 2=y, 3=z\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image must be a complex Fourier transform.
An anisotropic weight function is calculated at each voxel and applied to the transform.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1533 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh_LoG (double resolution, double sigma)"

.PP
Weighs an image's amplitudes with a Laplacian-of-Gaussian function\&. 
.PP
\fBParameters\fP
.RS 4
\fIresolution\fP high resolution limit\&. 
.br
\fIsigma\fP gaussian sigma\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is Fourier transformed and the radial power spectrum calculated.
The ratio between the C curve and the average amplitudes in each shell
is calculated and used to rescale the amplitudes of the image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1395 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh_ramp (double resolution, double axis, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Weighs a transform with a ramp\&. 
.PP
\fBParameters\fP
.RS 4
\fIresolution\fP high resolution limit\&. 
.br
\fIaxis\fP tilt axis for single tilt series (radians)\&. 
.br
\fIplanf\fP 2D forward Fourier transform plan\&. 
.br
\fIplanb\fP 2D backward Fourier transform plan\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
Requirements:
    The data must be complex float and the FOM block must be allocated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1258 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh_ramp (double resolution, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Weighs a transform with a ramp\&. 
.PP
\fBParameters\fP
.RS 4
\fIresolution\fP high resolution limit\&. 
.br
\fIplanf\fP 2D forward Fourier transform plan\&. 
.br
\fIplanb\fP 2D backward Fourier transform plan\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
Requirements:
    The data must be complex float and the FOM block must be allocated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1196 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::fspace_weigh_RPS_curve (\fBBplot\fP * plot, double resolution = \fC0\fP)"

.PP
Weighs an image's amplitudes with a given RPS curve\&. 
.PP
\fBParameters\fP
.RS 4
\fI*plot\fP RPS plot\&. 
.br
\fIresolution\fP high resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is Fourier transformed and the radial power spectrum calculated.
The ratio between the square root of the RPS curve and the average 
amplitudes in each shell is calculated and used to rescale the amplitudes 
of the image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1436 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::gaussian_sphere (long nn, \fBVector3\fP< double > center, double sigma, double amp)"

.PP
Fills a gaussian sphere within an image with a uniform value\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fIcenter\fP center of sphere\&. 
.br
\fIsigma\fP Gaussian sigma value\&. 
.br
\fIamp\fP amplitude\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
All voxels within a sphere at a given location and with a given radius 
are increased by a given fill value.
The new data replaces the old data.
The default center is {0,0,0}.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 566 of file Bimage_edit\&.cpp\&.
.SS "void Bimage::get (\fBBstring\fP tag)"

.PP
Prints out header information associated with a tag string\&. 
.PP
\fBParameters\fP
.RS 4
\fItag\fP tag string\&. 
.RE
.PP

.PP
Definition at line 2741 of file Bimage\&.cpp\&.
.SS "double Bimage::get (long nn, long xx, long yy, long zz, long cc = \fC0\fP)"

.PP
Returns the data value at the given coordinates\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image index\&. 
.br
\fIxx\fP x coordinate\&. 
.br
\fIyy\fP y coordinate\&. 
.br
\fIzz\fP z coordinate\&. 
.br
\fIcc\fP channel index\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double value\&. 
.PP
.nf
The elemental data value is returned in double precision.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 969 of file Bimage\&.cpp\&.
.SS "double Bimage::get (long nn, \fBVector3\fP< double > vox, long cc = \fC0\fP)"

.PP
Returns the data value at the given coordinates\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image index\&. 
.br
\fIvox\fP voxel coordinates\&. 
.br
\fIcc\fP channel index\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double value\&. 
.PP
.nf
The elemental data value is returned in double precision.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 991 of file Bimage\&.cpp\&.
.SS "tm* Bimage::get_localtime ()\fC [inline]\fP"

.PP
Definition at line 255 of file Bimage\&.h\&.
.SS "time_t Bimage::get_time ()\fC [inline]\fP"

.PP
Definition at line 251 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::gradient ()"

.PP
Calculates the central difference gradient image\&. 
.PP
\fBReturns\fP
.RS 4
Bimage* an image with 3-value gradient vectors\&. 
.PP
.nf
The central differences are calculated in the three orthogonal
directions and written into 3-value vectors.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 252 of file Bimage_filter\&.cpp\&.
.SS "\fBBimage\fP * Bimage::gradient3x3 ()"

.PP
Calculates the difference gradient image in a 3x3 kernel\&. 
.PP
\fBReturns\fP
.RS 4
Bimage* an image with 3-value gradient vectors\&. 
.PP
.nf
The central differences are calculated in the three orthogonal
directions and written into 3-value vectors.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 336 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::gradient_correction ()"

.PP
Calculates and corrects for a linear gradient across an image\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The linear gradient across an image is calculated as:
    density(x,y,z) = b0 + b1*x + b2*y + b3*z
The image is converted to floating point and corrected for the gradient.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 783 of file Bimage_rescale\&.cpp\&.
.SS "\fBGSgraph\fP Bimage::graph_segment (int type = \fC1\fP, int connect_type = \fC0\fP, double complexity = \fC0\fP, long min_size = \fC0\fP)"

.PP
Graph-based segmentation of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP segmentation type: 1=threshold, 2=statistical region merging\&. 
.br
\fIconnect_type\fP connection type: 0=direct neighbors, 1=all neighbors\&. 
.br
\fIcomplexity\fP a value determining the number of segments\&. 
.br
\fImin_size\fP minimum segment size\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBGSgraph\fP graph with segment designations\&. 
.PP
.nf
An array of edges between neighboring voxels is set up and sorted in
non-decreasing order. The voxels are then aggregated into regions based
on two selectable criteria:
simple      edge difference with adjustable threshold.
srm         statistical region merging.
Regions below a given cutoff size are merged.
Only the first sub-image is segmented.

.fi
.PP
 
.RE
.PP
\fBRemarks\fP
.RS 4
R\&. Nock, F\&. Nielsen: Statistical Region Merging\&. IEEE Trans\&. Pattern Anal\&. Mach\&. Intell\&. 26(11): 1452-1458 (2004) 
.RE
.PP

.PP
Definition at line 1380 of file Bimage_segment\&.cpp\&.
.SS "\fBBimage\fP * Bimage::graph_segments_to_image (\fBGSgraph\fP & g)"

.PP
Converting a graph-based segmentation to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIg\fP graph segmentation\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* segmented image\&. 
.RE
.PP

.PP
Definition at line 1451 of file Bimage_segment\&.cpp\&.
.SS "\fBBimage\fP * Bimage::graph_segments_to_mask (\fBGSgraph\fP & g)"

.PP
Converting a graph-based segmentation to a multi-level mask\&. 
.PP
\fBParameters\fP
.RS 4
\fIg\fP graph segmentation\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* segmented image\&. 
.RE
.PP

.PP
Definition at line 1478 of file Bimage_segment\&.cpp\&.
.SS "\fBGSgraph\fP Bimage::graph_setup (int connect_type)"

.PP
Initializing voxels and edges for graph-based segmentation\&. 
.PP
\fBParameters\fP
.RS 4
\fIconnect_type\fP connection type: 0=direct neighbors, 1=all neighbors\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBGSgraph\fP graph with segment designations\&. 
.RE
.PP
\fBRemarks\fP
.RS 4
R\&. Nock, F\&. Nielsen: Statistical Region Merging\&. IEEE Trans\&. Pattern Anal\&. Mach\&. Intell\&. 26(11): 1452-1458 (2004)
.RE
.PP
Edges are set up with 6 or 26 neighbors\&. 
.PP
Definition at line 1298 of file Bimage_segment\&.cpp\&.
.SS "\fBCompoundType\fP Bimage::guess_compoundtype (long nc)"

.PP
Definition at line 324 of file Bimage\&.cpp\&.
.SS "int Bimage::hanning_taper (double fill = \fC0\fP)"

.PP
Apply Hanning taper window to the image\&. 
.PP
\fBParameters\fP
.RS 4
\fIfill\fP value of edge voxels\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
Along each dimension, the image is multiplied with a function:
    v_new(i) = fill + ( v_old(i) - fill )* 0.5 * ( 1 - cos( 2*PI*i/(n-1) )) i=0,...,n-1
where   fill is the desired edge value.
        n is the size of the image

.fi
.PP
 
.RE
.PP

.PP
Definition at line 460 of file Bimage_edit\&.cpp\&.
.SS "\fBBimage\fP * Bimage::height (\fBView\fP * views, double threshold = \fC0\fP)"

.PP
Calculates a set of height images from a 3D density map\&. 
.PP
\fBParameters\fP
.RS 4
\fI*views\fP linked list of views\&. 
.br
\fIthreshold\fP density threshold to consider as object\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* 2D height images as sub-images\&. 
.PP
.nf
A set of height images is calculated according to a list of views.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 230 of file Bimage_topo\&.cpp\&.
.SS "\fBBimage\fP * Bimage::helical_cross_section (double helix_rise, double helix_angle, double scale, double hires)"

.PP
Calculates a helical cross section from line transforms of a filament\&. 
.PP
\fBParameters\fP
.RS 4
\fIhelix_rise\fP helical subunit rise in angstrom\&. 
.br
\fIhelix_angle\fP helical subunit rotation in radians\&. 
.br
\fIscale\fP scale of cross section\&. 
.br
\fIhires\fP high resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* 2D cross section image\&. 
.PP
.nf
The filament image must be oriented with the helical axis coinciding with 
the y axis. Each row of pixels is transformed and written into a
2D transform based on an orientation calculated from given helical
parameters.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1421 of file Bimage_helix\&.cpp\&.
.SS "double Bimage::helix_interpolate (long i, double helix_rise, double helix_angle, int zmin, int zmax, double radius, int norm_flag = \fC1\fP)"

.PP
Definition at line 18 of file Bimage_helix\&.cpp\&.
.SS "\fBBplot\fP * Bimage::helix_segment_correlation (int thickness, double angle_start, double angle_end, double angle_step, int bin, double hires, double lores, double radius)"

.PP
Calculates the correlation over rotation angles between helical segments\&. 
.PP
\fBParameters\fP
.RS 4
\fIthickness\fP segment thickness\&. 
.br
\fIangle_start\fP start value for angle\&. 
.br
\fIangle_end\fP end value for angle\&. 
.br
\fIangle_step\fP step size for angle\&. 
.br
\fIbin\fP bin image for faster searching (limited to 1,2,3)\&. 
.br
\fIhires\fP high resolution limit in angstroms\&. 
.br
\fIlores\fP low resolution limit in angstroms\&. 
.br
\fIradius\fP radius for mask (voxels)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bplot* plot with coefficients over all rotations results\&. 
.PP
.nf
The image is split up into segments in the z direction. Every adjacent pair
of segments are cross-correlated over an angular range to find the best
rotation. The cross-correlation can be resolution-limited. The image may
also be masked beyond a radius and binned to speed up execution.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1240 of file Bimage_helix\&.cpp\&.
.SS "int Bimage::helix_segment_correlation_one (long i, double angle_start, double angle_end, double angle_step, int bin, double hires, double lores, double radius, \fBfft_plan\fP planf, \fBfft_plan\fP planb, double * cc)"

.PP
Definition at line 1198 of file Bimage_helix\&.cpp\&.
.SS "double Bimage::helix_symmetrize (double helix_rise, double helix_angle, int dyad_axis, int zmin, int zmax, double radius, int norm_flag = \fC1\fP)"

.PP
Symmetrizes an image given helical symmetry parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fIhelix_rise\fP rise per asymmetric unit (angstrom)\&. 
.br
\fIhelix_angle\fP rotation angle per asymmetric unit (radians)\&. 
.br
\fIdyad_axis\fP dyad axis indicator: 2=dyad axis on x-axis, otherwise none\&. 
.br
\fIzmin\fP mimimum z slice to include\&. 
.br
\fIzmax\fP maximum z slice to include\&. 
.br
\fIradius\fP radius to do symmetrizing over (pixels)\&. 
.br
\fInorm_flag\fP if 1, normalize 
.RE
.PP
\fBReturns\fP
.RS 4
double R factor\&. 
.PP
.nf
The data between the z limits are replicated along the helical axis
according to the helical rise and rotation to fill the new volume.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 133 of file Bimage_helix\&.cpp\&.
.SS "\fBBplot\fP * Bimage::histogram (long bins)"

.PP
Calculates the histogram of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIbins\fP number of bins in the histogram\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bplot* 0\&. 
.PP
.nf
A histogram of an image is calculated with a given number of bins.
Multiple channels are output as successive one-dimensional arrays.
The image data is not affected.
The statistics for the input image must be correctly calculated.
If the postscript file name is given, a postscript plot is produced.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 82 of file Bimage_histogram\&.cpp\&.
.SS "vector< long > Bimage::histogram (long bins, double & scale, double & offset)"

.PP
Calculates the histogram of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIbins\fP number of bins in the histogram\&. 
.br
\fI&scale\fP scale\&. 
.br
\fI&offset\fP offset\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<long> histogram\&. 
.PP
.nf
A histogram of an image is calculated with a given number of bins.
Multiple channels are output as successive one-dimensional arrays.
The image data is not affected.
The statistics for the input image must be correctly calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 33 of file Bimage_histogram\&.cpp\&.
.SS "\fBBplot\fP * Bimage::histogram_counts (int flags = \fC0\fP)"

.PP
Finds the peaks in a quantized image from the histogram\&. 
.PP
\fBParameters\fP
.RS 4
\fIflags\fP 1=plot, 2=convert image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bplot* plot of fits\&. 
.PP
.nf
A histogram of an image with quantized data is calculated.
The peaks are determined and the image converted.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 206 of file Bimage_histogram\&.cpp\&.
.SS "vector< double > Bimage::histogram_gauss_fit (long bins, long ngauss = \fC1\fP)"

.PP
Fits a gaussian function to a histogram of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIbins\fP number of bins in the histogram\&. 
.br
\fIngauss\fP number of gaussians\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<double> array with 3 values for each gaussian\&. 
.PP
.nf
A histogram of an image is calculated with a given number of bins.
The return has (in order) the gaussian amplitude, the offset, and the sigma value.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 910 of file Bimage_histogram\&.cpp\&.
.SS "vector< double > Bimage::histogram_gauss_fit2 (long bins, long ngauss = \fC1\fP)"

.PP
Definition at line 1016 of file Bimage_histogram\&.cpp\&.
.SS "\fBBplot\fP * Bimage::histogram_gauss_plot (long bins, long ngauss = \fC1\fP)"

.PP
Fits a gaussian function to a histogram of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIbins\fP number of bins in the histogram\&. 
.br
\fIngauss\fP number of gaussians\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bplot* plot of the histogram and the gaussian fit\&. 
.PP
.nf
A histogram of an image is calculated with a given number of bins.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1115 of file Bimage_histogram\&.cpp\&.
.SS "int Bimage::histogram_minmax (double & tmin, double & tmax)"

.PP
Calculates minimum and maximum thresholds for truncation\&. 
.PP
\fBParameters\fP
.RS 4
\fI&tmin\fP minumum threshold\&. 
.br
\fI&tmax\fP maxumum threshold\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
A histogram of an image is calculated.  The first minimum in the first
quarter of the histogram and the last minimum in the last quarter
are taken to define the small and large outliers.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 542 of file Bimage_histogram\&.cpp\&.
.SS "vector< double > Bimage::histogram_multi_thresholds (long bins, long number)"

.PP
Calculates multiple thresholds from a histogram\&. 
.PP
\fBParameters\fP
.RS 4
\fIbins\fP number bins in histogram\&. 
.br
\fInumber\fP number of clusters (one more than thresholds)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<double> thresholds\&. 
.PP
.nf
Reference: PS.Liao, TS.Chen, and PC. Chung,
       Journal of Information Science and Engineering, vol 17, 713-727 (2001)

.fi
.PP
 
.RE
.PP

.PP
Definition at line 854 of file Bimage_histogram\&.cpp\&.
.SS "\fBBplot\fP * Bimage::histogram_otsu_variance (long bins)"

.PP
Calculates the inter-set variance of the bisection of a historgram using the method of Otsu\&. 
.PP
\fBParameters\fP
.RS 4
\fIbins\fP number bins in histogram\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double threshold\&. 
.PP
.nf
Reference: NOBUYUKI OTSU, IEEE TRANSACTIONS ON SYSTEMS, MAN, AND CYBERNETICS, VOL. SMC-9, NO. 1, JANUARY 1979

.fi
.PP
 
.RE
.PP

.PP
Definition at line 644 of file Bimage_histogram\&.cpp\&.
.SS "\fBBplot\fP * Bimage::histogram_poisson_fit (long bins, int flag = \fC0\fP)"

.PP
Fits a poisson function to a histogram of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIbins\fP number of bins in the histogram\&. 
.br
\fIflag\fP 1=plot\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bplot* plot of the histogram and the poisson fit\&. 
.PP
.nf
A histogram of an image is calculated with a given number of bins.
The histogram is fit to the Poisson function:
               lambda * exp(-lambda)
    f(x) = Amp ---------------------
                        x!
by first converting it to a linear form:
    ln(f(x)) = ln(Amp) + x*ln(lambda) - lambda - lgamma(x+1)
and then using the downhill simplex method to find the solution.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1390 of file Bimage_histogram\&.cpp\&.
.SS "int Bimage::histomatch (\fBBimage\fP * p, long bins)"

.PP
Fits two images by matching the histogram of the second to the first\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.br
\fIbins\fP number of bins in the histograms\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 if error\&. 
.PP
.nf
Both images are converted to floating point.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 615 of file Bimage_combine\&.cpp\&.
.SS "\fBBstring\fP& Bimage::identifier ()\fC [inline]\fP"

.PP
Definition at line 218 of file Bimage\&.h\&.
.SS "void Bimage::identifier (\fBBstring\fP s)\fC [inline]\fP"

.PP
Definition at line 217 of file Bimage\&.h\&.
.SS "long Bimage::image_size ()\fC [inline]\fP"

.PP
Definition at line 285 of file Bimage\&.h\&.
.SS "long Bimage::images ()\fC [inline]\fP"

.PP
Definition at line 507 of file Bimage\&.h\&.
.SS "void Bimage::images (long nn)"

.PP
Definition at line 369 of file Bimage\&.cpp\&.
.SS "int Bimage::images_to_channels (long nc, \fBCompoundType\fP ct)"

.SS "int Bimage::images_to_slices ()"

.PP
Changes the 2D images to slices in a 3D image\&. 
.PP
\fBReturns\fP
.RS 4
int error code (<0 means failure)\&. 
.RE
.PP

.PP
Definition at line 2152 of file Bimage\&.cpp\&.
.SS "int Bimage::impose_superpixels (\fBBimage\fP * pmask, vector< \fBBsuperpixel\fP > & seg, int impose)"

.PP
Impose superpixel features onto an image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP mask defining superpixels\&. 
.br
\fIseg\fP array of superpixels\&. 
.br
\fIimpose\fP flag to select feature 
.RE
.PP
\fBReturns\fP
.RS 4
0 \&. 
.PP
.nf
Features to select:
0   none
1   segment average
2   lowest neighboring segment
3   difference from lowest neighbor
4   higest neigboring segment
5   difference from highest neighbor

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1992 of file Bimage_segment\&.cpp\&.
.SS "long Bimage::index (long nc, long nx, long ny, long nz, long nn) const\fC [inline]\fP"

.PP
Definition at line 400 of file Bimage\&.h\&.
.SS "long Bimage::index (long nx, long ny) const\fC [inline]\fP"

.PP
Definition at line 391 of file Bimage\&.h\&.
.SS "long Bimage::index (long nx, long ny, long nz) const\fC [inline]\fP"

.PP
Definition at line 394 of file Bimage\&.h\&.
.SS "long Bimage::index (long nx, long ny, long nz, long nn) const\fC [inline]\fP"

.PP
Definition at line 397 of file Bimage\&.h\&.
.SS "long Bimage::index (\fBVector3\fP< long > vox, long nn) const\fC [inline]\fP"

.PP
Definition at line 403 of file Bimage\&.h\&.
.SS "long Bimage::index (vector< long > vox, long nn) const\fC [inline]\fP"

.PP
Definition at line 406 of file Bimage\&.h\&.
.SS "long Bimage::index_wrap (long nx, long ny, long nz) const\fC [inline]\fP"

.PP
Definition at line 409 of file Bimage\&.h\&.
.SS "long Bimage::index_wrap (\fBVector3\fP< long > coor) const\fC [inline]\fP"

.PP
Definition at line 418 of file Bimage\&.h\&.
.SS "long Bimage::index_wrap (vector< long > coor) const\fC [inline]\fP"

.PP
Definition at line 421 of file Bimage\&.h\&.
.SS "int Bimage::information ()"

.PP
Prints out header information for an image\&. 
.PP
\fBReturns\fP
.RS 4
int error code (<0 means failure)\&. 
.RE
.PP

.PP
Definition at line 2571 of file Bimage\&.cpp\&.
.SS "int Bimage::integer_interpolation (int integer_factor)"

.PP
Definition at line 16 of file Bimage_bin\&.cpp\&.
.SS "int Bimage::integer_interpolation (int integer_factor, int odd)"

.PP
Interpolates by an integer scale with a density-preserving overlapping kernel\&. 
.PP
\fBParameters\fP
.RS 4
\fIinteger_factor\fP integer interpolation factor\&. 
.br
\fIodd\fP flag to ensure the dimensions are odd\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
An image is interpolated by integer scaling (i.e., 2, 3, 4-fold or 
more) sometimes referred to as a form of binning.  A kernel is used
such that it overlaps with its neighbouring positions.  Voxels where
neighbouring kernel positions overlap contribute to 2, 4 or 8 new
voxels based on the number of overlapping kernel positions.  Only
the central voxel is unique to a kernel position.  The kernel is 
calculated as:
    w(i,j,k) = (1/s^2n)*(s-|s-1-i|)*(s-|s-1-j|)*(s-|s-1-k|)
where   s is the integer interpolation factor.
        n is the number of dimensions (1D, 2D or 3D).
The flag determines whether the dimensions are forced to be even or odd:
    0       No forcing
    1       x odd
    2       x even
    4       y odd
    8       y even
    16      z odd
    32      z even
    21      all odd
    42      all even
and any other combination.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 50 of file Bimage_bin\&.cpp\&.
.SS "\fBBimage\fP * Bimage::intensities_phase_colored (double scale)"

.PP
Generates a power spectrum with phases colored according to a color wheel\&. 
.PP
\fBParameters\fP
.RS 4
\fIscale\fP amplitude scaling\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* color power spectrum\&. 
.PP
.nf
A polar data type image (such as a Fourier transform) is converted
to indicate the phases as colors. The primary colors are located
0 degrees (red), 120 degrees (green) and -120 degrees (blue). All
three color values are down-weighted based on the amplitude. The
weighting is calculated as:
    weight = amplitude/(average+2*standard_deviation)
The origin specified in the image is used to shift the phases.
The scale is multiplied with the amplitude and cut off at one
to give the user the ability to enhance the image.
Default:
    scale = 1/(average_amplitude + standard_deviation_of_amplitude) 

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1428 of file Bimage_complex\&.cpp\&.
.SS "\fBBimage\fP * Bimage::internal_volume (double threshold)"

.PP
Calculates the internal volume of a shell\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP threshold to define density\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* internal volume mask\&. 
.RE
.PP

.PP
Definition at line 1009 of file Bimage_segment\&.cpp\&.
.SS "\fBBimage\fP * Bimage::internal_volume (double threshold, int mask_out_freq)"

.PP
Calculates the internal volume of a shell\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP threshold to define density\&. 
.br
\fImask_out_freq\fP mask output frequency\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* internal volume mask\&. 
.RE
.PP

.PP
Definition at line 1079 of file Bimage_segment\&.cpp\&.
.SS "double Bimage::interpolate (double xx, double yy = \fC0\fP, double zz = \fC0\fP, long nn = \fC0\fP, double fill = \fC0\fP) const\fC [inline]\fP"

.PP
Definition at line 327 of file Bimage\&.h\&.
.SS "double Bimage::interpolate (long cc, double xx, double yy = \fC0\fP, double zz = \fC0\fP, long nn = \fC0\fP, double fill = \fC0\fP) const"

.PP
Interpolates using a given location\&. 
.PP
\fBParameters\fP
.RS 4
\fIcc\fP channel\&. 
.br
\fIxx\fP x location\&. 
.br
\fIyy\fP y location\&. 
.br
\fIzz\fP z location\&. 
.br
\fInn\fP image number\&. 
.br
\fIfill\fP fill value if outside boundaries\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double interpolated value\&. 
.PP
.nf
Trilinear interpolation.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1423 of file Bimage\&.cpp\&.
.SS "double Bimage::interpolate (long cc, \fBVector3\fP< double > vec, long nn = \fC0\fP, double fill = \fC0\fP) const\fC [inline]\fP"

.PP
Definition at line 331 of file Bimage\&.h\&.
.SS "double Bimage::interpolate (\fBVector3\fP< double > vec, long nn = \fC0\fP, double fill = \fC0\fP) const\fC [inline]\fP"

.PP
Definition at line 335 of file Bimage\&.h\&.
.SS "double Bimage::interpolate (vector< double > vec, long nn = \fC0\fP, double fill = \fC0\fP) const\fC [inline]\fP"

.PP
Definition at line 339 of file Bimage\&.h\&.
.SS "int Bimage::interpolate_gaps (long step)"

.PP
Interpolate the voxels that are not calculated\&. 
.PP
\fBParameters\fP
.RS 4
\fIstep\fP step increment for voxels with proper values\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 if error\&. 
.PP
.nf
Sparse voxels calculated on a regular grid with the given step size are 
used to fill intermediate voxels with linearly interpolated values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1036 of file Bimage_edit\&.cpp\&.
.SS "double Bimage::interpolate_wrap (double xx, double yy = \fC0\fP, double zz = \fC0\fP, long nn = \fC0\fP) const\fC [inline]\fP"

.PP
Definition at line 345 of file Bimage\&.h\&.
.SS "double Bimage::interpolate_wrap (long cc, double xx, double yy = \fC0\fP, double zz = \fC0\fP, long nn = \fC0\fP) const"

.PP
Interpolates using a given location with wrapping\&. 
.PP
\fBParameters\fP
.RS 4
\fIcc\fP channel\&. 
.br
\fIxx\fP x location\&. 
.br
\fIyy\fP y location\&. 
.br
\fIzz\fP z location\&. 
.br
\fInn\fP image number\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double interpolated value\&. 
.PP
.nf
Trilinear interpolation with wrapping around periodic image boundaries.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1533 of file Bimage\&.cpp\&.
.SS "double Bimage::interpolate_wrap (long cc, \fBVector3\fP< double > vec, long nn = \fC0\fP) const\fC [inline]\fP"

.PP
Definition at line 349 of file Bimage\&.h\&.
.SS "double Bimage::interpolate_wrap (\fBVector3\fP< double > vec, long nn = \fC0\fP) const\fC [inline]\fP"

.PP
Definition at line 353 of file Bimage\&.h\&.
.SS "void Bimage::inverse (double minval = \fC0\fP)"

.PP
Calculates the inverse of the image\&. 
.PP
\fBParameters\fP
.RS 4
\fIminval\fP the minimum absolute value considered not zero\&. 
.PP
.nf
The inverse of every pixel is calculated.
If the minumum value is given as zero, zero pixels are retained.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3957 of file Bimage\&.cpp\&.
.SS "void Bimage::invert ()"

.PP
Inverts the data in the image\&. 
.PP
.nf
The Bit data type is negated.
An unsigned data type is subtracted from its type maximum.
A signed data type is negated.

.fi
.PP
 
.PP
Definition at line 3306 of file Bimage\&.cpp\&.
.SS "double Bimage::kernel_average (long idx, long ksize, double tmin, double tmax)"

.PP
Finds the highest value in a kernel\&. 
.PP
\fBParameters\fP
.RS 4
\fIidx\fP index in multi-image\&. 
.br
\fIksize\fP kernel edge half size\&. 
.br
\fItmin\fP miminum to exclude\&. 
.br
\fItmax\fP maximum to exclude 
.RE
.PP
\fBReturns\fP
.RS 4
double average value\&. 
.RE
.PP

.PP
Definition at line 3032 of file Bimage\&.cpp\&.
.SS "int Bimage::kernel_gaussian (double sigma, double max)"

.PP
Generates a gaussian kernel image\&. 
.PP
\fBParameters\fP
.RS 4
\fIsigma\fP gaussian width\&. 
.br
\fImax\fP kernel maximum\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 34 of file Bimage_filter\&.cpp\&.
.SS "\fBVector3\fP<long> Bimage::kernel_high (long i, long k = \fC1\fP)\fC [inline]\fP"

.PP
Definition at line 475 of file Bimage\&.h\&.
.SS "\fBVector3\fP<long> Bimage::kernel_high (long i, \fBVector3\fP< long > k)\fC [inline]\fP"

.PP
Definition at line 485 of file Bimage\&.h\&.
.SS "int Bimage::kernel_laplacian_of_gaussian (double sigma, double max)"

.PP
Generates a laplacian-of-gaussian kernel\&. 
.PP
\fBParameters\fP
.RS 4
\fIsigma\fP gaussian width\&. 
.br
\fImax\fP kernel maximum\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* kernel image\&. 
.RE
.PP

.PP
Definition at line 77 of file Bimage_filter\&.cpp\&.
.SS "\fBVector3\fP<long> Bimage::kernel_low (long i, long k = \fC1\fP)\fC [inline]\fP"

.PP
Definition at line 469 of file Bimage\&.h\&.
.SS "\fBVector3\fP<long> Bimage::kernel_low (long i, \fBVector3\fP< long > k)\fC [inline]\fP"

.PP
Definition at line 479 of file Bimage\&.h\&.
.SS "long Bimage::kernel_max (long idx, long ksize)"

.PP
Finds the highest value in a kernel\&. 
.PP
\fBParameters\fP
.RS 4
\fIidx\fP index in multi-image\&. 
.br
\fIksize\fP kernel edge half size 
.RE
.PP
\fBReturns\fP
.RS 4
long index of highest value\&. 
.RE
.PP

.PP
Definition at line 2998 of file Bimage\&.cpp\&.
.SS "long Bimage::kernel_max_neigbor (long idx, long ksize)"

.PP
Finds the highest value in a kernel excluding the central voxel\&. 
.PP
\fBParameters\fP
.RS 4
\fIidx\fP index in multi-image\&. 
.br
\fIksize\fP kernel edge half size 
.RE
.PP
\fBReturns\fP
.RS 4
long index of highest value\&. 
.RE
.PP

.PP
Definition at line 3069 of file Bimage\&.cpp\&.
.SS "long Bimage::kernel_max_wrap (long idx, long ksize)"

.PP
Finds the highest value in a kernel with wrapping\&. 
.PP
\fBParameters\fP
.RS 4
\fIidx\fP index in multi-image\&. 
.br
\fIksize\fP kernel edge half size 
.RE
.PP
\fBReturns\fP
.RS 4
long index of highest value\&. 
.RE
.PP

.PP
Definition at line 3103 of file Bimage\&.cpp\&.
.SS "long Bimage::kernel_min (long idx, long ksize)"

.PP
Finds the highest value in a kernel\&. 
.PP
\fBParameters\fP
.RS 4
\fIidx\fP index in multi-image\&. 
.br
\fIksize\fP kernel edge half size 
.RE
.PP
\fBReturns\fP
.RS 4
long index of highest value\&. 
.RE
.PP

.PP
Definition at line 2966 of file Bimage\&.cpp\&.
.SS "multimap< double, long > Bimage::kernel_order (long idx, long ksize)"

.PP
Orders the values in a kernel\&. 
.PP
\fBParameters\fP
.RS 4
\fIidx\fP index in multi-image\&. 
.br
\fIksize\fP kernel edge half size 
.RE
.PP
\fBReturns\fP
.RS 4
multimap<double,long> index of highest value\&. 
.RE
.PP

.PP
Definition at line 3144 of file Bimage\&.cpp\&.
.SS "multimap< double, long > Bimage::kernel_order_neighbors (long idx, long ksize)"

.PP
Orders the neigbor values in a kernel\&. 
.PP
\fBParameters\fP
.RS 4
\fIidx\fP index in multi-image\&. 
.br
\fIksize\fP kernel edge half size 
.RE
.PP
\fBReturns\fP
.RS 4
multimap<double,long> index of highest value\&. 
.RE
.PP

.PP
Definition at line 3172 of file Bimage\&.cpp\&.
.SS "\fBBimage\fP * Bimage::kmeans_segment (long nregion = \fC2\fP, long max_iter = \fC10\fP, double ratio = \fC1\fP)"

.PP
Segments an image based on K-means\&. 
.PP
\fBParameters\fP
.RS 4
\fInregion\fP number of regions\&. 
.br
\fImax_iter\fP maximum number of iterations\&. 
.br
\fIratio\fP balance between density and distance\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* segmentation mask\&. 
.PP
.nf
The metric to choose region membership is based on the minimum of:
    d = |<c>-c|/s + r|<v>-v|
for:
    c:      coordinates
    <c>:    region average coordinates.
    s:      image size.
    v:      density.
    <v>:    region average density.
    r:      ratio.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1200 of file Bimage_segment\&.cpp\&.
.SS "string& Bimage::label ()\fC [inline]\fP"

.PP
Definition at line 246 of file Bimage\&.h\&.
.SS "void Bimage::label (string s)\fC [inline]\fP"

.PP
Definition at line 245 of file Bimage\&.h\&.
.SS "void Bimage::largest (\fBBimage\fP * p)"

.PP
Selects the largest of each pixel from two images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP other image\&. 
.RE
.PP

.PP
Definition at line 3981 of file Bimage\&.cpp\&.
.SS "\fBBimage\fP * Bimage::level_mask_extract (\fBBimage\fP * pmask, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Extracts all the regions associated with a multi-level mask\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP multi-level mask map\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP value of edge voxels\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* image with excised regions\&. 
.PP
.nf
The feature index is found in a feature map and the corresponding voxels
in the density maps are extracted.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2035 of file Bimage_mask\&.cpp\&.
.SS "int Bimage::level_masked_stats (\fBBimage\fP * pmask)"

.PP
Caclulates statistics for all the regions defined by a multi-level mask\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP multi-level mask map\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The input data is replaced by the average for each region.
A linked image is created to hold the variance for each region.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1889 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::levelmask_add (\fBBimage\fP * pmask, int add_level = \fC1\fP)"

.PP
Adds a bilevel mask to a level mask\&. 
.PP
\fBParameters\fP
.RS 4
\fIpmask\fP bilevel mask to add\&. 
.br
\fIadd_level\fP the level index to add\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of selected regions\&. 
.PP
.nf
Where the bilevel mask is one, the level mask is set to given level value.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1579 of file Bimage_mask\&.cpp\&.
.SS "\fBBimage\fP * Bimage::levelmask_asymmetric_units (\fBBsymmetry\fP & sym, int index)"

.PP
Calculates a multi-level mask to indicate asymmetric units\&. 
.PP
\fBParameters\fP
.RS 4
\fI*sym\fP symmetry structure\&. 
.br
\fIindex\fP asu index (<1 means all)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* multi-level mask\&. 
.PP
.nf
A reference view for each point group is generated such that it is
located close to the center of the canonical asymmetric unit.
A set of symmetry-related reference views are then generated from 
the original reference.
The distance of each voxel is then calculated to each reference
view, and assigned to asymmetric unit with the closest reference view.
If the given index is larger than one, a mask is generated only for the
asymmetric unit with that index. 

.fi
.PP
 
.RE
.PP

.PP
Definition at line 899 of file Bimage_symmetry\&.cpp\&.
.SS "double Bimage::levelmask_average_region_size ()"

.PP
Calculates the average size of regions in a level mask\&. 
.PP
\fBReturns\fP
.RS 4
double average feature size\&. 
.RE
.PP

.PP
Definition at line 2063 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::levelmask_clean ()"

.PP
Removes empty levels from a multi-level mask\&. 
.PP
\fBReturns\fP
.RS 4
long 0\&. 
.PP
.nf
The mask is converted to an integer mask.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2102 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::levelmask_collapse ()"

.PP
Collapse a multi-level mask to a binary mask\&. 
.PP
\fBReturns\fP
.RS 4
long number of voxels retained\&. 
.PP
.nf
All non-zero segments are converted to ones.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1541 of file Bimage_mask\&.cpp\&.
.SS "\fBBimage\fP * Bimage::levelmask_color_by_size ()"

.PP
Color a multi-level mask based on the volumes of regions\&. 
.PP
\fBReturns\fP
.RS 4
Bimage* new colored image\&. 
.RE
.PP

.PP
Definition at line 2172 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::levelmask_colorize ()"

.PP
Colorizes a multi-level mask with random color assignments\&. 
.PP
\fBReturns\fP
.RS 4
long number of levels\&. 
.PP
.nf
A lookup table (LUT) is calculated for the range of gray-scale values
and random colors assigned to each value.
The image is then converted to RGB using the LUT.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2136 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::levelmask_combine (\fBBstring\fP & select_list)"

.PP
Combines the selected levels in a multi-level mask and renumber\&. 
.PP
\fBParameters\fP
.RS 4
\fI&select_list\fP comma_separated list of levels to select\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of voxels retained\&. 
.PP
.nf
The new data replaces the old data.
The result is a multi-level mask where the selected levels are combined into one.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1733 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::levelmask_dilate ()"

.PP
Dilates a level mask\&. 
.PP
\fBReturns\fP
.RS 4
long 0\&. 
.PP
.nf
Traditional 3^dim kernel dilation.  Any pixel with a value of 1 turns 
all of its neighbors to a value of 1.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1621 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::levelmask_dilate (int times)"

.PP
Dilates a level mask\&. 
.PP
\fBParameters\fP
.RS 4
\fItimes\fP number of dilation operations\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long 0\&. 
.PP
.nf
Traditional 3^dim kernel dilation.  Any pixel with a value of 1 turns 
all of its neighbors to a value of 1.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1603 of file Bimage_mask\&.cpp\&.
.SS "int Bimage::levelmask_region_size ()"

.PP
Convert a mask to reflect region sizes\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 2225 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::levelmask_select (\fBBimage\fP * pmask)"

.PP
Selects regions overlapping a mask\&. 
.PP
\fBParameters\fP
.RS 4
\fIpmask\fP overlap template mask\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of selected regions\&. 
.PP
.nf
The input mask can be of any form. All non-zero parts of this mask is used.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1816 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::levelmask_select (\fBBstring\fP & select_list, int flag = \fC0\fP)"

.PP
Retains the selected levels in a multi-level mask\&. 
.PP
\fBParameters\fP
.RS 4
\fI&select_list\fP comma_separated list of levels to select\&. 
.br
\fIflag\fP 0=binary mask, 1=multi-level mask\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of voxels retained\&. 
.PP
.nf
The new data replaces the old data.
The result is either a binary mask (flag=0) or a multi-level mask where
the level indices changed to reflect the new range of selected levels (flag=1).
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1691 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::levelmask_select (long nn, \fBVector3\fP< long > voxel)"

.PP
Retains the selected levels in a multi-level mask\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number\&. 
.br
\fIvoxel\fP voxel with level to select\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of voxels retained\&. 
.PP
.nf
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1781 of file Bimage_mask\&.cpp\&.
.SS "\fBBplot\fP * Bimage::levelmask_size_histogram ()"

.PP
Color a multi-level mask based on the volumes of regions\&. 
.PP
\fBReturns\fP
.RS 4
Bplot* region size histogram\&. 
.RE
.PP

.PP
Definition at line 2256 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::levelmask_switch (long index1, long index2)"

.PP
Switches two segments in a multi-level mask\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex1\fP first index\&. 
.br
\fIindex2\fP second index\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of levels\&. 
.PP
.nf
If the two indices are not found, the mask is not modified.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1863 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::levelmask_symmetrize (\fBBsymmetry\fP & sym)"

.PP
Symetrizes a multi-level mask\&. 
.PP
\fBParameters\fP
.RS 4
\fIsym\fP point group symmetry\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long maximum level index\&. 
.RE
.PP

.PP
Definition at line 1941 of file Bimage_mask\&.cpp\&.
.SS "int Bimage::limit_levels (int nlevels)"

.PP
Converts a full gray scale image to a limited level image\&. 
.PP
\fBParameters\fP
.RS 4
\fInlevels\fP number of levels\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The dynamic range of the image is decreased to a given number of gray
scale levels.
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 426 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::line (\fBVector3\fP< double > start, \fBVector3\fP< double > end, double width, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Creates a line in an image and fills it with a constant value\&. 
.PP
\fBParameters\fP
.RS 4
\fIstart\fP three-value start of line\&. 
.br
\fIend\fP three-value end of line\&. 
.br
\fIwidth\fP gaussian width of smoothing function\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The edge of the area is smoothed with a function:
                    v_old(x,y,z) + fill*exp(1.618*dist/width)
    v_new(x,y,z) = ------------------------------------------
                           1 + exp(1.618*dist/width)
where   fill is the constant fill value.
        dist is the distance to the rectangular boundary defined by
            the input size and start
        width is the gaussian width (softness)
With very small values of the gaussian width, the edge approaches a
step function.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 234 of file Bimage_edit\&.cpp\&.
.SS "int Bimage::line_powerspectra (\fBfft_plan\fP plan)"

.PP
Calculates the 1D power spectrum of each line in an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIplan\fP fft plan\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
Each line is transformed to a power spectrum in place.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 811 of file Bimage_polar\&.cpp\&.
.SS "double Bimage::linear_fit (\fBBimage\fP * p, \fBBimage\fP * pmask, double max_exclude)"

.PP
Linear least squares fit of two images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.br
\fI*pmask\fP mask to limit calculation to a certain region\&. 
.br
\fImax_exclude\fP maximum percentage of outlying points to exclude\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double first R factor\&. 
.PP
.nf
The data blocks from two images are fit by a simple linear least squares
regression algorithm with exclusion of a percentage of outliers:
    image2 = intercept + slope * image1
The first image is modified to return the difference:
    difference = intercept + slope * image1 - image2
The residual returned is:
    R = sqrt(sum(difference^2) / sum((image2-avg2)^2))
Note: A linear fit is not symmetric with respect to the two input
data sets - the order of the input images determine the output.
The two data blocks must have the same size and are converted to
floating point.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 477 of file Bimage_combine\&.cpp\&.
.SS "\fBBimage\fP * Bimage::local_filter (\fBBimage\fP * pmask, int mask_level, \fBBimage\fP * resmap, int size, \fBVector3\fP< long > vedge)"

.PP
Applies a local resolution filter to a map\&. 
.PP
\fBAuthor\fP
.RS 4
Giovanni Cardone and Bernard Heymann 
.RE
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP mask of areas to generate\&. 
.br
\fImask_level\fP mask level\&. 
.br
\fI*resmap\fP local resolution map\&. 
.br
\fIsize\fP kernel size\&. 
.br
\fIvedge\fP edge size\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* filtered image, NULL on error\&. 
.PP
.nf
At each voxel, a kernel/small box is extracted and lowpass filtered
to the resolution limit for that voxel in the local resolution map.
A mask may be used to limit the region of application.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 782 of file Bimage_resolution\&.cpp\&.
.SS "void Bimage::logarithm ()"

.PP
Calculates the logarithm of the image data\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is first converted to floating point, or intensities
for complex data. The logarithm is calculated to place the minmum at
zero and scale it to the standard deviation:
                data - min
    new_data = log ------------- + 1
                   std
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 725 of file Bimage_rescale\&.cpp\&.
.SS "long Bimage::mask (\fBBimage\fP * pmask, double fill)"

.PP
Masks an image\&. 
.PP
\fBAuthor\fP
.RS 4
Samuel Payne 
.RE
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP binary mask\&. 
.br
\fIfill\fP value to use where mask is zero\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long 0\&. 
.PP
.nf
If the mask value for that pixel is 0, the image pixel is changed
to the fill value.  Otherwise it is left alone.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 26 of file Bimage_mask\&.cpp\&.
.SS "\fBBimage\fP * Bimage::mask_by_conditional_thresholds (vector< double > threshold)"

.PP
Generates a mask based on a conditional hierarchy of thresholds\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP array of gray scale levels\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* unsigned char mask\&. 
.PP
.nf
A multi-level mask is generated using the given threshold values.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 166 of file Bimage_mask\&.cpp\&.
.SS "\fBBimage\fP * Bimage::mask_by_threshold (double threshold)"

.PP
Generates a mask based on an image at a given threshold\&. 
.PP
\fBAuthor\fP
.RS 4
Samuel Payne & Bernard Heymann 
.RE
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP gray scale level\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* unsigned char mask\&. 
.PP
.nf
A binary mask is generated using the given threshold.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 93 of file Bimage_mask\&.cpp\&.
.SS "\fBBimage\fP * Bimage::mask_by_thresholds (vector< double > threshold)"

.PP
Generates a mask based on an image at given thresholds\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP array of gray scale levels\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* unsigned char mask\&. 
.PP
.nf
A multi-level mask is generated using the given threshold values.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 129 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_close (int times = \fC1\fP)"

.PP
Closes a binary mask\&. 
.PP
\fBParameters\fP
.RS 4
\fItimes\fP the number of times to dilate and erode the mask\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long masked voxels\&. 
.PP
.nf
Closing a mask is a dilation followed by an erosion.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 521 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_combine (\fBBimage\fP * p, int operation)"

.PP
Combines two masks with different operations\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second mask\&. 
.br
\fIoperation\fP combining operation\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* unsigned char mask\&. 
.PP
.nf
The input images are assumed to be a masks of 0's and 1's and are
modified according to the operation requested:
    0   val1 = val2
    1   val1 = val1 and val2
    2   val1 = val1 or  val2
    3   val1 = val1 xor val2
where val1 and val2 are the data in the two images. 
Image statistics of the first image are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 295 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_dilate (long times = \fC1\fP)"

.PP
Dilates a binary mask\&. 
.PP
\fBAuthor\fP
.RS 4
Samuel Payne & Bernard Heymann 
.RE
.PP
\fBParameters\fP
.RS 4
\fItimes\fP the number of times to dilate the mask\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long masked voxels\&. 
.PP
.nf
Traditional 3^dim kernel dilation.  Any pixel with a value of 1 turns 
all of its neighbors to a value of 1.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 463 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_dilate_erode (unsigned char dir)"

.PP
Dilates or erodes a binary mask\&. 
.PP
\fBAuthor\fP
.RS 4
Samuel Payne & Bernard Heymann 
.RE
.PP
\fBParameters\fP
.RS 4
\fIdir\fP 0=erode, 1=dilate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long masked voxels\&. 
.PP
.nf
Traditional 3^dim kernel dilation.  Any pixel with a value of 1 turns 
all of its neighbors to a value of 1.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 406 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_erode (long times = \fC1\fP)"

.PP
Erodes a binary mask\&. 
.PP
\fBAuthor\fP
.RS 4
Samuel Payne & Bernard Heymann 
.RE
.PP
\fBParameters\fP
.RS 4
\fItimes\fP the number of times to erode the mask 
.RE
.PP
\fBReturns\fP
.RS 4
long masked voxels\&. 
.PP
.nf
Traditional 3^dim kernel erosion.  If all the neighboring pixels have
value of 1, then that pixel is left at 1. Otherwise it is changed to 0.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 483 of file Bimage_mask\&.cpp\&.
.SS "\fBBimage\fP * Bimage::mask_extract (\fBBimage\fP * pmask)"

.PP
Zeroes everything outside the mask and return the excised feature\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP mask\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* excised feature\&. 
.PP
.nf
The mask must be the same size as the image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 333 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_fill (\fBVector3\fP< long > voxel)"

.PP
Fills an empty part of a mask indicated by the given voxel\&. 
.PP
\fBParameters\fP
.RS 4
\fIvoxel\fP point from which to fill the mask\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long masked voxels\&. 
.RE
.PP

.PP
Definition at line 539 of file Bimage_mask\&.cpp\&.
.SS "int Bimage::mask_fspace_banded (vector< double > & band)"

.PP
Generate reciprocal space mask based on a specification of bands\&. 
.PP
\fBParameters\fP
.RS 4
\fI&band\fP array of number pairs, each a shell and value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The band argument is a list of pairs of values, each pair indicating
a resolution shell (in angstrom) and a flag indicating whether the 
following shells should be:
    0: excluded - also the high resolution limit
    1: included in the FOM
    -1: included in the cross-validation FOM
The high resolution limit for the mask is set in the image structure.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 849 of file Bimage_mask\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::mask_fspace_resize (\fBVector3\fP< long > nusize)"

.PP
Resizes a reciprocal space mask\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP new mask size\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBVector3<double>\fP scale\&. 
.PP
.nf
The mask is assumed to be centered at (0,0,0).
The image is resized by inserting or removing
rows or columns in the middle of the data set.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 725 of file Bimage_mask\&.cpp\&.
.SS "\fBMatrix\fP Bimage::mask_interface_matrix (int img_num)"

.PP
Calculates the interfaces between regions\&. 
.PP
\fBParameters\fP
.RS 4
\fIimg_num\fP sub-image number\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBMatrix\fP interface matrix\&. 
.PP
.nf
The mask must be an integer image.
An interface matrix is calculated to count the number of connected
voxels between every pair of regions.
Each value i in a row j gives the number of voxels of the region j that
are adjacent to one or more voxels in region i.
Row 0 and column 0 are excluded from the calculation.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2339 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_invert ()"

.PP
Inverts a mask\&. 
.PP
\fBReturns\fP
.RS 4
long number of mask voxels\&. 
.PP
.nf
The mask is assumed to be in range [0,1].
    new_mask = 1 - old_mask.
Image statistics of the mask are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 260 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_merge_delete (long min_size, long min_if)"

.PP
Calculates the interfaces between regions and deletes/merges small ones\&. 
.PP
\fBParameters\fP
.RS 4
\fImin_size\fP minimum size to accept regions, small ones are deleted/merged\&. 
.br
\fImin_if\fP minimum interface size to consider a small region connected\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long 0\&. 
.PP
.nf
The mask is converted to an integer mask.
An interface matrix is calculated to count the number of connected
voxels between every pair of regions.
Regions that are smaller than the minimum size are either deleted or
merged with other regions.
If the maximum interface size for a small region is less than the minimum
specified, the region is deleted, otherwise, it is added to that
neighboring region with which it shares the biggest interface.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2457 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_missing_cone (\fBVector3\fP< double > ori, double mis_ang, double resolution)"

.PP
Generates a mask with a missing cone\&. 
.PP
\fBParameters\fP
.RS 4
\fIori\fP image origin\&. 
.br
\fImis_ang\fP cone angle from xy plane\&. 
.br
\fIresolution\fP high resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of mask voxels\&. 
.PP
.nf
The given image is used to generate a binary mask of the same size.
If the input origin is {0,0,0}, the origin in the image is used as 
the center for the missing part.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1105 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_missing_find (\fBVector3\fP< double > ori, double resolution, \fBBstring\fP & mis_type)"

.PP
Generates a missing mask from an example image\&. 
.PP
\fBParameters\fP
.RS 4
\fIori\fP image origin\&. 
.br
\fIresolution\fP high resolution limit\&. 
.br
\fImis_type\fP missing region type: wedge\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of mask voxels\&. 
.PP
.nf
The given image is used to generate a binary mask of the same size.
If the input origin is {0,0,0}, the origin in the image is used as 
the center for the missing part.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1178 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_missing_pyramid (\fBVector3\fP< double > ori, double tilt_axis1, double tilt_axis2, double tilt_neg1, double tilt_pos1, double tilt_neg2, double tilt_pos2, double resolution)"

.PP
Generates a mask with a missing pyramid\&. 
.PP
\fBParameters\fP
.RS 4
\fIori\fP image origin\&. 
.br
\fItilt_axis1\fP tilt axis angle 1\&. 
.br
\fItilt_axis2\fP tilt axis angle 2\&. 
.br
\fItilt_neg1\fP negative tilt angle for axis 1\&. 
.br
\fItilt_pos1\fP positive tilt angle for axis 1\&. 
.br
\fItilt_neg2\fP negative tilt angle for axis 2\&. 
.br
\fItilt_pos2\fP positive tilt angle for axis 2\&. 
.br
\fIresolution\fP high resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of mask voxels\&. 
.PP
.nf
The given image is used to generate a binary mask of the same size.
If the input origin is {0,0,0}, the origin in the image is used as 
the center for the missing part.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1017 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_missing_wedge (\fBVector3\fP< double > ori, double tilt_axis, double tilt_neg, double tilt_pos, double resolution)"

.PP
Generates a mask with a missing wedge\&. 
.PP
\fBParameters\fP
.RS 4
\fIori\fP image origin\&. 
.br
\fItilt_axis\fP tilt axis angle\&. 
.br
\fItilt_neg\fP negative tilt angle\&. 
.br
\fItilt_pos\fP positive tilt angle\&. 
.br
\fIresolution\fP high resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of mask voxels\&. 
.PP
.nf
The given image is used to generate a binary mask of the same size.
If the input origin is {0,0,0}, the origin in the image is used as 
the center for the missing part.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 934 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_open (int times = \fC1\fP)"

.PP
Opens a binary mask\&. 
.PP
\fBParameters\fP
.RS 4
\fItimes\fP the number of times to erode and dilate the mask\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long masked voxels\&. 
.PP
.nf
Opening a mask is an erosion followed by a dilation.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 501 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_pack_plane (\fBMatrix3\fP mat, double hi_res, double scale)"

.PP
Packs a 2D mask into a 3D reciprocal space volume\&. 
.br
 
.PP
\fBParameters\fP
.RS 4
\fImat\fP affine orientation matrix\&. 
.br
\fIhi_res\fP high resolution limit\&. 
.br
\fIscale\fP scale\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long 0\&. 
.PP
.nf
The rotation matrix is used to determine the plane in reciprocal space
to set as one.
Both the high resolution limit and the scale must correspond to the 
associated reconstruction.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1285 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_plane (\fBVector3\fP< double > origin, \fBVector3\fP< double > normal)"

.PP
Generates a mask on one side of a plane\&. 
.PP
\fBParameters\fP
.RS 4
\fIorigin\fP any point on plane\&. 
.br
\fInormal\fP plane normal\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long 0\&. 
.PP
.nf
The given image is used to generate a binary mask of the same size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 553 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_rectangle (double length, double width, double rect_angle, int wrap)"

.PP
Generates a mask along an axis within a 2D image\&. 
.PP
\fBParameters\fP
.RS 4
\fIlength\fP length along axis (pixels)\&. 
.br
\fIwidth\fP width perpendicular to axis (pixels)\&. 
.br
\fIrect_angle\fP angle from x-axis (radians)\&. 
.br
\fIwrap\fP flag to wrap around boundaries\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long 0\&. 
.PP
.nf
The input image is assumed to be a mask of 0's and 1's and is modified
according to the operation requested.
Only an axis in the xy plane is used, generating a rectangular mask
of given length and width around the axis, with its center at the
origins given in the image structure.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 608 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_region_interfaces (int reg_num)"

.PP
Reports the whole interface matrix or interfaces for one region only\&. 
.PP
\fBParameters\fP
.RS 4
\fIreg_num\fP region to report for (<0 whole interface matrix)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long 0\&. 
.PP
.nf
The mask is converted to an integer mask.
An interface matrix is calculated to count the number of connected
voxels between every pair of regions.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2406 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_shell (\fBVector3\fP< double > origin, double rad_min, double rad_max)\fC [inline]\fP"

.PP
Definition at line 1382 of file Bimage\&.h\&.
.SS "long Bimage::mask_split (long voxels_per_level)"

.PP
Converts a mask to a multilevel mask with a given number of voxels per level\&. 
.PP
\fBParameters\fP
.RS 4
\fIvoxels_per_level\fP number of voxels per level\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of voxels retained\&. 
.PP
.nf
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1491 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_stats ()"

.PP
Calculates statistics for a mask\&. 
.PP
\fBReturns\fP
.RS 4
long voxels in positive levels\&. 
.PP
.nf
The mask can be any type, but the regions in the mask are rounded to
the nearest integer for counting statistics.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 205 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::mask_symmetrize (\fBBsymmetry\fP & sym)"

.PP
Symetrizes a mask\&. 
.PP
\fBParameters\fP
.RS 4
\fIsym\fP point group symmetry\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long maximum level index\&. 
.RE
.PP

.PP
Definition at line 660 of file Bimage_mask\&.cpp\&.
.SS "double Bimage::mass_at_threshold (long img_num, double threshold, double rho)"

.PP
Calculates the mass from the density threshold\&. 
.PP
\fBParameters\fP
.RS 4
\fIimg_num\fP sub-image number (first = 0)\&. 
.br
\fIthreshold\fP density threshold\&. 
.br
\fIrho\fP protein density in Da/A3\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double threshold\&. 
.PP
.nf
An image is assumed to have density represented by higher (white) values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 979 of file Bimage_segment\&.cpp\&.
.SS "double Bimage::mass_threshold (long img_num, double mol_weight, double rho)"

.PP
Finds the density threshold associated with a particular molecular weight\&. 
.PP
\fBParameters\fP
.RS 4
\fIimg_num\fP sub-image number (first = 0,)\&. 
.br
\fImol_weight\fP molecular weight\&. 
.br
\fIrho\fP protein density in Da/A3\&. 
.RE
.PP
\fBReturns\fP
.RS 4
float threshold\&. 
.PP
.nf
A threshold value is determined which contour a density such that
it corresponds to 100% of the given molecular weight.
An image is assumed to have density represented by higher (white) values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 890 of file Bimage_segment\&.cpp\&.
.SS "int Bimage::max_in_kernel (long ksize)"

.PP
Definition at line 348 of file Bimage_mask\&.cpp\&.
.SS "double Bimage::maximum ()\fC [inline]\fP"

.PP
Definition at line 545 of file Bimage\&.h\&.
.SS "void Bimage::maximum (double d)\fC [inline]\fP"

.PP
Definition at line 550 of file Bimage\&.h\&.
.SS "double Bimage::maximum_included_radius ()"

.PP
Returns the radius of the enclosed sphere or circle\&. 
.PP
\fBReturns\fP
.RS 4
double radius of largest sphere that will fit in an image\&. 
.PP
.nf
Returns the radius of the largest sphere or circle that will fit
inside a three- or two-dimensional image, respectively, or the 
midpoint of a one-dimensional image.
Assumes that the x, y, and z dimensions are the number of data points
in those respective directions, and that the length (in pixels)
of the respective dimensions is x, y, or z minus one.  The minimum 
length is two times the radius of the largest sphere that will fit 
inside the image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2095 of file Bimage\&.cpp\&.
.SS "int Bimage::median_bin (int binning)"

.PP
Bins by an integer size, selecting the kernel median\&. 
.PP
\fBParameters\fP
.RS 4
\fIbinning\fP integer bin factor\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
An image is binned by an integer size, square in 2D and cubic in 3D.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 393 of file Bimage_bin\&.cpp\&.
.SS "double Bimage::merge_amplitudes_and_phases (\fBBimage\fP * pamp)"

.PP
Merges the amplitudes from one map with the phases of another\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pamp\fP amplitude image (simple or complex)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double RMSD of amplitudes\&. 
.PP
.nf
The amplitude image can be a floating point image or a complex image.
The phase image must be complex and its amplitudes are replaced by
the values from the amplitude image.
No statistics are calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1288 of file Bimage_complex\&.cpp\&.
.SS "double Bimage::merge_amplitudes_and_phases (\fBBimage\fP * pref, double res_hi, double res_lo)"

.PP
Keeps selected phases and replaces amplitudes and other phases from a reference transform\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pref\fP reference Fourier transform\&. 
.br
\fIres_hi\fP high resolution limit\&. 
.br
\fIres_lo\fP low resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double RMSD of amplitudes\&. 
.PP
.nf
The input transform is considered to be modified in some way (such as solvent flattening).
Only the phases in the specified resolution shell are kept, while all
the other phases and amplitudes within the high resolution limit is
retrieved from the reference transform.
No statistics are calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1336 of file Bimage_complex\&.cpp\&.
.SS "\fBJSvalue\fP& Bimage::meta_data ()\fC [inline]\fP"

.PP
Definition at line 220 of file Bimage\&.h\&.
.SS "void Bimage::meta_data_retain_one_image (long img_num)"

.PP
Erases all sub-image records from the meta data except one\&. 
.PP
\fBParameters\fP
.RS 4
\fIimg_num\fP sub-image number\&. 
.RE
.PP

.PP
Definition at line 780 of file Bimage\&.cpp\&.
.SS "void Bimage::meta_data_update ()"

.PP
Update metadata from the sub-image information\&. 
.PP
.nf
The sub-image information is encoded in the metadata in JSON format.

.fi
.PP
 
.PP
Definition at line 687 of file Bimage\&.cpp\&.
.SS "double Bimage::minimum ()\fC [inline]\fP"

.PP
Definition at line 544 of file Bimage\&.h\&.
.SS "void Bimage::minimum (double d)\fC [inline]\fP"

.PP
Definition at line 549 of file Bimage\&.h\&.
.SS "int Bimage::mirror ()"

.PP
Inverts/mirrors each image through its origin\&. 
.PP
\fBReturns\fP
.RS 4
int number of images\&. 
.PP
.nf
Each image in a Bimage structure is inverted.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 563 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::moments (long max_order)"

.PP
Prints out moments for all sub-images\&. 
.PP
\fBReturns\fP
.RS 4
int error code (<0 means failure)\&. 
.RE
.PP

.PP
Definition at line 2670 of file Bimage\&.cpp\&.
.SS "int Bimage::moments (long max_order, long nn)"

.PP
Prints out moments for one sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fImax_order\fP maximum order\&. 
.br
\fInn\fP sub-image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code (<0 means failure)\&. 
.RE
.PP

.PP
Definition at line 2687 of file Bimage\&.cpp\&.
.SS "\fBBimage\fP * Bimage::montage (int first, int cols, int rows, int skip = \fC0\fP, int flip = \fC0\fP)"

.PP
Rearranges an image into a montage of 2D slices for display\&. 
.PP
\fBParameters\fP
.RS 4
\fIcols\fP columns in montage\&. 
.br
\fIrows\fP rows in montage\&. 
.br
\fIfirst\fP first slice in montage\&. 
.br
\fIskip\fP number of slices to skip\&. 
.br
\fIflip\fP flip the order of panels on: 1=x axis, 2=y axis\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* montaged image\&. 
.PP
.nf
The slices of a 3D image are packed into a 2D montage.
The background value for the image is used for empty regions.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 49 of file Bimage_montage\&.cpp\&.
.SS "\fBBimage\fP * Bimage::moving_sum (long window, long step = \fC1\fP, int flag = \fC0\fP)"

.PP
Calculates a moving sum of the sub-images\&. 
.PP
\fBParameters\fP
.RS 4
\fIwindow\fP number of successive images to sum\&. 
.br
\fIstep\fP intervals between windows\&. 
.br
\fIflag\fP if set, calculate average\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* moving sum/average image\&. 
.PP
.nf
Each successive subset of sub-images of size set by the window parameter are summed.
Where the window extends beyond the limits for the number of images,
the summation is just over the existing images.
The number of images depends on the step size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3583 of file Bimage\&.cpp\&.
.SS "void Bimage::multi_channel_to_complex ()"

.PP
A multi-channel image is converted to a set of complex images\&. 
.PP
.nf
The input image channels are written into the real part of the complex image.

.fi
.PP
 
.PP
Definition at line 53 of file Bimage_complex\&.cpp\&.
.SS "void Bimage::multiply (\fBBimage\fP * p)"

.PP
Multiplies all sub-images with the first sub-image of the other image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP image multiplier\&. 
.PP
.nf
The other image is multiplied with the first.
Both images are converted to floating point.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3822 of file Bimage\&.cpp\&.
.SS "void Bimage::multiply (\fBBimage\fP * p, double scale, double shift = \fC0\fP)"

.PP
Multiplies an image with another image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP image multiplier\&. 
.br
\fIscale\fP density scale to other image 
.br
\fIshift\fP density shift to other image\&. 
.PP
.nf
Requirement: The images must have the same size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3777 of file Bimage\&.cpp\&.
.SS "void Bimage::multiply (double v)"

.PP
Multiplies an image with a constant value\&. 
.PP
\fBParameters\fP
.RS 4
\fIv\fP constant multiplier\&. 
.RE
.PP

.PP
Definition at line 3450 of file Bimage\&.cpp\&.
.SS "void Bimage::multiply (long j, \fBComplex\fP< double > cv)\fC [inline]\fP"

.PP
Definition at line 320 of file Bimage\&.h\&.
.SS "void Bimage::multiply (long nn, \fBBimage\fP * p)"

.PP
Multiplies a sub-image with another image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image to multiply\&. 
.br
\fI*p\fP image multiplier\&. 
.PP
.nf
Requirement: The images must have the same size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3802 of file Bimage\&.cpp\&.
.SS "void Bimage::multiply (long nn, double v)"

.PP
Multiplies a sub-image with a constant value\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fIv\fP constant multiplier\&. 
.RE
.PP

.PP
Definition at line 3471 of file Bimage\&.cpp\&.
.SS "\fBBimage\fP * Bimage::nad (double ht, long zw, double lambda, double C, double alpha)"

.PP
Denoises a 3D density map by non-linear anisotropic diffusion\&. 
.PP
\fBParameters\fP
.RS 4
\fIht\fP time step size, 0 < ht <= 0\&.25\&. 
.br
\fIzw\fP slab size for piece-wise denoising\&. 
.br
\fIlambda\fP lamda parameter for EED\&. 
.br
\fIC\fP coherence parameter for CED\&. 
.br
\fIalpha\fP \&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new image\&. 
.PP
.nf
The diffusion tensor is calculated with the aim of enhancing edges (EED)
or planes (CED).

.fi
.PP
 
.RE
.PP

.PP
Definition at line 580 of file Bimage_nad\&.cpp\&.
.SS "\fBBimage\fP * Bimage::nad_2D (double ht, double lambda, double C, double alpha)"

.PP
Denoises a 2D image by non-linear anisotropic diffusion\&. 
.PP
\fBParameters\fP
.RS 4
\fIht\fP time step size, 0 < ht <= 0\&.25\&. 
.br
\fIlambda\fP lamda parameter for EED\&. 
.br
\fIC\fP coherence parameter for CED\&. 
.br
\fIalpha\fP \&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new image\&. 
.PP
.nf
The diffusion tensor is calculated with the aim of enhancing edges (EED)
or planes (CED).

.fi
.PP
 
.RE
.PP

.PP
Definition at line 554 of file Bimage_nad\&.cpp\&.
.SS "int Bimage::noise_gaussian (double ravg = \fC0\fP, double rstd = \fC1\fP)"

.PP
Generates an image with a gaussian random distribution of densities\&. 
.PP
\fBParameters\fP
.RS 4
\fIravg\fP average\&. 
.br
\fIrstd\fP standard deviation\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
An image with a given datatype, number of subimages, and size is
generated with densities with a gaussian distribution with a given
average and standard deviation:
    density = average + std_dev*sqrt(-2*log(random_value))*
                    cos(2*PI*random_value);
where random_value is between 0 and 1.
The output image is floating point.
Statistics are calculated before returning.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 72 of file Bimage_noise\&.cpp\&.
.SS "int Bimage::noise_logistical (double ravg, double rstd)"

.PP
Generates an image with a gaussian random distribution of densities\&. 
.PP
\fBParameters\fP
.RS 4
\fIravg\fP average\&. 
.br
\fIrstd\fP standard deviation\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
An image with a given datatype, number of subimages, and size is
generated with densities with a logistical differential distribution 
with a given average and standard deviation:
    density = average + (std_dev/golden)*ln(1/random_value - 1)
where random_value is between 0 and 1 and:
    golden  = (sqrt(5) + 1)/2
The output image is floating point.
Statistics are calculated before returning.

.fi
.PP
 Reference: Press W\&.H\&. et al (1992) Numerical Recipes in C\&. 
.RE
.PP

.PP
Definition at line 156 of file Bimage_noise\&.cpp\&.
.SS "int Bimage::noise_poisson (double ravg)"

.PP
Generates an image with a poisson random distribution of densities\&. 
.PP
\fBParameters\fP
.RS 4
\fIravg\fP average\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
Algorithm taken from Numerical Recipes in C.
The poisson distribution is given for j = 0,1,... by:
            avg^j * exp(-avg)
    P(j) = -----------------
                   j!
Note that only positive integer values are defined for j and sum(P(j)) = 1.
An array of floating point numbers is generated with a poisson 
distribution with a given average. The standard deviation is:
    std = sqrt(avg)
If the average <= 0, the function exits.
Statistics are calculated before returning.

.fi
.PP
 Reference: Press W\&.H\&. et al (1992) Numerical Recipes in C\&. 
.RE
.PP

.PP
Definition at line 115 of file Bimage_noise\&.cpp\&.
.SS "int Bimage::noise_spectral (double alpha)"

.PP
Generates a noise map with a defined spectral decay\&. 
.PP
\fBParameters\fP
.RS 4
\fIalpha\fP spectral decay\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
Uniform random phases are generated and the amplitudes are set to:
    amp = s^(-alpha/2).

.fi
.PP
 
.RE
.PP

.PP
Definition at line 184 of file Bimage_noise\&.cpp\&.
.SS "int Bimage::noise_uniform (double rmin, double rmax)"

.PP
Generates an image with a uniform random distribution of densities\&. 
.PP
\fBParameters\fP
.RS 4
\fIrmin\fP minimum density value\&. 
.br
\fIrmax\fP maximum density value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
An image with a given datatype, number of subimages, and size is
generated with densities distributed uniformly in the range of the
given minimum and maximum:
    density = random_value*(max - min) + min
where random_value is between 0 and 1.
The average and standard deviation are:
    average = (max + min)/2
    standard deviation = 0.5*sqrt(1/3)*(max - min).
The output image is floating point.
Statistics are calculated before returning.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 34 of file Bimage_noise\&.cpp\&.
.SS "int Bimage::normalize (double average, double stdev, int norm_type)"

.PP
Normalizes a set of images to a desired average and standard deviation\&. 
.PP
\fBParameters\fP
.RS 4
\fIaverage\fP desired average\&. 
.br
\fIstdev\fP desired standard deviation (if 0, use defaults)\&. 
.br
\fInorm_type\fP type of determining the effective average and standard deviation: 0=simple, 1=Gaussian, 2=Poisson\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The effective average and standard deviation for each image is obtained
in one of three ways:
    0.      The simple avergae and standard devaition for the image.
    1.      Gaussian fit of the histogram.
    2.      Poisson fit of the histogram.
A histogram of an image is calculated with a given number of bins.
The histogram is fit to a Gaussian or Poisson function with exclusion of a
small number of bins in the histogram (defined as outliers).
The effective average and standard deviation are used to 
rescale the data for each image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 536 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::normalize (long imgnum, double average, double stdev, int norm_type, long bins)"

.PP
Normalizes a sub-image to a desired average and standard deviation\&. 
.PP
\fBParameters\fP
.RS 4
\fIimgnum\fP sub-image number\&. 
.br
\fIaverage\fP desired average\&. 
.br
\fIstdev\fP desired standard deviation (if 0, use defaults)\&. 
.br
\fInorm_type\fP type of determining the effective average and standard deviation: 0=simple, 1=Gaussian, 2=Poisson\&. 
.br
\fIbins\fP number of histogram bins required to fit distributions\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The effective average and standard deviation for each image is obtained
in one of three ways:
    0.      The simple avergae and standard devaition for the image.
    1.      Gaussian fit of the histogram.
    2.      Poisson fit of the histogram.
A histogram of an image is calculated with a given number of bins.
The histogram is fit to a Gaussian or Poisson function with exclusion of a
small number of bins in the histogram (defined as outliers).
The effective average and standard deviation are used to 
rescale the data for each image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 481 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::normalize_local (long kernel_size)"

.PP
Normalizes by subtracting local average and dividing by local standard deviation\&. 
.PP
\fBParameters\fP
.RS 4
\fIkernel_size\fP size of kernel edge\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The local average and standard deviation within a kernel is calculated 
and used to normalize the image.
The convolution is threaded if compiled with GCD or OpenMP.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 608 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::normalize_local (\fBVector3\fP< long > kernel)"

.PP
Normalizes by subtracting local average and dividing by local standard deviation\&. 
.PP
\fBParameters\fP
.RS 4
\fIkernel\fP size of kernel edge\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The local average and standard deviation within a kernel is calculated 
and used to normalize the image.
The convolution is threaded if compiled with GCD or OpenMP.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 625 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::one_color (int color, double cmin, double cmax, int flag = \fC0\fP)"

.PP
Converts a gray-scale image to a single color\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolor\fP color selection (0=red, 1=green, 2=blue)\&. 
.br
\fIcmin\fP lower grayscale boundary\&. 
.br
\fIcmax\fP upper grayscale boundary\&. 
.br
\fIflag\fP sets the type of conversion\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
A grayscale image is converted to a selected color between the given minimum and maximum.
The flag parameter bit:
    bit 1       calculate a subtractive color range.
    bit 2       keep the ranges beyond the minimum and maximum as gray

.fi
.PP
 
.RE
.PP

.PP
Definition at line 247 of file Bimage_color\&.cpp\&.
.SS "\fBBimage\fP * Bimage::operator+ (\fBBimage\fP & p)"

.PP
Adds two images together, adjusting for size difference\&. 
.PP
\fBParameters\fP
.RS 4
\fI&p\fP image to add\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* summed image, NULL on error\&. 
.PP
.nf
The second image is added to the first:
    image1 = image1 + image2*scale + shift
The resultant image size is the bigger of the two.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 4034 of file Bimage\&.cpp\&.
.SS "\fBBimage\fP & Bimage::operator= (const \fBBimage\fP & p)"

.PP
Assigns an image\&. 
.PP
.nf
The internal copy function is called.

.fi
.PP
 
.PP
Definition at line 920 of file Bimage\&.cpp\&.
.SS "double Bimage::operator[] (long j) const"

.PP
Returns the data value at the given index\&. 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double value\&. 
.PP
.nf
The elemental data value is returned in double precision.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 937 of file Bimage\&.cpp\&.
.SS "\fBJSvalue\fP& Bimage::operator[] (string tag)\fC [inline]\fP"

.PP
Definition at line 221 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::orient (\fBView\fP * views)"

.PP
Calculates multiple copies oriented according to views\&. 
.PP
\fBParameters\fP
.RS 4
\fIviews\fP orientations for new images\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new set of images\&. 
.PP
.nf
Each image in a Bimage structure is rotated to the corresponding view.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 529 of file Bimage_transform\&.cpp\&.
.SS "void Bimage::origin (double ox, double oy, double oz)\fC [inline]\fP"

.PP
Definition at line 574 of file Bimage\&.h\&.
.SS "void Bimage::origin (long nn, double ox, double oy, double oz)\fC [inline]\fP"

.PP
Definition at line 593 of file Bimage\&.h\&.
.SS "void Bimage::origin (long nn, \fBVector3\fP< double > vec)\fC [inline]\fP"

.PP
Definition at line 586 of file Bimage\&.h\&.
.SS "void Bimage::origin (long nn, vector< double > ori)\fC [inline]\fP"

.PP
Definition at line 589 of file Bimage\&.h\&.
.SS "void Bimage::origin (\fBVector3\fP< double > vec)\fC [inline]\fP"

.PP
Definition at line 582 of file Bimage\&.h\&.
.SS "void Bimage::origin (vector< double > vec)\fC [inline]\fP"

.PP
Definition at line 578 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::orthogonal_slices (long nn, \fBVector3\fP< long > voxel, \fBVector3\fP< long > ext_size)"

.PP
Extracts orthogonal views around a voxel\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number to extract\&. 
.br
\fIvoxel\fP voxel of intersection\&. 
.br
\fIext_size\fP size of slices to extract\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* extracted slice for 2D and 3 slices for 3D\&. 
.PP
.nf
Only the desired region is extracted from the original image.
The fill value is taken from the image background.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 767 of file Bimage_extract\&.cpp\&.
.SS "double Bimage::otsu_threshold (long bins)"

.PP
Calculates the threshold from a histogram according to Otsu\&. 
.PP
\fBParameters\fP
.RS 4
\fIbins\fP number bins in histogram\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double threshold\&. 
.PP
.nf
Reference: NOBUYUKI OTSU, IEEE TRANSACTIONS ON SYSTEMS, MAN, AND CYBERNETICS, VOL. SMC-9, NO. 1, JANUARY 1979

.fi
.PP
 
.RE
.PP

.PP
Definition at line 694 of file Bimage_histogram\&.cpp\&.
.SS "vector< double > Bimage::otsu_variance (vector< long > h)"

.PP
Calculates the inter-set variance of the bisection of a historgram using the method of Otsu\&. 
.PP
\fBParameters\fP
.RS 4
\fIh\fP histogram\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<double> variance\&. 
.PP
.nf
Reference: NOBUYUKI OTSU, IEEE TRANSACTIONS ON SYSTEMS, MAN, AND CYBERNETICS, VOL. SMC-9, NO. 1, JANUARY 1979

.fi
.PP
 
.RE
.PP

.PP
Definition at line 735 of file Bimage_histogram\&.cpp\&.
.SS "int Bimage::pack_transform (int img_select, unsigned char * data, \fBFourierType\fP tf)"

.PP
Definition at line 2509 of file Bimage\&.cpp\&.
.SS "int Bimage::pack_transform (unsigned char * data, \fBFourierType\fP tf)"

.PP
Definition at line 2504 of file Bimage\&.cpp\&.
.SS "\fBBimage\fP * Bimage::pack_two_in_complex (\fBBimage\fP * p)"

.PP
Packs two real images into one complex image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* the new complex image, NULL on error\&. 
.PP
.nf
Two real space images are packed into the real and imaginary parts
of a new data block with conversion from the original non-complex type.
The header values of the first image are adopted for the new image.
No statistics are calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 744 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::pad (long sz, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Pads an image to a new size with a given fill value\&. 
.PP
\fBParameters\fP
.RS 4
\fIsz\fP new size\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP value to use when padding the image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is enlarged with padding only on one side in each
dimension with an input size greater than one.
The data type is preserved.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 347 of file Bimage_resize\&.cpp\&.
.SS "int Bimage::pad (\fBVector3\fP< long > sz, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Pads an image to a new size with a given fill value\&. 
.PP
\fBParameters\fP
.RS 4
\fIsz\fP new size\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP value to use when padding the image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&.
.RE
.PP
The image is enlarged with padding only on one side in each dimension with an input size greater than one\&. The data type is preserved\&. 
.PP
Definition at line 370 of file Bimage_resize\&.cpp\&.
.SS "\fBBimage\fP * Bimage::pad_copy (long sz, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Pads an image to a new size with a given fill value\&. 
.PP
\fBParameters\fP
.RS 4
\fIsz\fP new size\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP value to use when padding the image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* resized image\&. 
.PP
.nf
The image is enlarged with padding only on one side in each
dimension with an input size greater than one.
The data type is preserved.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 388 of file Bimage_resize\&.cpp\&.
.SS "\fBBimage\fP * Bimage::pad_copy (\fBVector3\fP< long > sz, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Pads an image to a new size with a given fill value\&. 
.PP
\fBParameters\fP
.RS 4
\fIsz\fP new size\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP value to use when padding the image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* resized image\&.
.RE
.PP
The image is enlarged with padding only on one side in each dimension with an input size greater than one\&. The data type is preserved\&. 
.PP
Definition at line 411 of file Bimage_resize\&.cpp\&.
.SS "\fBVector3\fP<long> Bimage::page_size ()\fC [inline]\fP"

.PP
Definition at line 496 of file Bimage\&.h\&.
.SS "void Bimage::page_size (long nx, long ny, long nz)\fC [inline]\fP"

.PP
Definition at line 497 of file Bimage\&.h\&.
.SS "void Bimage::page_size (\fBVector3\fP< long > vec)\fC [inline]\fP"

.PP
Definition at line 501 of file Bimage\&.h\&.
.SS "void Bimage::page_size (vector< long > vec)\fC [inline]\fP"

.PP
Definition at line 502 of file Bimage\&.h\&.
.SS "double Bimage::peak_sigma (long nn, \fBVector3\fP< long > coor, long kernel_size)"

.PP
Calculates a sigma value for a cross-correlation peak\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fIcoor\fP coordinates in the image\&. 
.br
\fIkernel_size\fP kernel size to fit the gaussian\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double sigma value\&. 
.PP
.nf
The peak is assumed to be close to a gaussian.
The sigma is calculated for each kernel location and averaged:
    sigma = sqrt(rad^2/2(ln(vmax)-ln(v)))

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2008 of file Bimage_correlate\&.cpp\&.
.SS "\fBBplot\fP * Bimage::percentiles ()"

.PP
Calculates the percentiles from the histogram of an image\&. 
.PP
\fBReturns\fP
.RS 4
Bplot* plot of the percentiles\&. 
.PP
.nf
A histogram of an image is calculated with 10000 bins.
The percentiles are calculated from the running sum of the histogram
and returned in a plot.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 468 of file Bimage_histogram\&.cpp\&.
.SS "\fBBimage\fP * Bimage::periodic_averaging (\fBVector3\fP< double > period)"

.PP
Calculates an average within a periodic frame\&. 
.PP
\fBParameters\fP
.RS 4
\fIperiod\fP size of periodic frame\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new image\&. 
.RE
.PP

.PP
Definition at line 1263 of file Bimage_filter\&.cpp\&.
.SS "int Bimage::phase_colour_wheel ()"

.PP
Generates a phase color wheel\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is filled with a color wheel where the location (x,y) 
is converted to polar form:
    a = arctan(y/x)
    r = sqrt(x^2+y^2)
The color is a function of the angle a and saturation is a function
of the distance from the origin.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 574 of file Bimage_color\&.cpp\&.
.SS "\fBBimage\fP * Bimage::phase_difference (\fBBimage\fP * p, int type = \fC0\fP, double res_hi = \fC0\fP, double res_lo = \fC0\fP)"

.PP
Calculates the cosine of the phase difference between two images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP real space reference image\&. 
.br
\fItype\fP 0=phase angle, 1=cos(phase angle), 2=scale by amplitude product 
.br
\fIres_hi\fP upper resolution limit\&. 
.br
\fIres_lo\fP lower resolution limit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* phase difference image\&. 
.PP
.nf
Both images are Fourier transformed and the cosine of the phase
difference calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2103 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::phase_flip (\fBBimage\fP * pd)"

.PP
Flips the phases of an image based on a phase difference map\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pd\fP reciprocal space phase difference map\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 2289 of file Bimage_fspace\&.cpp\&.
.SS "int Bimage::phase_shift (long nn, \fBVector3\fP< double > shift)"

.PP
Phase shifts a complex sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image to transform\&. 
.br
\fIshift\fP three-value real space shift vector\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
A real space translation with wrapping is equivalent to phase shifting
in reciprocal space.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 327 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::phase_shift (\fBVector3\fP< double > shift)"

.PP
Phase shifts a complex image\&. 
.PP
\fBParameters\fP
.RS 4
\fIshift\fP three-value real space shift vector\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
A real space translation with wrapping is equivalent to phase shifting
in reciprocal space.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 303 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::phase_shift_to_center ()"

.PP
Phase shifts a set of reflections to the nominal center of the image origin\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
A real space translation with wrapping is equivalent to phase shifting
in reciprocal space. The phases are shifted based on the embedded
sub-image origins.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 429 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::phase_shift_to_origin ()"

.PP
Phase shifts a set of reflections to the image origin\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
A real space translation with wrapping is equivalent to phase shifting
in reciprocal space. The phases are shifted based on the embedded
sub-image origins.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 374 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::place (long nn, \fBBimage\fP * p, \fBVector3\fP< double > loc, double radius = \fC0\fP, double scale = \fC1\fP, double shift = \fC0\fP, int operation = \fC0\fP)"

.PP
Places a small image into a large image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fI*p\fP image to place\&. 
.br
\fIloc\fP location in large image of small image origin\&. 
.br
\fIradius\fP radial mask to transfer small image\&. 
.br
\fIscale\fP density scale to apply to second image\&. 
.br
\fIshift\fP density shift to apply to second image\&. 
.br
\fIoperation\fP operation to apply\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 if error\&. 
.PP
.nf
The small image is placed with its origin at given origin in the large image.
The second image is scaled and shifted before placing into the first:
    image1 = image1 + image2*scale + shift
Both images are converted to floating point.
The operation can be selected:
    0   simple addition.
    1   replace if smaller.
    2   replace if larger.
Requirement: Both images must have the same pixel size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 176 of file Bimage_combine\&.cpp\&.
.SS "int Bimage::place_central_part (\fBBimage\fP * p, long nn)"

.PP
Packs a tile into a new composite image, retaining only the central part\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP image = tiles\&. 
.br
\fInn\fP tile image (can be a sub-image)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The overlaps between tiles are divided between the neighboring tiles.
The tile placement is in the sub-image origins.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 356 of file Bimage_combine\&.cpp\&.
.SS "int Bimage::place_with_addition (\fBBimage\fP * p, long nn)"

.PP
Packs a tile into a new composite image with addition within overlap\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP image = tiles\&. 
.br
\fInn\fP tile image (can be a sub-image)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The tiles are added to the image.
The contributions at each voxel are counted in a linked image.
The tile placement is in the sub-image origins.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 240 of file Bimage_combine\&.cpp\&.
.SS "int Bimage::place_with_overlap (\fBBimage\fP * p, long nn)"

.PP
Packs a tile into a new composite image with weighted overlap\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP image = tiles\&. 
.br
\fInn\fP tile image (can be a sub-image)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The overlaps between tiles are filled in with a weighted average based
on a linear transition from one to the other.
The tile placement is in the sub-image origins.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 282 of file Bimage_combine\&.cpp\&.
.SS "\fBBplot\fP * Bimage::plot ()"

.PP
Converts a one-dimensional image into a plot\&. 
.PP
\fBReturns\fP
.RS 4
Bplot* plot structure\&.
.RE
.PP
Each image generates one plot with each channel converted to a curve\&. 
.PP
Definition at line 4111 of file Bimage\&.cpp\&.
.SS "double Bimage::poisson_statistics_check ()"

.PP
Checks whether the statistics conform to a Poisson distribution\&. 
.PP
\fBReturns\fP
.RS 4
double variance-to-average scale\&. 
.PP
.nf
A warning is issued when the variance/average differs more than 5% from one.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 197 of file Bimage_stats\&.cpp\&.
.SS "\fBBimage\fP * Bimage::polar_power_spectrum (double resolution, long num_angle)"

.PP
Calculates the polar power spectrum of a 2D transform amplitude or intensity image\&. 
.PP
\fBParameters\fP
.RS 4
\fIresolution\fP high resolution limit\&. 
.br
\fInum_angle\fP number of angles to use for interpolation\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* polar power spectrum\&. 
.PP
.nf
The length of each annulus is number of angles times the radial offset.
The samples on each annulus are calculated by bilinear interpolation.
The maximum annulus calculated depends on the resolution limit specified
in the input image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 771 of file Bimage_polar\&.cpp\&.
.SS "\fBBimage\fP * Bimage::polar_transform (long nangles, long ann_min, long ann_max, long dann, long zmin, long zmax, long zinc)"

.PP
Calculates an image with cylindrical coordinates by integration\&. 
.PP
\fBParameters\fP
.RS 4
\fInangles\fP number of angles in each annulus\&. 
.br
\fIann_min\fP minimum annulus (pixels)\&. 
.br
\fIann_max\fP maximum annulus (pixels)\&. 
.br
\fIdann\fP width of annulus (pixels)\&. 
.br
\fIzmin\fP minimum z (pixels)\&. 
.br
\fIzmax\fP maximum z (pixels)\&. 
.br
\fIzinc\fP increment in z (pixels)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* cylindrical image\&. 
.PP
.nf
The image is converted to cylindrical form by integrating blocks 
    with a defined annular width and thickness in z at each angle. 
The resultant image contains lines corresponding to integrated blocks
    covering 360° of angle.
The sampling must be isotropic.
The origins within the sub-image structures are used.
The interpolation routine actually calculates the old cartesian 
coordinates for each set of cylindrical coordinates.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 696 of file Bimage_polar\&.cpp\&.
.SS "void Bimage::power (double v)"

.PP
Calculates the power of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIv\fP power value\&. 
.RE
.PP

.PP
Definition at line 3488 of file Bimage\&.cpp\&.
.SS "int Bimage::power_spectrum (int flags = \fC0\fP)"

.PP
Calculates a power spectrum\&. 
.PP
\fBParameters\fP
.RS 4
\fIflags\fP 1=norm, 2=avg, 4=shift, 8=log\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
All the sub-images are Fourier transformed.
The flags variable controls options base don which bits are set:
    1   normalize image before transformation
    2   average all power spectra
    4   shift the origin to the center
    8   calculate the logarithm of the power spectrum

.fi
.PP
 
.RE
.PP

.PP
Definition at line 49 of file Bimage_powerspectrum\&.cpp\&.
.SS "vector< double > Bimage::powerspectrum_isotropy (long n, double & lores, double & hires)"

.PP
Calculates a measure of anisotropy in a poer spectrum\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP sub-image number\&. 
.br
\fI&lores\fP low resolution limit\&. 
.br
\fI&hires\fP high resolution limit 
.RE
.PP
\fBReturns\fP
.RS 4
vector<double> 3-vlaue vector: power average and deviation and maximum power angle\&. The power between the indicated resolution shells are averaged for each angle and fitted to an equation for anisotropy: P = Pavg + Pdev*cos(2(a-phi)) where phi is the direction of maximum power\&. 
.RE
.PP

.PP
Definition at line 432 of file Bimage_powerspectrum\&.cpp\&.
.SS "\fBBimage\fP * Bimage::powerspectrum_tiled (long img_num, \fBVector3\fP< long > tile_size, int flags = \fC0\fP)"

.PP
Prepares a tiled power spectrum from an image for determining CTF parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fIimg_num\fP sub-image to transform\&. 
.br
\fItile_size\fP tile size (if (0,0,0) don't tile)\&. 
.br
\fIflags\fP 1=norm, 2=avg, 4=shift, 8=log\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* power spectrum\&. 
.PP
.nf
A large single image (a micrograph) is converted to a number of tiles
packed into a multi-image structure.
All the sub-images are Fourier transformed and the power spectra calculated.
The flag indicates if the images are normalized, averaged, shifted and
the logarithm calculated

.fi
.PP
 
.RE
.PP

.PP
Definition at line 106 of file Bimage_powerspectrum\&.cpp\&.
.SS "\fBBimage\fP * Bimage::powerspectrum_tiled_and_tilted (\fBVector3\fP< long > tile_size, double tilt_axis, double tilt_angle, double tilt_offset, double defocus, double iCL2, int flags = \fC0\fP)"

.PP
Prepares a tiled powerspectrum from a tilted image for determining CTF parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fItile_size\fP tile size (if (0,0,0) don't tile)\&. 
.br
\fItilt_axis\fP tilt axis angle (in radians)\&. 
.br
\fItilt_angle\fP tilt angle (in radians)\&. 
.br
\fItilt_offset\fP offset perpendicular to tilt axis (in pixels)\&. 
.br
\fIdefocus\fP average defocus to adjust for change in focus\&. 
.br
\fIiCL2\fP inverse of product of spherical aberration and wavelenght squared\&. 
.br
\fIflags\fP 1=norm, 2=avg, 4=shift, 8=log, 16=add\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* power spectrum\&. 
.PP
.nf
A large single image (a micrograph) is converted to a number of tiles
packed into a multi-image structure.
All the sub-images are Fourier transformed and the power spectra calculated.
The power spectra are scaled based on the tilt and average defocus of the image.
The flag indicates if the images are normalized, averaged, shifted and
the logarithm calculated

.fi
.PP
 
.RE
.PP

.PP
Definition at line 365 of file Bimage_powerspectrum\&.cpp\&.
.SS "\fBBimage\fP * Bimage::powerspectrum_tilt_axis (long img_num, \fBVector3\fP< long > tile_size, double tilt_axis, double tilt_offset, int flags = \fC0\fP)"

.PP
Prepares a tiled powerspectrum from a tilted image for determining CTF parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fIimg_num\fP sub-image to transform\&. 
.br
\fItile_size\fP tile size (if (0,0,0) don't tile)\&. 
.br
\fItilt_axis\fP tilt axis angle (in radians)\&. 
.br
\fItilt_offset\fP offset perpendicular to tilt axis (in pixels)\&. 
.br
\fIflags\fP 1=norm, 2=avg, 4=shift, 8=log\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* power spectrum\&. 
.PP
.nf
A large single image (a micrograph) is converted to a number of tiles
along the tilt axis packed into a multi-image structure.
All the sub-images are Fourier transformed and the power spectra calculated.
The flag indicates if the images are normalized, averaged, shifted and
the logarithm calculated

.fi
.PP
 
.RE
.PP

.PP
Definition at line 163 of file Bimage_powerspectrum\&.cpp\&.
.SS "\fBBimage\fP * Bimage::powerspectrum_tilted (long img_num, \fBVector3\fP< long > tile_size, double tilt_axis, double tilt_angle, double defocus, double iCL2, int flags = \fC0\fP)"

.PP
Prepares a tiled powerspectrum from a tilted image for determining CTF parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fIimg_num\fP sub-image to transform\&. 
.br
\fItile_size\fP tile size (if (0,0,0) don't tile)\&. 
.br
\fItilt_axis\fP tilt axis angle (in radians)\&. 
.br
\fItilt_angle\fP tilt angle (in radians)\&. 
.br
\fIdefocus\fP average defocus to adjust for change in focus\&. 
.br
\fIiCL2\fP inverse of product of spherical aberration and wavelenght squared\&. 
.br
\fIflags\fP 1=norm, 2=avg, 4=shift, 8=log\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* power spectrum\&. 
.PP
.nf
A large single image (a micrograph) is converted to a number of tiles
packed into a multi-image structure.
All the sub-images are Fourier transformed and the power spectra calculated.
The power spectra are scaled based on the tilt and average defocus of the image.
The flag indicates if the images are normalized, averaged, shifted and
the logarithm calculated

.fi
.PP
 
.RE
.PP

.PP
Definition at line 281 of file Bimage_powerspectrum\&.cpp\&.
.SS "vector< double > Bimage::pps_angular_correlation (\fBBimage\fP * pref, double res_hi, double res_lo, long nang, \fBfft_plan\fP planf)"

.PP
Definition at line 1315 of file Bimage_align\&.cpp\&.
.SS "void Bimage::progressive_sum ()"

.PP
Progressive sum of the sub-images\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
Each sub-image is summed with all previous sub-images.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3633 of file Bimage\&.cpp\&.
.SS "\fBBimage\fP * Bimage::project (char axis, int flags = \fC1\fP)"

.PP
Projects a 3D image to a 2D image down one of the three major axes\&. 
.PP
\fBParameters\fP
.RS 4
\fIaxis\fP axis of projection\&. 
.br
\fIflags\fP 1=scale projection, 2=minimum, 4=maximum\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* projection image (floating point)\&. 
.PP
.nf
The sums of the z-planes are accumulated into a new floating point data 
block.  This block is then rescaled and converted back to the original 
data type.
The new data replaces the old data.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 31 of file Bimage_project\&.cpp\&.
.SS "\fBBimage\fP * Bimage::project (\fBView\fP * view, double resolution, \fBFSI_Kernel\fP * kernel)"

.PP
Calculates a set of projections as central sections from a 3D fourier transform\&. 
.PP
\fBParameters\fP
.RS 4
\fI*view\fP linked list of views\&. 
.br
\fIresolution\fP high resolution limit\&. 
.br
\fI*kernel\fP frequency space interpolation kernel\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* projections as sub-images\&. 
.PP
.nf
The map is Fourier transformed and shifted to its phase origin.
For each view, a central section is calculated using reciprocal space interpolation.
All the projections are phase shifted to a central origin and back-transformed.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 343 of file Bimage_project\&.cpp\&.
.SS "\fBBimage\fP * Bimage::project (\fBView\fP * view, int norm_flag = \fC1\fP)"

.PP
Calculates a set of projections from a 3D density map\&. 
.PP
\fBParameters\fP
.RS 4
\fI*view\fP linked list of views\&. 
.br
\fInorm_flag\fP flag to normalize projection\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* projections as sub-images\&. 
.PP
.nf
A set of projections is calculated according to a list of views.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 207 of file Bimage_project\&.cpp\&.
.SS "int Bimage::pure_color ()"

.PP
Generates a pure color image without intensity\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
Pure color is defined as:
            col
    col = --------
          sum(col)

.fi
.PP
 
.RE
.PP

.PP
Definition at line 352 of file Bimage_color\&.cpp\&.
.SS "int Bimage::quadric (double * param)"

.PP
Generates a quadric surface over the whole image\&. 
.PP
\fBParameters\fP
.RS 4
\fIparam\fP 7-value array of parameters\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 893 of file Bimage_edit\&.cpp\&.
.SS "int Bimage::quadric_correct (vector< double > param)"

.PP
Corrects for a quadric surface\&. 
.PP
\fBParameters\fP
.RS 4
\fIparam\fP 7-value array of parameters\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.RE
.PP

.PP
Definition at line 857 of file Bimage_rescale\&.cpp\&.
.SS "vector< double > Bimage::quadric_fit ()"

.PP
Fits the whole image to a quadric surface\&. 
.PP
\fBReturns\fP
.RS 4
vector<double> 7-value array of parameters\&. 
.PP
.nf
A quadric surface is defined as:
v = a0 + a1*dx + a2*dy + a3*dz + a4*dx^2 + a5*dy^2 + a6*dz^2

.fi
.PP
 
.RE
.PP

.PP
Definition at line 893 of file Bimage_rescale\&.cpp\&.
.SS "vector<\fBJSvalue\fP*> Bimage::query (string & path)\fC [inline]\fP"

.PP
Definition at line 224 of file Bimage\&.h\&.
.SS "double Bimage::R_factor (\fBBimage\fP * p)"

.PP
Calculates an R factor between two images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP second image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double R factor, -1 if not run\&. 
.PP
.nf
The difference between two images is calculated and normalized as:
                          sum(image1 - image2)^2
    R = sqrt(-------------------------------------------------)
             sqrt(sum(image1 - avg1)^2 * sum(image2 - avg2)^2)
Both images are converted to floating point.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 218 of file Bimage_correlate\&.cpp\&.
.SS "\fBBimage\fP * Bimage::radial (long minrad, long maxrad, double rad_step, \fBBimage\fP * pmask, int wrap = \fC0\fP)"

.PP
Calculates the radial average of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIminrad\fP minimum radius in voxels\&. 
.br
\fImaxrad\fP maximum radius in voxels\&. 
.br
\fIrad_step\fP step size in voxels\&. 
.br
\fI*pmask\fP mask to limit calculation\&. 
.br
\fIwrap\fP flag to wrap the data\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* radial average in the form of a 1D image\&. 
.PP
.nf
A radial average of a 2D or 3D image is calculated between a minimum
and maximum radius.  An interpolative method is used where the value of 
a voxel is distributed between the two nearest radial annuli.
The final sum in an annulus is normalized by the number of voxels 
contributing to the annulus sum.
The origins within the sub-image structures are used.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 55 of file Bimage_polar\&.cpp\&.
.SS "\fBBimage\fP * Bimage::radial (long minrad, long maxrad, double rad_step, double ellipticity, double angle, \fBBimage\fP * pmask, int wrap = \fC0\fP)"

.PP
Calculates the radial average of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIminrad\fP minimum radius in voxels\&. 
.br
\fImaxrad\fP maximum radius in voxels\&. 
.br
\fIrad_step\fP step size in voxels\&. 
.br
\fIellipticity\fP ratio of major and minor axes\&. 
.br
\fIangle\fP angle of major axis\&. 
.br
\fI*pmask\fP mask to limit calculation\&. 
.br
\fIwrap\fP flag to wrap the data\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* radial average in the form of a 1D image\&. 
.PP
.nf
A radial average of a 2D or 3D image is calculated between a minimum
and maximum radius.  An interpolative method is used where the value of 
a voxel is distributed between the two nearest radial annuli.
The final sum in an annulus is normalized by the number of voxels 
contributing to the annulus sum.
The origins within the sub-image structures are used.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 79 of file Bimage_polar\&.cpp\&.
.SS "\fBBimage\fP * Bimage::radial (long minrad, long maxrad, double rad_step = \fC1\fP, int wrap = \fC0\fP)"

.PP
Calculates the radial average of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIminrad\fP minimum radius in voxels\&. 
.br
\fImaxrad\fP maximum radius in voxels\&. 
.br
\fIrad_step\fP step size in voxels\&. 
.br
\fIwrap\fP flag to wrap the data\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* radial average in the form of a 1D image\&. 
.PP
.nf
A radial average of a 2D or 3D image is calculated between a minimum
and maximum radius.  An interpolative method is used where the value of 
a voxel is distributed between the two nearest radial annuli.
The final sum in an annulus is normalized by the number of voxels 
contributing to the annulus sum.
The origins within the sub-image structures are used.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 33 of file Bimage_polar\&.cpp\&.
.SS "\fBBimage\fP * Bimage::radial_coverage (double threshold, double rad_step = \fC1\fP)"

.PP
Calculates the coverage in each radial shell\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP density threshold to distinguish for- and background\&. 
.br
\fIrad_step\fP radial step size (voxels)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 1190 of file Bimage_polar\&.cpp\&.
.SS "double * Bimage::radial_fit (\fBBimage\fP * pref)"

.PP
Fits a radial profile to a reference radial profile\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pref\fP reference radial profile as a 1D image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double* 3-value result vector: dimension scale, amplitude scale and amplitude shift\&. 
.PP
.nf
A radial profile is fitted to a reference profile using an iterative
simplex down-hill method.  The equations solved are:
    x(new) = x(old)*m
    y(new) = y(old)*a + b
where   m is the dimension scaling (or magnification).
        a is the amplitude scaling.
        b is the amplitude shift.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 325 of file Bimage_polar\&.cpp\&.
.SS "\fBBimage\fP * Bimage::radial_sections (double rad_start, double rad_end, double rad_step, double spherical_fraction, \fBBsymmetry\fP & sym, int fill_type = \fC\fBFILL_USER\fP\fP, double fill = \fC0\fP)"

.PP
Calculates an image with slices giving the radial section projections\&. 
.PP
\fBParameters\fP
.RS 4
\fIrad_start\fP starting radius (voxels)\&. 
.br
\fIrad_end\fP ending radius (voxels)\&. 
.br
\fIrad_step\fP radial step size (voxels)\&. 
.br
\fIspherical_fraction\fP fraction of spherical section (requires symmetry)\&. 
.br
\fI*sym\fP symmetry for non-spherical sections\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP value to fill in excluded regions\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* image with radial sections\&. 
.PP
.nf
The 3D image is converted so that the sections contain 2D projections
of radial shells. The projection in slice i is defined for:
    i >= sqrt(x^2 + y^2)
Non-spherical sections can be generated by specifying the symmetry and
the fraction of spherical nature (1=spherical, 0=based on symmetry).
Sampling in x and y is not changed.
The sampling in the input map must be isotropic.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1131 of file Bimage_polar\&.cpp\&.
.SS "int Bimage::radial_shells ()"

.PP
Calculates an image with slices representing radial shell projections\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The 3D image is converted so that the sections contain 2D projections
of radial shells. The projection in slice z is defined for:
    z >= sqrt((x-xo)^2 + (y-yo)^2) + zo
The first projection is placed at the z origin and radiates out into
both positive and negative directions.
Sampling in x and y is not changed.
The sampling must be isotropic.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 853 of file Bimage_polar\&.cpp\&.
.SS "\fBBimage\fP * Bimage::radial_symmetry_adjusted (double rad_start, double rad_end, double rad_step, double spherical_fraction, \fBBsymmetry\fP & sym)"

.PP
Calculates the symmetry-adjusted radial average of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIrad_start\fP minimum radius in voxels\&. 
.br
\fIrad_end\fP maximum radius in voxels\&. 
.br
\fIrad_step\fP step size in voxels\&. 
.br
\fIspherical_fraction\fP ratio of major and minor axes\&. 
.br
\fI*sym\fP point group symmetry\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* radial average in the form of a 1D image\&. 
.PP
.nf
A radial average of a 2D or 3D image is calculated between a minimum
and maximum radius.  An interpolative method is used where the value of
a voxel is distributed between the two nearest radial annuli.
The final sum in an annulus is normalized by the number of voxels
contributing to the annulus sum.
The symmetry is used to adjust the radius to follow the contours of a shell.
The origins within the sub-image structures are used.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 206 of file Bimage_polar\&.cpp\&.
.SS "\fBBimage\fP * Bimage::radial_to_full (\fBVector3\fP< long > nusize, \fBVector3\fP< double > origin)"

.PP
Generates a full 2D or 3D image from a radial profile in a 1D image\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP size of image to expand to\&. 
.br
\fIorigin\fP origin for radial profile\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new 2D or 3D image\&. 
.PP
.nf
It assumes the resultant image is square or cubic.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 409 of file Bimage_polar\&.cpp\&.
.SS "unsigned char * Bimage::read_data (ifstream * fimg, int img_select, int sb, int vax, long pad)"

.PP
Read image data in a generalized style\&. 
.PP
\fBParameters\fP
.RS 4
\fI*fimg\fP file descriptor: file opened in calling function\&. 
.br
\fIimg_select\fP image selection: if -1, all images, if >= 0, one image\&. 
.br
\fIsb\fP flag activates byte swapping\&. 
.br
\fIvax\fP indicate vax style floating point - activates conversion\&. 
.br
\fIpad\fP any interspersed control or separation bytes\&. 
.RE
.PP
\fBReturns\fP
.RS 4
unsigned char* data pointer, NULL if reading failed\&. The whole file or a single image from a file may be read\&. The data is read in the largest blocks possible for efficiency\&. Any interspersed padding and page sizes not matching the data size contribute to inefficiency in reading\&. Swapping: sb = 1: swap bytes the size of the data type sb > 1: swap these number of bytes regardless of the data type 
.RE
.PP

.PP
Definition at line 2263 of file Bimage\&.cpp\&.
.SS "\fBVector3\fP<double> Bimage::real_coordinates (long i)\fC [inline]\fP"

.PP
Definition at line 456 of file Bimage\&.h\&.
.SS "\fBVector3\fP<double> Bimage::real_size ()\fC [inline]\fP"

.PP
Definition at line 503 of file Bimage\&.h\&.
.SS "\fBVector3\fP<long> Bimage::reciprocal_half ()\fC [inline]\fP"

.PP
Definition at line 1225 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::red_white_blue (double red_min, double white_min, double white_max, double blue_max)"

.PP
Colorizes an image with blue positive and red negative\&. 
.PP
\fBParameters\fP
.RS 4
\fIred_min\fP beginning of red gradient (most negative)\&. 
.br
\fIwhite_min\fP end of red gradient (fade into white)\&. 
.br
\fIwhite_max\fP beginning of blue gradient (start with white)\&. 
.br
\fIblue_max\fP end of blue gradient (most positive) 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* color scale image\&. 
.PP
.nf
A grayscale image is converted to RGB and colored with blue positive, 
red negative, and white in between.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 478 of file Bimage_color\&.cpp\&.
.SS "int Bimage::refine_peak ()"

.PP
Refines the position of a peak to sub-voxel resolution\&. 
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
The sub-voxel resolution peak in the vicinity of a voxel is defined 
by fitting a 2D/3D second order function around the voxel.
(typically used to find the shift vector in a cross-correlation map).

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1617 of file Bimage_correlate\&.cpp\&.
.SS "int Bimage::refine_peak_new ()"

.PP
Refines the position of a peak to sub-voxel resolution\&. 
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
The sub-voxel resolution peak in the vicinity of a voxel is defined 
by fitting a 2D/3D second order function around the voxel.
(typically used to find the shift vector in a cross-correlation map).

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1576 of file Bimage_correlate\&.cpp\&.
.SS "long Bimage::region_assign (\fBBimage\fP * pmask, long idx, long region_number, double threshold, int sign)"

.PP
Finds all the pixels that are part of the same region\&. 
.PP
\fBAuthor\fP
.RS 4
Bernard Heymann and Samuel Payne 
.RE
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP a mask holding region assignments\&. 
.br
\fIidx\fP the first voxel of a region\&. 
.br
\fIregion_number\fP the region number that voxels are assigned\&. 
.br
\fIthreshold\fP the level to define background\&. 
.br
\fIsign\fP sign controlling direction of thresholding\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
This method uses a list to keep track of voxels assigned to a region.
In subsequent iterations the non-assigned voxels next to those in
the list are assigned if they exceed the threshold, and their indices
are kept in a new list. The new list is transferred to the old list
and the process iteratively continued until the new list contains
no more voxels.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 100 of file Bimage_segment\&.cpp\&.
.SS "long Bimage::region_flood (\fBBimage\fP * pmask, double threshold_hi, double threshold_lo, double threshold_step, int fill_borders)"

.PP
Creates and expands a region map from a starting to ending threshold value\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP region map (if NULL, generate from high threshold)\&. 
.br
\fIthreshold_hi\fP the level to pick initial regions\&. 
.br
\fIthreshold_lo\fP the lowest level to include voxels in regions\&. 
.br
\fIthreshold_step\fP the incremental change in threshold\&. 
.br
\fIfill_borders\fP flag to assign borders between regions (default not)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of regions\&. 
.PP
.nf
A region map is calculated at the threshold furthest from the average.
The region map is then expanded by lowering the threshold gradually 
and assigning newly included voxels to neighboring regions (i.e., flooding).
Voxels with neighbours assigned to two or more different regions are tagged
as indeterminate to indicate borders between regions. These border voxels
are counted and can be used to estimate the extent of interfaces.
The indices of all the final regions are packed into an integer data block
within a new image.
The image is assumed to have high values for objects (i.e., density is white).

.fi
.PP
 
.RE
.PP

.PP
Definition at line 237 of file Bimage_segment\&.cpp\&.
.SS "\fBBimage\fP * Bimage::region_peaks (long kernel_size, double threshold, int flood = \fC0\fP, int wrap = \fC0\fP)"

.PP
Generates a segmented image from peaks above a threshold value\&. 
.PP
\fBParameters\fP
.RS 4
\fIkernel_size\fP size of kernel to determine peaks\&. 
.br
\fIthreshold\fP the lowest level to include voxels in regions\&. 
.br
\fIflood\fP flag to flood to the threshold\&. 
.br
\fIwrap\fP flag to wrap the kernel around image boundaries\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* integer image containing region index numbers\&. 
.PP
.nf
Every voxel with a value above the threshold is tagged by a pointer 
pointing to the highest value within a kernel. 
A peak is defined as pointing to itself, while every other voxel
points towards a peak.
The voxels in the mask are then iteratively assigned to the peaks
they point to.
The indices of all the final regions are packed into an integer data block
within a new image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 488 of file Bimage_segment\&.cpp\&.
.SS "int Bimage::region_threshold_series (double threshold_first, double threshold_last, double threshold_step)"

.PP
Segments a map through a series of thresholds and reports results\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold_first\fP the level to pick initial regions\&. 
.br
\fIthreshold_last\fP the lowest level to include voxels in regions\&. 
.br
\fIthreshold_step\fP the incremental change in threshold\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.RE
.PP

.PP
Definition at line 181 of file Bimage_segment\&.cpp\&.
.SS "\fBBimage\fP * Bimage::regions (double threshold, int sign)"

.PP
Segments an image into contiguous regions\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP the level at which things are ignored\&. 
.br
\fIsign\fP sign controlling direction of thresholding\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* level mask with indexed regions\&. 
.PP
.nf
The image is segmented into contiguous regions where a region is 
defined as all those voxels exceeding the given threshold and
adjacent to each other.
This method uses a list to keep track of voxels assigned to a region.
In subsequent iterations the non-assigned voxels next to those in
the list are assigned if they exceed the threshold, and their indices
are kept in a new list. The new list is transferred to the old list
and the process iteratively continued until the new list contains
no more voxels. The indices of all the regions are packed into
an integer data block within a new image.
The new image maps the indices of the regions starting from one to as
many regions as were found (the maximum gives the number of regions).
The new image has zeroes for all voxels outside the regions.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 37 of file Bimage_segment\&.cpp\&.
.SS "double Bimage::relative_density (\fBBimage\fP * pmask)"

.PP
Calculates the relative density in a region defined by a mask\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP a 4 level mask\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double relative density\&. 
.PP
.nf
The mask is assumed to have 4 levels:
0       region of no interest
1       region to estimate relative density
2       reference region
3       background region

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3266 of file Bimage\&.cpp\&.
.SS "int Bimage::replace (\fBBimage\fP * img)"

.PP
Replaces the data with that from the given image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*img\fP source image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The input image must be the same size as the receiving image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2897 of file Bimage\&.cpp\&.
.SS "int Bimage::replace (long nn, \fBBimage\fP * img, long nr, double fill)"

.PP
Replaces one sub-image in an image structure\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number to replace\&. 
.br
\fI*img\fP source image\&. 
.br
\fInr\fP source sub-image number\&. 
.br
\fIfill\fP fill vlue\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The input image may have a different size as the receiving image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2938 of file Bimage\&.cpp\&.
.SS "int Bimage::replace (long nn, \fBBimage\fP * img, long nr = \fC0\fP)"

.PP
Replaces one sub-image in an image structure\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image number to replace\&. 
.br
\fI*img\fP source image\&. 
.br
\fInr\fP source sub-image number\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The input image must be the same size as the receiving image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2916 of file Bimage\&.cpp\&.
.SS "long Bimage::replace_maxima (double threshold)"

.PP
Replaces maxima above a threshold using local averages\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP threshold\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of voxels replaced\&. 
.PP
.nf
The image is first segemented into regions, each defined as a 
contiguous cluster of voxels with values above the threshold. 
Each region is encoded in an integer image, with all the values
in this image set to the indices of the regions, or zero elsewhere.
The regions are iteratively filled in, where in every iteration, 
the border values of the regions are replaced by the average 
of the neighbouring voxels outside the region. After each iteration, 
every region is shrunk by excluding the newly replaced voxels.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 748 of file Bimage_segment\&.cpp\&.
.SS "int Bimage::replicate_asymmetric_unit (\fBBsymmetry\fP & sym)"

.PP
Calculates a full map from one asymmetric unit\&. 
.PP
\fBParameters\fP
.RS 4
\fI*sym\fP symmetry structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
A reference view for each point group is generated such that it is
located close to the center of the canonical asymmetric unit.
For each voxel in the target map, a set of symmetry-related views 
are generated and the one closest to the reference view used
to determine the corresponding voxels within the asymmetric unit.
The new voxel value is calculated by trilinear interpolation of the
voxels in the asymmetric unit. 

.fi
.PP
 
.RE
.PP

.PP
Definition at line 972 of file Bimage_symmetry\&.cpp\&.
.SS "int Bimage::rescale (double scale, double shift)"

.PP
Rescales the image data with a given multiplier and offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIscale\fP multiplier\&. 
.br
\fIshift\fP addition or offset\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
The new data is calculated as:
    new_datum = datum*scale + shift
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 27 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::rescale (long nn, double scale, double shift)"

.PP
Rescales the image data with a given multiplier and offset\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fIscale\fP multiplier\&. 
.br
\fIshift\fP addition or offset\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
Requirement: The images must have the same size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 62 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::rescale_to_avg_std (double nuavg, double nustd)"

.PP
Rescales the image data to a given average and standard deviation\&. 
.PP
\fBParameters\fP
.RS 4
\fInuavg\fP new average\&. 
.br
\fInustd\fP new standard deviation\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
The new data is calculated as:
                                new_std_dev
    new_datum = (datum - avg) * ----------- + new_avg
                                  std_dev
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 163 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::rescale_to_avg_std (double nuavg, double nustd, \fBBimage\fP * pmask)"

.PP
Rescales the image data to a given average and standard deviation\&. 
.PP
\fBParameters\fP
.RS 4
\fInuavg\fP new average\&. 
.br
\fInustd\fP new standard deviation\&. 
.br
\fI*pmask\fP statistical calculations limited to the masked region\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
The new data is calculated as:
                                new_std_dev
    new_datum = (datum - avg) * ----------- + new_avg
                                  std_dev
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 235 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::rescale_to_avg_std (long nn, double nuavg, double nustd)"

.PP
Rescales the image data to a given average and standard deviation\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fInuavg\fP new average\&. 
.br
\fInustd\fP new standard deviation\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
The new data is calculated as:
                                new_std_dev
    new_datum = (datum - avg) * ----------- + new_avg
                                  std_dev
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 199 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::rescale_to_min_max (double numin, double numax)"

.PP
Rescales the image data to a given minimum and maximum\&. 
.PP
\fBParameters\fP
.RS 4
\fInumin\fP new minimum\&. 
.br
\fInumax\fP new maximum\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
The new data is calculated as:
                                new_max - new_min
    new_datum = (datum - min) * ----------------- + new_min
                                    max - min
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 100 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::rescale_to_min_max (long nn, double numin, double numax)"

.PP
Rescales the image data to a given minimum and maximum\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fInumin\fP new minimum\&. 
.br
\fInumax\fP new maximum\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.PP
.nf
The new data is calculated as:
                                new_max - new_min
    new_datum = (datum - min) * ----------------- + new_min
                                    max - min
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 132 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::resize (\fBVector3\fP< long > nusize, \fBVector3\fP< long > translate, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Resizes without interpolation or rescaling\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP new image size three-value vector\&. 
.br
\fItranslate\fP three-value translation vector\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER 
.br
\fIfill\fP value to fill in new regions\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
An image is resized with translation and filling of new regions with 
a given value.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 28 of file Bimage_resize\&.cpp\&.
.SS "\fBBimage\fP * Bimage::resize_copy (\fBVector3\fP< long > nusize, \fBVector3\fP< long > translate, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Resizes without interpolation or rescaling\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP new image size three-value vector\&. 
.br
\fItranslate\fP three-value translation vector\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER 
.br
\fIfill\fP value to fill in new regions\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* resized image\&. 
.PP
.nf
An image is resized with translation and filling of new regions with 
a given value.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 124 of file Bimage_resize\&.cpp\&.
.SS "int Bimage::resize_wrap (\fBVector3\fP< long > nusize, \fBVector3\fP< long > translate)"

.PP
Resizes without interpolation or rescaling\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP new image size three-value vector\&. 
.br
\fItranslate\fP three-value translation vector\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
An image is resized with translation and filling of new regions with 
a given value.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 202 of file Bimage_resize\&.cpp\&.
.SS "\fBBimage\fP * Bimage::resize_wrap_copy (\fBVector3\fP< long > nusize, \fBVector3\fP< long > translate)"

.PP
Resizes with wrapping without interpolation or rescaling\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP new image size three-value vector\&. 
.br
\fItranslate\fP three-value translation vector\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* resized image\&. 
.PP
.nf
An image is resized with translation and filling of new regions with 
a given value.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 280 of file Bimage_resize\&.cpp\&.
.SS "void Bimage::reslice (\fBBstring\fP order)"

.PP
Switches axes of an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIorder\fP string encoding the reslicing order\&. 
.PP
.nf
Reslicing refers to switching the axes of a multidimensional image.
The equivalent is rotation around angles that are multiples of pi/2.
The reslicing is encoded as a string of x, y and z, with the order
and sign indicating the type of reslicing to be done.
The new data replaces the old data.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3334 of file Bimage\&.cpp\&.
.SS "void Bimage::reslice (const char * order)\fC [inline]\fP"

.PP
Definition at line 728 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::resolution_prepare (\fBBimage\fP * p)"

.PP
Definition at line 17 of file Bimage_resolution\&.cpp\&.
.SS "\fBBimage\fP * Bimage::resolution_prepare (\fBBimage\fP * p, \fBfft_plan\fP plan)"

.PP
Definition at line 46 of file Bimage_resolution\&.cpp\&.
.SS "\fBRGB\fP< double > Bimage::rgb (long j)"

.PP
Returns a color value at the given index\&. 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.RE
.PP
\fBReturns\fP
.RS 4
RGB<double> the color value\&. 
.PP
.nf
The index refers to compound values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1064 of file Bimage\&.cpp\&.
.SS "void Bimage::rgb_to_cmyk ()"

.PP
Converts an \fBRGB\fP color image to \fBCMYK\fP\&. 
.PP
Definition at line 176 of file Bimage_color\&.cpp\&.
.SS "void Bimage::rgb_to_rgba ()"

.PP
An alpha channel is added to a \fBRGB\fP color image\&. 
.PP
.nf
The alpha channel value is set to 255.

.fi
.PP
 
.PP
Definition at line 122 of file Bimage_color\&.cpp\&.
.SS "\fBRGBA\fP< double > Bimage::rgba (long j)"

.PP
Returns a color value at the given index\&. 
.PP
.nf
The index refers to compound values.

.fi
.PP
 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.RE
.PP
\fBReturns\fP
.RS 4
RGBA<double> the color value\&. 
.RE
.PP

.PP
Definition at line 1078 of file Bimage\&.cpp\&.
.SS "void Bimage::rgba_to_rgb ()"

.PP
The alpha channel is delete from an \fBRGBA\fP color image\&. 
.PP
Definition at line 149 of file Bimage_color\&.cpp\&.
.SS "int Bimage::rotate ()"

.PP
Rotates an image using parameters defined in the image in place\&. 
.PP
\fBReturns\fP
.RS 4
0 error code\&. 
.PP
.nf
The image is rotated according to the view and origin encoded
for the sub-image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 255 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::rotate (double angle)"

.PP
Rotates an image around the z-axis by the given angle in place\&. 
.PP
\fBParameters\fP
.RS 4
\fIangle\fP rotation angle in radians\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 error code\&. 
.PP
.nf
The image is rotated according to the axis and angle given.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 274 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::rotate (\fBMatrix3\fP mat)"

.PP
Rotates an image using the specified matrix\&. 
.PP
\fBParameters\fP
.RS 4
\fImat\fP 3x3 rotation matrix\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 error code\&. 
.PP
.nf
An image is rotated according to the input matrix.
The input image origin is the rotation center.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 351 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::rotate (\fBVector3\fP< double > axis, double angle)"

.PP
Rotates an image using an axis and angle in place\&. 
.PP
\fBParameters\fP
.RS 4
\fIaxis\fP 3-value rotation axis\&. 
.br
\fIangle\fP rotation angle in radians\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 error code\&. 
.PP
.nf
The image is rotated according to the axis and angle given.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 294 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::rotate (\fBVector3\fP< double > translate, \fBMatrix3\fP mat)"

.PP
Rotates an image using the specified shift and matrix\&. 
.PP
\fBParameters\fP
.RS 4
\fItranslate\fP translation after rotation\&. 
.br
\fImat\fP 3x3 rotation matrix\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 error code\&. 
.PP
.nf
An image is rotated according to the input view vector and angle. 
The input image origin is the rotation center.
The rotated image is translated to the input origin.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 371 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::rotate (\fBVector3\fP< double > translate, \fBView\fP view)"

.PP
Rotates an image to a specified view in place\&. 
.PP
\fBParameters\fP
.RS 4
\fItranslate\fP translation after rotation\&. 
.br
\fI*view\fP view vector and angle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 error code\&. 
.PP
.nf
An image is rotated according to the input view vector and angle. 
The input image origin is the rotation center.
The rotated image is translated to the input origin.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 332 of file Bimage_transform\&.cpp\&.
.SS "\fBBimage\fP * Bimage::rotate (\fBVector3\fP< long > nusize)"

.PP
Rotates an image using parameters defined in the image\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP 3-value new image size\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* rotated image\&. 
.PP
.nf
The image is rotated according to the view and origin encoded
for the sub-image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 389 of file Bimage_transform\&.cpp\&.
.SS "\fBBimage\fP * Bimage::rotate (\fBVector3\fP< long > nusize, double angle)"

.PP
Rotates an image around the z-axis by the given angle\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP 3-value new image size\&. 
.br
\fIangle\fP rotation angle in radians\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* rotated image\&. 
.PP
.nf
The image is rotated according to the axis and angle given.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 409 of file Bimage_transform\&.cpp\&.
.SS "\fBBimage\fP * Bimage::rotate (\fBVector3\fP< long > nusize, \fBMatrix3\fP mat)"

.PP
Rotates an image using the specified matrix\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP new image size\&. 
.br
\fImat\fP 3x3 rotation matrix\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* rotated image\&. 
.PP
.nf
An image is rotated according to the input matrix.
The input image origin is the rotation center.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 490 of file Bimage_transform\&.cpp\&.
.SS "\fBBimage\fP * Bimage::rotate (\fBVector3\fP< long > nusize, \fBVector3\fP< double > axis, double angle)"

.PP
Rotates an image using an axis and angle\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP 3-value new image size\&. 
.br
\fIaxis\fP 3-value rotation axis\&. 
.br
\fIangle\fP rotation angle in radians\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* rotated image\&. 
.PP
.nf
The image is rotated according to the axis and angle given.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 430 of file Bimage_transform\&.cpp\&.
.SS "\fBBimage\fP * Bimage::rotate (\fBVector3\fP< long > nusize, \fBVector3\fP< double > translate, \fBView\fP view)"

.PP
Rotates an image to a specified view\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP 3-value new image size\&. 
.br
\fItranslate\fP translation after rotation\&. 
.br
\fI*view\fP view vector and angle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* rotated image\&. 
.PP
.nf
An image is rotated according to the input view vector and angle. 
The input image origin is the rotation center.
The rotated image is translated to the input origin.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 470 of file Bimage_transform\&.cpp\&.
.SS "\fBBimage\fP * Bimage::rotate (\fBVector3\fP< long > nusize, \fBView\fP view)"

.PP
Rotates an image to a specified view\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP 3-value new image size\&. 
.br
\fI*view\fP view vector and angle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* rotated image\&. 
.PP
.nf
An image is rotated according to the input view vector and angle. 
The input image origin is the rotation center.
The rotated image is translated to the input origin.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 451 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::rotate (\fBView\fP view)"

.PP
Rotates an image to a specified view in place\&. 
.PP
\fBParameters\fP
.RS 4
\fI*view\fP view vector and angle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 error code\&. 
.PP
.nf
An image is rotated according to the input view vector and angle. 
The input image origin is the rotation center.
The rotated image is translated to the input origin.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 314 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::rotate_and_add (\fBBimage\fP * p, \fBVector3\fP< double > origin, \fBView\fP view)"

.PP
Rotates an image to a specified view and adds it to another image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP the image to rotate and add (modified)\&. 
.br
\fIorigin\fP origin in input image\&. 
.br
\fI*view\fP view vector and angle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
An image is rotated according to the input view vector and angle. 
The input image origin is the rotation center.
The rotated image is translated to the input origin.
The result is added to the current image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 512 of file Bimage_transform\&.cpp\&.
.SS "double Bimage::rotate_correlate (\fBVector3\fP< double > axis, double angle)"

.PP
Rotates a copy of an image and correlates it with the original\&. 
.PP
\fBParameters\fP
.RS 4
\fIaxis\fP rotation axis\&. 
.br
\fIangle\fP rotation angle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double correlation coefficient, -1 if error\&. 
.PP
.nf
This mainly used to determine the symmetry of a map.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 195 of file Bimage_correlate\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::rotate_cross_correlate (\fBBimage\fP * pref, \fBView\fP view, double hires, double lores, double search_radius, \fBBimage\fP * pmask, double & cc, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Definition at line 803 of file Bimage_correlate\&.cpp\&.
.SS "double Bimage::rotate_cross_correlate_two_way (\fBBimage\fP * pref, double angle, double res_hi, double res_lo, double shift_limit, \fBfft_plan\fP planf, \fBfft_plan\fP planb)"

.PP
Definition at line 861 of file Bimage_correlate\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::rotate_find_shift (\fBMatrix3\fP mat, double hires, double lores, double radius, double sigma, int refine_flag, \fBfft_plan\fP planf, \fBfft_plan\fP planb, double & cc)"

.PP
Rotates and find shift by cross-correlation\&. 
.PP
\fBParameters\fP
.RS 4
\fImat\fP rotation matrix\&. 
.br
\fIhires\fP high resolution limit in angstroms\&. 
.br
\fIlores\fP low resolution limit in angstroms\&. 
.br
\fIradius\fP search radius\&. 
.br
\fIsigma\fP soften search radius cutoff\&. 
.br
\fIrefine_flag\fP refine shift\&. 
.br
\fIplanf\fP forward Fourier transform plan\&. 
.br
\fIplanb\fP backward Fourier transform plan\&.k 
.br
\fI&cc\fP correlation coefficient 
.RE
.PP
\fBReturns\fP
.RS 4
\fBVector3<double>\fP origin\&. 
.PP
.nf
The point group symmetry operations are applied to an image with an
orientation defined by the reference symmetry axis (default {0,0,1}). 

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1310 of file Bimage_correlate\&.cpp\&.
.SS "\fBBimage\fP * Bimage::rotate_height (\fBMatrix3\fP mat, \fBVector3\fP< double > translate, double threshold = \fC0\fP)"

.PP
Rotates a 3D map and calculates the height along the z-axis\&. 
.PP
\fBParameters\fP
.RS 4
\fImat\fP 3x3 rotation or skewing matrix\&. 
.br
\fItranslate\fP 3-value vector for translation after transformation\&. 
.br
\fIthreshold\fP density threshold to consider as object\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new 2D height image\&. 
.PP
.nf
The 3D map is rotated around its center as origin and the height 
calculated along the z-direction.
The resultant 2D image is translated if the translation vector is 
non-zero.
The rotation origin is obtained from the map origin.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 164 of file Bimage_topo\&.cpp\&.
.SS "\fBBimage\fP * Bimage::rotate_project (\fBMatrix3\fP mat, \fBVector3\fP< double > translate, double radial_cutoff, int norm_flag = \fC1\fP)"

.PP
Rotates a 3D map and projects it along the z-axis\&. 
.PP
\fBParameters\fP
.RS 4
\fImat\fP 3x3 rotation or skewing matrix\&. 
.br
\fItranslate\fP 3-value vector for translation after transformation\&. 
.br
\fIradial_cutoff\fP spherical cutoff to apply\&. 
.br
\fInorm_flag\fP flag to normalize projection\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new 2D projection image\&. 
.PP
.nf
The 3D map is rotated around its center as origin and the data 
integrated along the z-direction after subtraction of the
background (which must be calculated before this function).
The resultant 2D image is translated if the translation vector is 
non-zero. A radial cutoff can be applied to decrease the computation 
time. A value of zero or less sets the default to the length of the 
x-axis (i.e., no effective cutoff).
The rotation origin is obtained from the map origin.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 118 of file Bimage_project\&.cpp\&.
.SS "long Bimage::rotate_to_axis (\fBBsymmetry\fP & sym, long axis, long axis_flag)"

.PP
Rotates to a symmetry axis\&. 
.PP
\fBParameters\fP
.RS 4
\fI*sym\fP symmetry structure\&. 
.br
\fIaxis\fP desired symmetry axis order\&. 
.br
\fIaxis_flag\fP view modifier\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long 0\&. 
.RE
.PP

.PP
Definition at line 560 of file Bimage_symmetry\&.cpp\&.
.SS "vector<\fBVector3\fP<double> > Bimage::sampling ()\fC [inline]\fP"

.PP
Definition at line 532 of file Bimage\&.h\&.
.SS "void Bimage::sampling (double ux, double uy, double uz)\fC [inline]\fP"

.PP
Definition at line 526 of file Bimage\&.h\&.
.SS "\fBVector3\fP<double> Bimage::sampling (long nn)\fC [inline]\fP"

.PP
Definition at line 529 of file Bimage\&.h\&.
.SS "void Bimage::sampling (long nn, double ux, double uy, double uz)\fC [inline]\fP"

.PP
Definition at line 520 of file Bimage\&.h\&.
.SS "void Bimage::sampling (long nn, \fBVector3\fP< double > u)\fC [inline]\fP"

.PP
Definition at line 517 of file Bimage\&.h\&.
.SS "void Bimage::sampling (\fBVector3\fP< double > u)\fC [inline]\fP"

.PP
Definition at line 523 of file Bimage\&.h\&.
.SS "void Bimage::sampling (vector< \fBVector3\fP< double >> sam)\fC [inline]\fP"

.PP
Definition at line 537 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::scale_to_reference (\fBBimage\fP * pref, \fBBimage\fP * pmask, double scalemin, double scalemax, double step)"

.PP
Scales and image to the given reference, searching for the correct scale\&. 
.PP
\fBParameters\fP
.RS 4
\fIpref\fP reference/template image\&. 
.br
\fIpmask\fP mask to limit correlation calculation (can be NULL)\&. 
.br
\fIscalemin\fP minimum scaling to start search\&. 
.br
\fIscalemax\fP maximum scaling to end search\&. 
.br
\fIstep\fP scaling search step size\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* scaled image\&. 
.RE
.PP

.PP
Definition at line 759 of file Bimage_transform\&.cpp\&.
.SS "\fBBimage\fP * Bimage::scale_to_reference (\fBBimage\fP * pref, \fBBimage\fP * pmask = \fCNULL\fP)"

.PP
Scales and image to the given reference, searching for the correct scale\&. 
.PP
\fBParameters\fP
.RS 4
\fIpref\fP reference/template image\&. 
.br
\fIpmask\fP mask to limit correlation calculation (can be NULL)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* scaled image\&. 
.RE
.PP

.PP
Definition at line 817 of file Bimage_transform\&.cpp\&.
.SS "\fBBimage\fP * Bimage::scale_to_same_size (\fBBimage\fP * pref)"

.PP
Scales and image to the given reference\&. 
.PP
\fBParameters\fP
.RS 4
\fIpref\fP reference/template image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* scaled image\&. 
.RE
.PP

.PP
Definition at line 735 of file Bimage_transform\&.cpp\&.
.SS "\fBBplot\fP * Bimage::seamed_helix_symmetrize (double helix_rise, double helix_angle, double seam_shift, int dyad_axis, int zmin, int zmax, double radius, int norm_flag)"

.PP
Symmetrizes an image given helical symmetry parameters and seam shift parameter\&. 
.PP
\fBParameters\fP
.RS 4
\fIhelix_rise\fP rise per asymmetric unit (angstrom)\&. 
.br
\fIhelix_angle\fP rotation angle per asymmetric unit (radians)\&. 
.br
\fIseam_shift\fP translation along the seam (subunit height units)\&. 
.br
\fIdyad_axis\fP dyad axis indicator: 2=dyad axis on x-axis, otherwise none\&. 
.br
\fIzmin\fP mimimum z slice to include\&. 
.br
\fIzmax\fP maximum z slice to include\&. 
.br
\fIradius\fP radius to do symmetrizing over (pixels)\&. 
.br
\fInorm_flag\fP if 1, normalize 
.RE
.PP
\fBReturns\fP
.RS 4
Bplot* plot\&. 
.PP
.nf
The data between the z limits are replicated along the helical axis
according to the helical rise and rotation and the seam to fill the new volume.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 280 of file Bimage_helix\&.cpp\&.
.SS "double Bimage::search_views (\fBBimage\fP * ptemp, \fBView\fP * views, double hires, double lores, double search_radius, \fBBimage\fP * pmask, \fBView\fP & currview, \fBVector3\fP< double > & currshift)"

.PP
Searches a 2D/3D density map for a template\&. 
.PP
\fBParameters\fP
.RS 4
\fI*ptemp\fP the template to be searched for\&. 
.br
\fI*views\fP list of views to search\&. 
.br
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fIsearch_radius\fP radius for shift search\&. 
.br
\fI*pmask\fP mask for cross-correlation (ignored if NULL)\&. 
.br
\fI&currview\fP best current view to return\&. 
.br
\fI&currshift\fP best current shift to return\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double the best correlation coefficient\&. 
.PP
.nf
The template is rotated and cross-correlated to find the best fit.
The views must be calculated externally to allow for custom sets.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 34 of file Bimage_search\&.cpp\&.
.SS "\fBBimage\fP * Bimage::search_volume (\fBBimage\fP * ptemp, \fBView\fP * view, double alpha, double alpha_step, double hires, double lores, \fBBimage\fP * pmask, double threshold)"

.PP
Searches a 2D/3D density map for a template\&. 
.PP
\fBParameters\fP
.RS 4
\fI*ptemp\fP the template to be searched for\&. 
.br
\fI*view\fP views\&. 
.br
\fIalpha\fP rotation around view vector, <0 = use 2*PI (radians)\&. 
.br
\fIalpha_step\fP angular step size around view vector (radians)\&. 
.br
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fI*pmask\fP mask for cross-correlation (ignored if NULL)\&. 
.br
\fIthreshold\fP threshold value, if 0, threshold = FOMmax/2\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* image with the best view at each voxel and FOM block\&. 
.PP
.nf
The template is rotated and cross-correlated to find the best fit.
The views must be calculated externally to allow for custom sets.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 208 of file Bimage_search\&.cpp\&.
.SS "double Bimage::search_volume_view (\fBBimage\fP * ptemp, \fBView\fP view, double hires, double lores, \fBBimage\fP * pmask, double threshold, \fBBimage\fP * pfit)"

.PP
Searches a 2D/3D density map for a template using a specific view\&. 
.PP
\fBParameters\fP
.RS 4
\fI*ptemp\fP the template to be searched for\&. 
.br
\fIview\fP view\&. 
.br
\fIhires\fP high resolution limit\&. 
.br
\fIlores\fP low resolution limit\&. 
.br
\fI*pmask\fP mask for cross-correlation (ignored if NULL)\&. 
.br
\fIthreshold\fP threshold value, if 0, threshold = FOMmax/2\&. 
.br
\fI*pfit\fP view image with FOM block to hold results\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double maximum FOM\&. 
.PP
.nf
The template is rotated to the view and cross-correlated.
A view image is updated with the results where the correlation coefficients are higher.
The views must be calculated externally to allow for custom sets.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 151 of file Bimage_search\&.cpp\&.
.SS "long Bimage::select_images (\fBBstring\fP list)"

.PP
Definition at line 2243 of file Bimage\&.cpp\&.
.SS "void Bimage::set (long j, \fBCMYK\fP< double > color)"

.PP
Sets a color value at the given index\&. 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.br
\fIcolor\fP color value\&. 
.PP
.nf
The index refers to compound values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1215 of file Bimage\&.cpp\&.
.SS "void Bimage::set (long j, \fBComplex\fP< double > cv)"

.PP
Sets a complex value at the given index\&. 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.br
\fIcv\fP complex value\&. 
.PP
.nf
The index refers to compound values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1160 of file Bimage\&.cpp\&.
.SS "void Bimage::set (long j, double v)"

.PP
Sets a single value at the given index\&. 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.br
\fIv\fP value\&. 
.RE
.PP

.PP
Definition at line 1127 of file Bimage\&.cpp\&.
.SS "void Bimage::set (long j, \fBRGB\fP< double > color)"

.PP
Sets a color value at the given index\&. 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.br
\fIcolor\fP color value\&. 
.PP
.nf
The index refers to compound values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1176 of file Bimage\&.cpp\&.
.SS "void Bimage::set (long j, \fBRGBA\fP< double > color)"

.PP
Sets a color value at the given index\&. 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.br
\fIcolor\fP color value\&. 
.PP
.nf
The index refers to compound values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1195 of file Bimage\&.cpp\&.
.SS "void Bimage::set (long j, \fBVector3\fP< double > vec)"

.PP
Sets a 3-value vector at the given index\&. 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.br
\fIvec\fP 3-value vector\&. 
.PP
.nf
The index refers to compound values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1235 of file Bimage\&.cpp\&.
.SS "void Bimage::set (long j, \fBView\fP view)"

.PP
Sets a 3-value vector at the given index\&. 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.br
\fIview\fP 4-value view\&. 
.PP
.nf
The index refers to compound values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1253 of file Bimage\&.cpp\&.
.SS "void Bimage::set_max (double xx, double yy, double zz, long nn, double v)"

.PP
Sets a value at a given location to neigboring data elements if it is larger\&. 
.PP
\fBParameters\fP
.RS 4
\fIxx\fP x location\&. 
.br
\fIyy\fP y location\&. 
.br
\fIzz\fP z location\&. 
.br
\fInn\fP image number (4 th dimension)\&. 
.br
\fIv\fP value to assess and set\&. 
.PP
.nf
All neighboring voxels are checked and set to the given value if it is larger.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1312 of file Bimage\&.cpp\&.
.SS "long Bimage::set_subset_selection (\fBBstring\fP list)"

.PP
Sets the sub-image selections based on a list\&. 
.PP
\fBParameters\fP
.RS 4
\fIlist\fP list of sub-images to select\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of images selected\&. 
.PP
.nf
The data is not altered.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 2187 of file Bimage\&.cpp\&.
.SS "void Bimage::set_time (time_t t)\fC [inline]\fP"

.PP
Definition at line 259 of file Bimage\&.h\&.
.SS "void Bimage::set_time (tm * t)\fC [inline]\fP"

.PP
Definition at line 260 of file Bimage\&.h\&.
.SS "int Bimage::shape (int type, \fBVector3\fP< long > rect, \fBVector3\fP< double > start, double width, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Creates a shape in an image and fills it with a constant value\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP type of shape: 0=rectangle, 1=oval, 2=cylinder 
.br
\fIrect\fP three-value size of the area to be filled\&. 
.br
\fIstart\fP three-value start of area\&. 
.br
\fIwidth\fP gaussian width of smoothing function\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The edge of the area is smoothed with a function:
                    v_old(x,y,z) + fill*exp(1.618*dist/width)
    v_new(x,y,z) = ------------------------------------------
                           1 + exp(1.618*dist/width)
where   fill is the constant fill value.
        dist is the distance to the rectangular boundary defined by 
            the input size and start
        width is the gaussian width (softness)
With very small values of the gaussian width, the edge approaches a
step function.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 105 of file Bimage_edit\&.cpp\&.
.SS "int Bimage::shape (long nn, int type, \fBVector3\fP< long > rect, \fBVector3\fP< double > start, double width, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Creates a shape in an image and fills it with a constant value\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP type of edge: 0=rectangle, 1=oval, 2=cylinder 
.br
\fInn\fP sub-image\&. 
.br
\fIrect\fP three-value size of the area to be filled\&. 
.br
\fIstart\fP three-value start of area\&. 
.br
\fIwidth\fP gaussian width of smoothing function\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The edge of the area is smoothed with a function:
                    v_old(x,y,z) + fill*exp(1.618*dist/width)
    v_new(x,y,z) = ------------------------------------------
                           1 + exp(1.618*dist/width)
where   fill is the constant fill value.
        dist is the distance to the rectangular boundary defined by 
            the input size and start
        width is the gaussian width (softness)
With very small values of the gaussian width, the edge approaches a
step function.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 139 of file Bimage_edit\&.cpp\&.
.SS "int Bimage::shell (long nn, \fBVector3\fP< double > center, double minrad, double maxrad, double width, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Fills a shell within an image with a uniform value\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fIcenter\fP center of shell\&. 
.br
\fIminrad\fP minimum radius of shell\&. 
.br
\fImaxrad\fP maximum radius of shell\&. 
.br
\fIwidth\fP gaussian width of smoothing function\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
All voxels within a shell at a given location and within given radii
are set to a given fill value.
The new data replaces the old data.
The default center is {0,0,0}.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 646 of file Bimage_edit\&.cpp\&.
.SS "int Bimage::shell (\fBVector3\fP< double > center, double minrad, double maxrad, double width, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Fills a shell within an image with a uniform value\&. 
.PP
\fBParameters\fP
.RS 4
\fIcenter\fP center of shell\&. 
.br
\fIminrad\fP minimum radius of shell\&. 
.br
\fImaxrad\fP maximum radius of shell\&. 
.br
\fIwidth\fP gaussian width of smoothing function\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
All voxels within a shell at a given location and within given radii
are set to a given fill value.
The new data replaces the old data.
The default center is {0,0,0}.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 618 of file Bimage_edit\&.cpp\&.
.SS "int Bimage::shell_wrap (long nn, \fBVector3\fP< double > center, double minrad, double maxrad, double width, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Fills a shell within an image with a uniform value with wrapping\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fIcenter\fP center of shell\&. 
.br
\fIminrad\fP minimum radius of shell\&. 
.br
\fImaxrad\fP maximum radius of shell\&. 
.br
\fIwidth\fP gaussian width of smoothing function\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
All voxels within a shell at a given location and within given radii
are set to a given fill value.
The new data replaces the old data.
The default center is {0,0,0}.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 728 of file Bimage_edit\&.cpp\&.
.SS "int Bimage::shift (long nn, \fBVector3\fP< double > vec, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Shifts one sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fIvec\fP 3-value real space shift vector\&. 
.br
\fIfill_type\fP fill type for filling empty regions\&. 
.br
\fIfill\fP value to fill in empty regions\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.RE
.PP

.PP
Definition at line 605 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::shift (\fBVector3\fP< double > vec, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Shifts an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIvec\fP 3-value real space shift vector\&. 
.br
\fIfill_type\fP fill type for filling empty regions\&. 
.br
\fIfill\fP value to fill in empty regions\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.RE
.PP

.PP
Definition at line 589 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::shift_background (double bkg)"

.PP
Sets the background for each sub-image to a given value\&. 
.PP
\fBParameters\fP
.RS 4
\fIbkg\fP new background value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
The background is taken as the average of the values outside the
circle or sphere enclosed by the image.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 353 of file Bimage_background\&.cpp\&.
.SS "int Bimage::shift_wrap (long nn, \fBVector3\fP< double > vec)"

.PP
Shifts one sub-image with wrapping\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image\&. 
.br
\fIvec\fP 3-value real space shift vector\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.RE
.PP

.PP
Definition at line 655 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::shift_wrap (\fBVector3\fP< double > vec)"

.PP
Shifts an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIvec\fP 3-value real space shift vector\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.RE
.PP

.PP
Definition at line 641 of file Bimage_transform\&.cpp\&.
.SS "long Bimage::show_image ()\fC [inline]\fP"

.PP
Definition at line 563 of file Bimage\&.h\&.
.SS "void Bimage::show_image (long nn)\fC [inline]\fP"

.PP
Definition at line 564 of file Bimage\&.h\&.
.SS "double Bimage::show_maximum ()\fC [inline]\fP"

.PP
Definition at line 570 of file Bimage\&.h\&.
.SS "void Bimage::show_maximum (double v)\fC [inline]\fP"

.PP
Definition at line 572 of file Bimage\&.h\&.
.SS "double Bimage::show_minimum ()\fC [inline]\fP"

.PP
Definition at line 569 of file Bimage\&.h\&.
.SS "void Bimage::show_minimum (double v)\fC [inline]\fP"

.PP
Definition at line 571 of file Bimage\&.h\&.
.SS "double Bimage::show_scale ()\fC [inline]\fP"

.PP
Definition at line 567 of file Bimage\&.h\&.
.SS "void Bimage::show_scale (double scale)\fC [inline]\fP"

.PP
Definition at line 568 of file Bimage\&.h\&.
.SS "long Bimage::show_slice ()\fC [inline]\fP"

.PP
Definition at line 565 of file Bimage\&.h\&.
.SS "void Bimage::show_slice (long nz)\fC [inline]\fP"

.PP
Definition at line 566 of file Bimage\&.h\&.
.SS "int Bimage::shrink_wrap (\fBVector3\fP< long > nusize, \fBVector3\fP< long > translate)"

.PP
Shrinks an image to a new size with wrapping of the excluded edges\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP new image size three-value vector\&. 
.br
\fItranslate\fP three-value translation vector\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
An image is resized to a smaller size with translation and wrapping
of the excluded edges to complete periodic boundaries. The image is
first converted to floating point to prevent overflows of smaller 
data types. The new image is finally converted back to the original
data type.
The new data replaces the old data.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 432 of file Bimage_resize\&.cpp\&.
.SS "void Bimage::simple_to_complex ()"

.PP
A simple image is converted to a complex image\&. 
.PP
.nf
The input image is written into the real part of the complex image.

.fi
.PP
 
.PP
Definition at line 22 of file Bimage_complex\&.cpp\&.
.SS "void Bimage::simple_to_rgb ()"

.PP
A simple image is converted to a color image\&. 
.PP
.nf
All three color values in each voxel are the same (i.e., gray).

.fi
.PP
 
.PP
Definition at line 21 of file Bimage_color\&.cpp\&.
.SS "void Bimage::simple_to_rgba ()"

.PP
A simple image is converted to a color image\&. 
.PP
.nf
All three color values in each voxel are the same (i.e., gray).
The alpha value is set to 255.

.fi
.PP
 
.PP
Definition at line 58 of file Bimage_color\&.cpp\&.
.SS "\fBVector3\fP<long> Bimage::size () const\fC [inline]\fP"

.PP
Definition at line 381 of file Bimage\&.h\&.
.SS "void Bimage::size (long nx, long ny, long nz)\fC [inline]\fP"

.PP
Definition at line 382 of file Bimage\&.h\&.
.SS "void Bimage::size (\fBVector3\fP< long > vec)\fC [inline]\fP"

.PP
Definition at line 383 of file Bimage\&.h\&.
.SS "void Bimage::size (vector< long > vec)\fC [inline]\fP"

.PP
Definition at line 384 of file Bimage\&.h\&.
.SS "long Bimage::sizeX () const\fC [inline]\fP"

.PP
Definition at line 388 of file Bimage\&.h\&.
.SS "void Bimage::sizeX (long nx)\fC [inline]\fP"

.PP
Definition at line 385 of file Bimage\&.h\&.
.SS "long Bimage::sizeY () const\fC [inline]\fP"

.PP
Definition at line 389 of file Bimage\&.h\&.
.SS "void Bimage::sizeY (long ny)\fC [inline]\fP"

.PP
Definition at line 386 of file Bimage\&.h\&.
.SS "long Bimage::sizeZ () const\fC [inline]\fP"

.PP
Definition at line 390 of file Bimage\&.h\&.
.SS "void Bimage::sizeZ (long nz)\fC [inline]\fP"

.PP
Definition at line 387 of file Bimage\&.h\&.
.SS "int Bimage::slices_to_images ()"

.PP
Changes the slices in a 3D image into a set of 2D images\&. 
.PP
\fBReturns\fP
.RS 4
int error code (<0 means failure)\&. 
.RE
.PP

.PP
Definition at line 2111 of file Bimage\&.cpp\&.
.SS "void Bimage::smallest (\fBBimage\fP * p)"

.PP
Selects the smallest of each pixel from two images\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP other image\&. 
.RE
.PP

.PP
Definition at line 4005 of file Bimage\&.cpp\&.
.SS "double Bimage::snvariance (double snradius)"

.PP
Calculates the ratio of variance inside and outside a given radius\&. 
.PP
\fBParameters\fP
.RS 4
\fIsnradius\fP radius of signal\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double the SNR\&. 
.PP
.nf
The region outside the radial limit is considered noise and the region
inside is considered signal plus noise.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1532 of file Bimage_helix\&.cpp\&.
.SS "long Bimage::space_group ()\fC [inline]\fP"

.PP
Definition at line 602 of file Bimage\&.h\&.
.SS "void Bimage::space_group (unsigned int grp)\fC [inline]\fP"

.PP
Definition at line 606 of file Bimage\&.h\&.
.SS "int Bimage::sphere (\fBVector3\fP< double > center, double radius, double width = \fC0\fP, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Fills a sphere within an image with a uniform value\&. 
.PP
\fBParameters\fP
.RS 4
\fIcenter\fP three vector center of sphere\&. 
.br
\fIradius\fP sphere radius\&. 
.br
\fIwidth\fP gaussian width of smoothing function\&. 
.br
\fIfill_type\fP FILL_AVERAGE, FILL_BACKGROUND, FILL_USER\&. 
.br
\fIfill\fP fill value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
All voxels within a sphere at a given location and with a given radius 
are increased by a given fill value.
The new data replaces the old data.
The default center is {0,0,0}.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 512 of file Bimage_edit\&.cpp\&.
.SS "\fBBimage\fP * Bimage::split_channels ()"

.PP
Splits the channels into individual images\&. 
.PP
\fBReturns\fP
.RS 4
Bimage* new image\&. 
.PP
.nf
The channels are converted to successive sets of images.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1992 of file Bimage\&.cpp\&.
.SS "void Bimage::square ()"

.PP
Calculates the square of an image\&. 
.PP
.nf
Values less than zero are set to zero.
Values greater than the data type maximum are set to the maximum.

.fi
.PP
 
.PP
Definition at line 678 of file Bimage_rescale\&.cpp\&.
.SS "void Bimage::square_root ()"

.PP
Calculates the square root of an image\&. 
.PP
.nf
Values less than zero are set to zero.
Values greater than the data type maximum are set to the maximum.

.fi
.PP
 
.PP
Definition at line 698 of file Bimage_rescale\&.cpp\&.
.SS "double Bimage::standard_deviation ()\fC [inline]\fP"

.PP
Definition at line 547 of file Bimage\&.h\&.
.SS "void Bimage::standard_deviation (double d)\fC [inline]\fP"

.PP
Definition at line 552 of file Bimage\&.h\&.
.SS "long Bimage::statistics ()"

.PP
Calculates the statistics for an image\&. 
.PP
\fBReturns\fP
.RS 4
long number of errors\&. 
.RE
.PP

.PP
Definition at line 22 of file Bimage_stats\&.cpp\&.
.SS "long Bimage::statistics (\fBBimage\fP * pmask, double & regavg, double & regstd)"

.PP
Calculates the statistics for a region in an image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pmask\fP region\&. 
.br
\fI&regavg\fP region average to be calculated\&. 
.br
\fI&regstd\fP region standard deviation to be calculated\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of voxels\&. 
.RE
.PP

.PP
Definition at line 167 of file Bimage_stats\&.cpp\&.
.SS "long Bimage::statistics (long img_num)"

.PP
Calculates the statistics for a sub-image\&. 
.PP
\fBParameters\fP
.RS 4
\fIimg_num\fP sub-image number\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of errors\&. 
.RE
.PP

.PP
Definition at line 101 of file Bimage_stats\&.cpp\&.
.SS "long Bimage::stats_in_mask (long nn, \fBBimage\fP * pmask)"

.PP
Calculates the statistics for an image for each level in a mask\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image number\&. 
.br
\fI*pmask\fP mask with two or more levels 
.RE
.PP
\fBReturns\fP
.RS 4
long number of levels (0 means failure)\&. 
.RE
.PP

.PP
Definition at line 508 of file Bimage_stats\&.cpp\&.
.SS "long Bimage::stats_in_poly (long nn, int nvert, \fBVector3\fP< double > * poly, double & vavg, double & vstd)"

.PP
Calculates the statistics for an image within the given polyhedron\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image number\&. 
.br
\fInvert\fP number of polygon vertices\&. 
.br
\fI*poly\fP array of polygon vertices\&. 
.br
\fI&vavg\fP return value for the average\&. 
.br
\fI&vstd\fP return value for the standard deviation\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of values (0 means failure)\&. 
.PP
.nf
If a voxel lies within the specified polyhedron, it is included in
the statistical calculations.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 437 of file Bimage_stats\&.cpp\&.
.SS "long Bimage::stats_in_shape (long nn, int type, \fBVector3\fP< long > start, \fBVector3\fP< long > end, double & vavg, double & vstd)"

.PP
Calculates the statistics for an image within the given box\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image number\&. 
.br
\fItype\fP type of selection: 1=rectangle, 2=ellipse\&. 
.br
\fIstart\fP starting coordinates\&. 
.br
\fIend\fP ending coordinates\&. 
.br
\fI&vavg\fP return value for the average\&. 
.br
\fI&vstd\fP return value for the standard deviation\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of values (0 means failure)\&. 
.PP
.nf
If a voxel lies within the specified box, it is included in
the statistical calculations.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 300 of file Bimage_stats\&.cpp\&.
.SS "long Bimage::stats_within_radii (long nn, \fBVector3\fP< double > loc, double rad_min, double rad_max, double & vavg, double & vstd)"

.PP
Calculates the statistics for an image within given radii from a location\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image number\&. 
.br
\fIloc\fP center of shell\&. 
.br
\fIrad_min\fP minimum radius (pixel units)\&. 
.br
\fIrad_max\fP maximum radius (pixel units)\&. 
.br
\fI&vavg\fP return value for the average\&. 
.br
\fI&vstd\fP return value for the standard deviation\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of values (0 means failure)\&. 
.PP
.nf
If a voxel lies within the specified radii, it is included in
the statistical calculations.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 223 of file Bimage_stats\&.cpp\&.
.SS "int Bimage::subimage_information ()"

.PP
Prints out header information for all sub-images\&. 
.PP
\fBReturns\fP
.RS 4
int error code (<0 means failure)\&. 
.RE
.PP

.PP
Definition at line 2634 of file Bimage\&.cpp\&.
.SS "void Bimage::subtract (\fBBimage\fP * p)"

.PP
Subtracts another image from an image\&. 
.PP
\fBParameters\fP
.RS 4
\fI*p\fP image to be added\&. 
.PP
.nf
Requirement: The images must have the same size.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 3678 of file Bimage\&.cpp\&.
.SS "int Bimage::subtract_background ()"

.PP
Subtracts the background for each sub-image\&. 
.PP
\fBReturns\fP
.RS 4
int 0, <0 on error\&. 
.PP
.nf
The background is taken from the sub-image structures.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 339 of file Bimage_background\&.cpp\&.
.SS "void Bimage::sum (long m, \fBBimage\fP ** p)"

.PP
Sums an array of images with their FOM blocks\&. 
.PP
\fBParameters\fP
.RS 4
\fIm\fP number of images in the array\&. 
.br
\fI**p\fP array of images\&. 
.PP
.nf
The images must all have the same dimensions.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 23 of file Bimage_combine\&.cpp\&.
.SS "void Bimage::sum_images ()"

.PP
Adds all sub-images\&. 
.PP
Definition at line 3503 of file Bimage\&.cpp\&.
.SS "vector< \fBBsuperpixel\fP > Bimage::superpixels (long step, double colorweight = \fC0\&.2\fP, long iterations = \fC10\fP, double stop = \fC1\fP)"

.PP
Segment the image into superpixels\&. 
.PP
\fBParameters\fP
.RS 4
\fIstep\fP initial superpixel intervals\&. 
.br
\fIcolorweight\fP weight of color differences compared to spatial distances\&. 
.br
\fIiterations\fP maximum number of iterations\&. 
.br
\fIstop\fP stopping condition as a percent of voxel changes\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<Bsuperpixel> array of superpixels\&. 
.PP
.nf
The segment array contents are:
0       count
1-3     coordinates
4+      channels
last    color weight for the segment - maximum squared distance

The mask is linked to the original image for return.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1819 of file Bimage_segment\&.cpp\&.
.SS "vector< \fBBsuperpixel\fP > Bimage::superpixels (long step, double colorweight = \fC0\&.2\fP, long iterations = \fC10\fP, long bin_levels = \fC1\fP, double stop = \fC1\fP)"

.PP
Definition at line 1886 of file Bimage_segment\&.cpp\&.
.SS "vector< \fBBsuperpixel\fP > Bimage::superpixels_from_mask (long cc, long step)"

.PP
Create superpixels from a multilevel mask\&. 
.PP
\fBParameters\fP
.RS 4
\fIcc\fP number of channels in the original image\&. 
.br
\fIstep\fP distance limit to determine neigbors\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<Bsuperpixel> array of superpixels\&. 
.RE
.PP

.PP
Definition at line 1768 of file Bimage_segment\&.cpp\&.
.SS "int Bimage::superpixels_update (\fBBimage\fP * pmask, vector< long > vstep, double colorweight, vector< \fBBsuperpixel\fP > & seg)"

.PP
Definition at line 1556 of file Bimage_segment\&.cpp\&.
.SS "\fBBimage\fP * Bimage::surface_to_topograph (double threshold, int dir = \fC0\fP)"

.PP
Converts a 3D image to a 2D height image\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP threshold to define the surface (assuming positive density)\&. 
.br
\fIdir\fP direction: 0=bottom up, 1=top down\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* 2D height image\&. 
.PP
.nf
The threshold defines the surface of the positive density in the 3D image.
Each line of voxels in the z-direction is scanned for the voxel
exceeding the threshold with the highest z-index.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 119 of file Bimage_topo\&.cpp\&.
.SS "double Bimage::symmetrize (\fBBstring\fP & symmetry_string, int flag)\fC [inline]\fP"

.PP
Definition at line 1233 of file Bimage\&.h\&.
.SS "double Bimage::symmetrize (\fBBstring\fP & symmetry_string, \fBView\fP ref_view, int flag)\fC [inline]\fP"

.PP
Definition at line 1241 of file Bimage\&.h\&.
.SS "double Bimage::symmetrize (\fBBsymmetry\fP sym, int flag)\fC [inline]\fP"

.PP
Definition at line 1237 of file Bimage\&.h\&.
.SS "double Bimage::symmetrize (\fBBsymmetry\fP sym, \fBView\fP ref_view, int flag)"

.PP
Applies point group symmetry to an image\&. 
.PP
\fBParameters\fP
.RS 4
\fIsym\fP point group\&. 
.br
\fIref_view\fP reference view vector and rotation angle\&. 
.br
\fIflag\fP flag to normalize after symmetrization\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double symmetry FOM\&. 
.PP
.nf
The point group symmetry operations are applied to an image with an
orientation defined by the reference symmetry axis (default {0,0,1}). 
The fill value is taken from image's background value.
The symmetry FOM is taken as the ratio of the power after to before
symmetrization. 

.fi
.PP
 
.RE
.PP

.PP
Definition at line 31 of file Bimage_symmetry\&.cpp\&.
.SS "double Bimage::symmetrize_cyclic (int cyclic, int flag)\fC [inline]\fP"

.PP
Definition at line 1245 of file Bimage\&.h\&.
.SS "int Bimage::symmetrize_cylinder ()"

.PP
Calculates a cylindrically symmetrized map\&. 
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The image is replaced with its cylindrically symmetrized version.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 585 of file Bimage_helix\&.cpp\&.
.SS "\fBBimage\fP * Bimage::symmetrize_cylinder (int flag)"

.PP
Calculates a cylindrically symmetrized map\&. 
.PP
\fBParameters\fP
.RS 4
\fIflag\fP 0: 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* 2D image with the cylindrical average\&. 
.PP
.nf
A 2D cylindrically symmetrized average is calculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 524 of file Bimage_helix\&.cpp\&.
.SS "string& Bimage::symmetry ()\fC [inline]\fP"

.PP
Definition at line 607 of file Bimage\&.h\&.
.SS "void Bimage::symmetry (string grp)\fC [inline]\fP"

.PP
Definition at line 611 of file Bimage\&.h\&.
.SS "\fBMatrix3\fP Bimage::symmetry_equivalent (\fBBimage\fP * pref, \fBBimage\fP * pmask, \fBBsymmetry\fP & sym)"

.PP
Finds the symmetry equivalent orientation of a particle with respect to a template\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pref\fP template to test against (same size as input image)\&. 
.br
\fI*pmask\fP mask to limit correlation calculation\&. 
.br
\fI*sym\fP symmetry structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBMatrix3\fP transformed image\&. 
.PP
.nf
For point groups up to tetrahedral symmetry, there is an ambiguity in the
orientation of a particle even though it is oriented according to the 
standard orientation for the symmetry.
A template is used to select the desired orientation and the image is transformed.
Both the input image and template must be in the standard orientation
for the point group.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 656 of file Bimage_symmetry\&.cpp\&.
.SS "\fBMatrix3\fP Bimage::symmetry_equivalent_cyclic (\fBBimage\fP * pref, \fBBimage\fP * pmask, \fBBsymmetry\fP & sym)"

.PP
Finds the cyclic symmetry equivalent orientation of a particle with respect to a template\&. 
.PP
\fBParameters\fP
.RS 4
\fI*pref\fP template to test against (same size as input image)\&. 
.br
\fI*pmask\fP mask to limit correlation calculation\&. 
.br
\fI*sym\fP symmetry structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBMatrix3\fP transformed image\&. 
.PP
.nf
For point groups up to tetrahedral symmetry, there is an ambiguity in the
orientation of a particle even though it is oriented according to the 
standard orientation for the symmetry.
A template is used to select the desired orientation and the image is transformed.
Both the input image and template must be in the standard orientation
for the point group.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 778 of file Bimage_symmetry\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::test_helix_parameters (double angle, double hires, double lores, \fBVector3\fP< long > mask_size, \fBVector3\fP< long > mask_start, long max_iter, \fBfft_plan\fP planf, \fBfft_plan\fP planb, double & cc)"

.PP
Definition at line 831 of file Bimage_helix\&.cpp\&.
.SS "double Bimage::test_helix_parameters (double rise, double angle, \fBVector3\fP< long > mask_size, \fBVector3\fP< long > mask_start)"

.PP
Definition at line 1022 of file Bimage_helix\&.cpp\&.
.SS "\fBBimage\fP * Bimage::thickness (double reference, double emfp)"

.PP
Calculates a thickness based on intensities with respect to a reference\&. 
.PP
\fBParameters\fP
.RS 4
\fIreference\fP reference intensity\&. 
.br
\fIemfp\fP proportionaility coefficient\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<double> 7-value array of parameters\&. 
.PP
.nf
The thickness for each pixel is:
    t = emfp * ln(Iref/Ipix)
If Ipix <= 0, t = 0

.fi
.PP
 
.RE
.PP

.PP
Definition at line 951 of file Bimage_rescale\&.cpp\&.
.SS "vector< \fBVector3\fP< long > > Bimage::tile_coordinates (\fBVector3\fP< long > & start, \fBVector3\fP< long > & region, \fBVector3\fP< long > & tile_size, \fBVector3\fP< long > & step_size, int exceed)"

.PP
Generates a set of tile coordinates for an image\&. 
.PP
\fBParameters\fP
.RS 4
\fI&start\fP 3-vector start for first tile to be extracted\&. 
.br
\fI&region\fP 3-vector size of part of image to be extracted (0 = whole image)\&. 
.br
\fI&tile_size\fP 3-vector size of extracted image\&. 
.br
\fI&step_size\fP 3-vector size of intervals between tiles\&. 
.br
\fIexceed\fP flag to allow tiles to exceed the input image size\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<\fBVector3<long>\fP> set of coordinates\&. 
.PP
.nf
Calculating the coordinates of tiles of a specified size and within
a specified region within the image. The overlap is specified by
the step size and a flag indicates the option to exceed the
bounds of the image.
The old data is not affected.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 258 of file Bimage_extract\&.cpp\&.
.SS "vector< \fBVector3\fP< long > > Bimage::tile_coordinates (\fBVector3\fP< long > tile_size, \fBVector3\fP< long > & step_size)"

.PP
Generates a set of tile coordinates to fit in the image dimensions\&. 
.PP
\fBParameters\fP
.RS 4
\fItile_size\fP 3-vector size of extracted image\&. 
.br
\fI&step_size\fP 3-vector size of intervals between tiles\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<\fBVector3<long>\fP> set of coordinates\&. 
.PP
.nf
Calculating the coordinates of tiles of a specified size to fit within
the bounds of the image. The overlap is specified by
the given step size, which is adjusted to fit the image bounds.
The old data is not affected.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 328 of file Bimage_extract\&.cpp\&.
.SS "\fBBimage\fP * Bimage::tile_mask (long step)"

.PP
Converts a mask to a tiled multilevel mask\&. 
.PP
\fBParameters\fP
.RS 4
\fIstep\fP isotropic tile edge size\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new mask\&. 
.PP
.nf
The old data is unmodified.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1453 of file Bimage_mask\&.cpp\&.
.SS "long Bimage::to_mask ()\fC [inline]\fP"

.PP
Definition at line 1366 of file Bimage\&.h\&.
.SS "long Bimage::to_mask (double threshold)"

.PP
Change the image to a mask\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP set mask above this value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
long number of mask voxels\&. 
.PP
.nf
The input image is effectively thresholded and a mask with 0 and 1 generated.
The new data type is unsigned char/byte.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 51 of file Bimage_mask\&.cpp\&.
.SS "\fBBimage\fP * Bimage::topograph_to_surface (\fBBimage\fP * psd, long nz, double density, double resolution)"

.PP
Converts a 2D AFM image to a 3D density map\&. 
.PP
\fBParameters\fP
.RS 4
\fI*psd\fP 2D standard deviation image\&. 
.br
\fInz\fP z dimension of the new 3D map\&. 
.br
\fIdensity\fP density inside the surface (Da/A3)\&. 
.br
\fIresolution\fP sigma bounds\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The 2D image is expanded in the z direction according to:
                          voxel_density
dens[x,y,z] = --------------------------------------
              1+exp(factor*(z-zdis[x,y])/sigma[x,y])
where   voxel_density is the total density attributed to a voxel
        factor = 1.618
        z - zdis[x,y] is the z distance from the surface
        sigma is a standard deviation term to describe the surface variability.
The sigma term can be set automatically or given by an input standard deviation map.
The position of the surface is calculated as:
zdis[x,y] = loz + (hiz - loz)*(image[x,y] - min)/(max - min)
where   loz and hiz are the lowest and highest points of the surface in the 3D map
        min and max are the image minimum and maximum values

.fi
.PP
 
.RE
.PP

.PP
Definition at line 39 of file Bimage_topo\&.cpp\&.
.SS "\fBBimage\fP * Bimage::track_gradient (double threshold, int flag = \fC0\fP)"

.PP
Generates a segmented image from peaks above a threshold value\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP the lowest level to include voxels in regions\&. 
.br
\fIflag\fP Track towards maxima (0) or minima (1)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* integer image containing tracking indices\&. 
.PP
.nf
Every voxel with a value above (below) the threshold is tagged by a pointer
pointing to the highest (lowest) value within a kernel of 3x3x3.
A peak is defined as pointing to itself, while every other voxel
points towards a peak.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 432 of file Bimage_segment\&.cpp\&.
.SS "\fBBimage\fP * Bimage::transform (long nn, \fBVector3\fP< long > nusize, \fBVector3\fP< double > scale, \fBVector3\fP< double > origin, \fBVector3\fP< double > translate, \fBMatrix3\fP mat, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Transforms a sub-image by translation, rotation, scaling and skewing, returning a single new image\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP sub-image to process\&. 
.br
\fInusize\fP 3-value new image size\&. 
.br
\fIscale\fP 3-value scale factor vector to apply\&. 
.br
\fIorigin\fP 3-value origin for rotation and skewing\&. 
.br
\fItranslate\fP 3-value vector for translation after transformation\&. 
.br
\fImat\fP 3x3 rotation or skewing matrix\&. 
.br
\fIfill_type\fP fill type for filling empty regions\&. 
.br
\fIfill\fP value to fill in empty regions\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new image\&. 
.PP
.nf
A number of transformation types are combined in this function for
efficiency. The basic operation is the conversion of the image data 
from the original data block to a new data block, applying a 
transformation matrix and translation vector with a specified origin 
followed by an optional translation:
    y = R*x + t
where   R is the rotation/skewing/scaling matrix.
        t is the translation vector.
Note: The image is converted to floating point to improve interpolation.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 138 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::transform (\fBVector3\fP< double > scale, \fBVector3\fP< double > origin, \fBVector3\fP< double > translate, \fBMatrix3\fP mat, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Transforms an image by translation, rotation, scaling and skewing, in place\&. 
.PP
\fBParameters\fP
.RS 4
\fIscale\fP 3-value scale factor vector to apply\&. 
.br
\fIorigin\fP 3-value origin for rotation and skewing\&. 
.br
\fItranslate\fP 3-value vector for translation after transformation\&. 
.br
\fImat\fP 3x3 rotation or skewing matrix\&. 
.br
\fIfill_type\fP fill type for filling empty regions\&. 
.br
\fIfill\fP value to fill in empty regions\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 error code\&. 
.PP
.nf
A number of transformation types are combined in this function for
efficiency. The basic operation is the conversion of the image data 
from the original data block to a new data block, applying a 
transformation matrix and translation vector with a specified origin 
followed by an optional translation:
    y = R*x + t
where   R is the rotation/skewing/scaling matrix.
        t is the translation vector.
Note: The image is converted to floating point to improve interpolation.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 37 of file Bimage_transform\&.cpp\&.
.SS "\fBBimage\fP * Bimage::transform (\fBVector3\fP< long > nusize, \fBVector3\fP< double > scale, \fBVector3\fP< double > origin, \fBVector3\fP< double > translate, \fBMatrix3\fP mat, int fill_type = \fC0\fP, double fill = \fC0\fP)"

.PP
Transforms an image by translation, rotation, scaling and skewing, returning a new image\&. 
.PP
\fBParameters\fP
.RS 4
\fInusize\fP 3-value new image size\&. 
.br
\fIscale\fP 3-value scale factor vector to apply\&. 
.br
\fIorigin\fP 3-value origin for rotation and skewing\&. 
.br
\fItranslate\fP 3-value vector for translation after transformation\&. 
.br
\fImat\fP 3x3 rotation or skewing matrix\&. 
.br
\fIfill_type\fP fill type for filling empty regions\&. 
.br
\fIfill\fP value to fill in empty regions\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* new image\&. 
.PP
.nf
A number of transformation types are combined in this function for
efficiency. The basic operation is the conversion of the image data 
from the original data block to a new data block, applying a 
transformation matrix and translation vector with a specified origin 
followed by an optional translation:
    y = R*x + t
where   R is the rotation/skewing/scaling matrix.
        t is the translation vector.
Note: The image is converted to floating point to improve interpolation.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 75 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::transform_lines ()"

.PP
Definition at line 1365 of file Bimage_helix\&.cpp\&.
.SS "void Bimage::transform_voxel (long i, \fBBimage\fP * pt, long nn, \fBVector3\fP< double > oldorigin, \fBVector3\fP< double > nuorigin, \fBMatrix3\fP affmat, double fill)"

.PP
Definition at line 104 of file Bimage_transform\&.cpp\&.
.SS "int Bimage::truncate (double minim, double maxim, double setmin, double setmax)"

.PP
Truncates image data to a given minimum and maximum\&. 
.PP
\fBParameters\fP
.RS 4
\fIminim\fP minimum\&. 
.br
\fImaxim\fP maximum\&. 
.br
\fIsetmin\fP value to set voxels smaller than minimum\&. 
.br
\fIsetmax\fP value to set voxels larger than maximum\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
All values smaller than the new minimum are set to the new minimum
and all values larger than the new maximum are set to the new maximum.
In cases where the given minimum and maximum are outside the data
type ranges, they are reset to the data type range limits.
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 277 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::truncate_to_avg (double minim, double maxim)"

.PP
Sets voxels in image data exceeding a given minimum and maximum to the average\&. 
.PP
\fBParameters\fP
.RS 4
\fIminim\fP minimum\&. 
.br
\fImaxim\fP maximum\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
All values smaller than the new minimum or larger than the new 
maximum are set to the image average.
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 349 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::truncate_to_background (double minim, double maxim)"

.PP
Sets voxels in image data exceeding a given minimum and maximum to the image background\&. 
.PP
\fBParameters\fP
.RS 4
\fIminim\fP minimum\&. 
.br
\fImaxim\fP maximum\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
All values smaller than the new minimum or larger than the new 
maximum are set to the background value.
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 367 of file Bimage_rescale\&.cpp\&.
.SS "int Bimage::truncate_to_min_max (double minim, double maxim)"

.PP
Truncates image data to a given minimum and maximum\&. 
.PP
\fBParameters\fP
.RS 4
\fIminim\fP minimum\&. 
.br
\fImaxim\fP maximum\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
All values smaller than the new minimum are set to the new minimum
and all values larger than the new maximum are set to the new maximum.
In cases where the given minimum and maximum are outside the data
type ranges, they are reset to the data type range limits.
The new data replaces the old data.
Image statistics are recalculated.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 331 of file Bimage_rescale\&.cpp\&.
.SS "double Bimage::tube_interpolate (long i, int h, int k, double latconst, int zmin, int zmax, double radius, int norm_flag = \fC1\fP)"

.PP
Definition at line 73 of file Bimage_helix\&.cpp\&.
.SS "double Bimage::tube_symmetrize (int h, int k, double latconst, int zmin, int zmax, double radius, int norm_flag = \fC1\fP)"

.PP
Symmetrizes an image given tubular lattice parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fIh\fP units along u vector\&. 
.br
\fIk\fP units along v vector\&. 
.br
\fIlatconst\fP lattice constant (angstrom)\&. 
.br
\fIzmin\fP mimimum z slice to include\&. 
.br
\fIzmax\fP maximum z slice to include\&. 
.br
\fIradius\fP radius to do symmetrizing over (pixels)\&. 
.br
\fInorm_flag\fP if 1, normalize 
.RE
.PP
\fBReturns\fP
.RS 4
double R factor\&. 
.PP
.nf
The data between the z limits are replicated along the helical axis
according to the lattice parameters to fill the new volume.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 633 of file Bimage_helix\&.cpp\&.
.SS "\fBUnitCell\fP Bimage::unit_cell ()\fC [inline]\fP"

.PP
Definition at line 619 of file Bimage\&.h\&.
.SS "void Bimage::unit_cell (\fBUnitCell\fP uc)\fC [inline]\fP"

.PP
Definition at line 612 of file Bimage\&.h\&.
.SS "\fBBimage\fP * Bimage::unpack_combined_transform ()"

.PP
Unpacks a complex transform obtained from two real images\&. 
.PP
\fBReturns\fP
.RS 4
Bimage* transform of second image\&. 
.PP
.nf
The complex image must be a Fourier transform obtained from two real 
space images which were packed into the real and imaginary parts
of the complex image before Fourier transformation.
The input image is used to hold the transform of the first image.
A new image is created to hold the transform of the second image.
Both these images are complex floating point.
Note: Images with even dimensions cannot be unpacked exactly because
    the inverse is not present when x=nx/2 or y=ny/2 or z=nz/2.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 814 of file Bimage_complex\&.cpp\&.
.SS "int Bimage::unpack_transform (int img_select, unsigned char * data, \fBFourierType\fP tf)"

.PP
Definition at line 2417 of file Bimage\&.cpp\&.
.SS "int Bimage::unpack_transform (unsigned char * data, \fBFourierType\fP tf)"

.PP
Definition at line 2412 of file Bimage\&.cpp\&.
.SS "void Bimage::update_from_meta_data ()"

.PP
Update sub-image information from the metadata\&. 
.PP
.nf
The metadata in JSON format is transferred to the sub-image information.

.fi
.PP
 
.PP
Definition at line 734 of file Bimage\&.cpp\&.
.SS "vector<double> Bimage::values (long i)\fC [inline]\fP"

.PP
Definition at line 292 of file Bimage\&.h\&.
.SS "void Bimage::values (long i, vector< double > val)\fC [inline]\fP"

.PP
Definition at line 298 of file Bimage\&.h\&.
.SS "vector< double > Bimage::values (long nn, \fBVector3\fP< double > vox)"

.PP
Returns an array with all channel data at the given coordinates\&. 
.PP
\fBParameters\fP
.RS 4
\fInn\fP image index\&. 
.br
\fIvox\fP voxel coordinates\&. 
.RE
.PP
\fBReturns\fP
.RS 4
vector<double> value array\&. 
.PP
.nf
The values of all channels are returned in double precision.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1012 of file Bimage\&.cpp\&.
.SS "double Bimage::variance ()\fC [inline]\fP"

.PP
Definition at line 548 of file Bimage\&.h\&.
.SS "int Bimage::variance (\fBBimage\fP * pweight)"

.PP
Calculates the local variance weighed with the given image\&. 
.PP
\fBParameters\fP
.RS 4
\fIpweight\fP weight image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The local variance is calculated using the given image as kernel weights.
The calculation is threaded if compiled with GCD or OpenMP.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 773 of file Bimage_stats\&.cpp\&.
.SS "int Bimage::variance (long kernel_size, int flag = \fC0\fP)"

.PP
Calculates the local variance within the given kernel\&. 
.PP
\fBParameters\fP
.RS 4
\fIkernel_size\fP size of kernel edge\&. 
.br
\fIflag\fP selects type of output\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The local variance within a kernel is calculated.
The calculation is threaded if compiled with GCD or OpenMP.
Flag values:
0   variance
1   standard deviation
2   poisson excess variance

.fi
.PP
 
.RE
.PP

.PP
Definition at line 643 of file Bimage_stats\&.cpp\&.
.SS "int Bimage::variance (\fBVector3\fP< long > kernel_size, int flag = \fC0\fP)"

.PP
Calculates the local variance within the given kernel\&. 
.PP
\fBParameters\fP
.RS 4
\fIkernel_size\fP 3-value size of kernel edge\&. 
.br
\fIflag\fP selects type of output\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int 0\&. 
.PP
.nf
The local variance within a kernel is calculated.
The calculation is threaded if compiled with GCD or OpenMP.
Flag values:
0   variance
1   standard deviation
2   poisson excess variance

.fi
.PP
 
.RE
.PP

.PP
Definition at line 671 of file Bimage_stats\&.cpp\&.
.SS "\fBBimage\fP * Bimage::variance_mask (long kernel_size, double lowvar = \fC1e\-6\fP, int bkg_flag = \fC0\fP)"

.PP
Calculates a mask based on local variance\&. 
.PP
\fBParameters\fP
.RS 4
\fIkernel_size\fP size of kernel edge\&. 
.br
\fIlowvar\fP low variance threshold\&. 
.br
\fIbkg_flag\fP flag to generate a background with value -1\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Bimage* binary mask\&. 
.PP
.nf
The local variance within a kernel is calculated and used to generate the mask.
A threshold is calculated to define the foreground and background.
Excluded regions are defined by a low variance parameter.
Foreground is set to 1, background is set to -1, excluded areas are set to 0.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1405 of file Bimage_mask\&.cpp\&.
.SS "double Bimage::variance_threshold (double lowvar)"

.PP
Calculates a threshold for a local variance image\&. 
.PP
\fBParameters\fP
.RS 4
\fIlowvar\fP low variance threshold\&. 
.RE
.PP
\fBReturns\fP
.RS 4
double threshold\&. 
.PP
.nf
A threshold is calculated to define the foreground and background.
Excluded regions are defined by a low variance parameter.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1346 of file Bimage_mask\&.cpp\&.
.SS "\fBVector3\fP< double > Bimage::vector3 (long j)"

.PP
Returns a 3-value vector at the given index\&. 
.PP
\fBParameters\fP
.RS 4
\fIj\fP index\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBVector3<double>\fP the 3-value vector\&. 
.PP
.nf
The index refers to compound values.

.fi
.PP
 
.RE
.PP

.PP
Definition at line 1050 of file Bimage\&.cpp\&.
.SS "void Bimage::vector_to_simple ()"

.PP
A vector image is converted to a simple image\&. 
.PP
.nf
The new value for each voxel is the length of each vector.

.fi
.PP
 
.PP
Definition at line 4183 of file Bimage\&.cpp\&.
.SS "void Bimage::view (double vx, double vy, double vz, double va)\fC [inline]\fP"

.PP
Definition at line 600 of file Bimage\&.h\&.
.SS "void Bimage::view (\fBView\fP vw)\fC [inline]\fP"

.PP
Definition at line 601 of file Bimage\&.h\&.
.SS "double Bimage::voxel_size ()\fC [inline]\fP"

.PP
Definition at line 509 of file Bimage\&.h\&.
.SS "bool Bimage::within_boundaries (long xx, long yy, long zz)\fC [inline]\fP"

.PP
Definition at line 465 of file Bimage\&.h\&.
.SS "template<typename T > bool Bimage::within_boundaries (\fBVector3\fP< T > loc)\fC [inline]\fP"

.PP
Definition at line 460 of file Bimage\&.h\&.
.SS "int Bimage::write (\fBBstring\fP & fn)"

.PP
Definition at line 2395 of file Bimage\&.cpp\&.
.SS "void Bimage::zero_fourier_origin ()"

.PP
Zeroes the first voxel in each image\&. 
.PP
Definition at line 2070 of file Bimage\&.cpp\&.
.SS "int Bimage::zero_origin ()"

.PP
Shifts the origins to zero with wrapping\&. 
.PP
\fBReturns\fP
.RS 4
int error code\&. 
.RE
.PP

.PP
Definition at line 722 of file Bimage_transform\&.cpp\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBBsub_image\fP* Bimage::image"

.PP
Definition at line 186 of file Bimage\&.h\&.
.SS "\fBBimage\fP* Bimage::next"

.PP
Definition at line 163 of file Bimage\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Bsoft from the source code\&.
