/**
@file	tcltk_bimage.cpp
@brief	A shared object to load Bsoft image files in TCL/Tk
@author Bernard Heymann
@date	Created: 20010210
@date	Modified: 20210110
**/

// Tk must be included before anything else to remedy symbol conflicts
#include <tk.h>

//#include "tcltk_bimage.h"
#include "rwimg.h"
#include "mg_ctf.h"
#include "Vector3.h"
#include "Euler.h"
#include "linked_list.h"
#include "timer.h"
#include "utilities.h"

// Declaration of global variables
extern int		verbose;		// Level of output to the screen
extern string	command;		// Command line
extern Bimage* 	imglist;
extern Bimage*	imgtemp;

struct Bmontage {
	int		ncol, nrow;
	int		first, skip, pad, flip;
	double	fill;
} mont = {0,0,0,0,0,0,0};

// Internal function prototypes
int			do_show(Bimage* p, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]);
int			do_magnify(Bimage* p, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]);
int			do_template(Bimage* p, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]);
Bimage*		do_montage(Bimage* p);
Tcl_Obj*	do_delete(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
Tcl_Obj*	do_get(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
Tcl_Obj*	do_line(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_set(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_switch(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_fix_type(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
Tcl_Obj*	do_stats(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_center(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_zero_origin(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_extract(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_crop(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_pad(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_invert(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_truncate(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_rescale(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_reslice(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_rotate(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_bin(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_average(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_variance(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_normalize(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_gaussian(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
Tcl_Obj*	do_histogram(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
Tcl_Obj*	do_histogram_fit(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
Tcl_Obj*	do_radial_average(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_diffraction_origin(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
int			do_fft(Bimage* p, int objc, Tcl_Obj *CONST objv[]);
Bimage*		do_powerspec(Bimage* p, int objc, Tcl_Obj *CONST objv[]);

/************************************************************************
@brief 	Implements the "Bimage" command in Tcl/Tk to access image files through Bsoft.
@param 	*interp		a Tcl interpreter within Tcl.
@param 	objc				number of arguments passed (+1).
@param 	*objv[]	arguments passed as Tcl objects.
@return 	int						Tcl result.

	Bimage command syntax:
		Bimage <action> <tcl_object> <arguments>.
		where:
			action			"exists", "open", "save", "show", "magnify", "kill", "get", "set", "reslice", 
                            "stats", "montage", "center", "zero_origin", "histogram", "powerspec", "findgold", 
                            "rps", "ctf", "ctf_fit", "pick", "extract_particles", "extract_filament", "refine"
			tcl_object		a photo object "theimg" generated by "image create photo theimg"
			arguments		action-specific arguments:
				"open"		<file_name> <image_number>
				"close"		<file_name>
				"save"	 	<file_name>
				"show"	 	<image_number> <slice_number> <mode>
				"magnify"	<x> <y> <z> <scale> <size_x> <size_y> <size_z>
				"statistics"
				"get"		<property> [arguments]
				"set"		<property> <value>
				"fixtype"
				"stats"		<image_number> <selection_type> <polygon>
				"extract"	<file_name> <image_number> <start> <end>
				"crop"		<image_number> <start> <end>
				"pad"		<xm> <ym> <zm> <xp> <yp> <zp> <filletype> <fill>
				"center"
				"zero_origin"
				"invert"
				"truncate"	<minimum> <maximum>
				"rescale"	<average> <standard_deviation>
				"reslice"	<order>
				"rotate"	<psi> <theta> <phi>
				"bin"		<bin_x> <bin_y> <bin_z>
				"average"	<k_x> <k_y> <k_z>
				"normalize"	<k_x> <k_y> <k_z>
				"montage"	<first> <columns> <rows> <skip> <pad> <fill>
				"histogram" <bins>
				"radial"	<origin_x> <origin_y> <origin_z> <angle>
				"diffori"	<origin_x> <origin_y> <origin_z>
				"fft"		<direction>
				"powerspec" <log_flag> <avg_flag> <tile.x> <tile.y> <tile.z> <tilt_axis> <tilt_angle>
				"rps"		<defocus_average> <defocus_deviation> <astigmatism_angle>
				"ctf_fit"   <defocus_average> <defocus_deviation> <astigmatism_angle>
								<voltage> <Cs> <amplitude_factor>
				"pick"		<particle_diameter> <gaussian_edge> <cc_threshold>
				"read_model"	<file_name>
				"write_model"	<file_name> <coordinates> <links>
				"extract_panels"	<file_name> <coordinates>
				where:
					property	"info"
								"filename <string>"
								"label <string>"
								"nimages <number>"
								"channels <number>"
								"nslices <number>"
								"width <pixels>"
								"height <pixels>"
								"size <x> <y> <z>"
								"center"
								"origin <x> <y> <z> <img_num>"
								"min <value>"
								"max <value>"
								"show_min <value>"
								"show_max <value>"
								"average"
								"standard_deviation"
								"background"
								"datatype <string>"
								"pixel_size <angstrom>"
								"pixel <x> <y>"
	Return values:
		Each action may have a return value:
			"open"		number of images
			"get"		return value based on property
			"set"		modify image property
			"histogram" array of integer values
			"rps"		array of values for radial average
			"ctf_fit"   baseline and envelope equations, defocus average 
                            and deviation and astigmatism angle
			"pick"		array of particle coordinates (each x y)
			"extract_filament"	(none)
            "extract_panels" (none)
	Note: For the rps and ctf actions, the pixel size, voltage, Cs and amplitude 
		factor must be set in the image structure.

**/
int			image_processing(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
//	verbose = VERB_DEBUG;

	Tcl_ResetResult(interp);
	
	int 				img_num(0);

	if ( objc < 3 ) {
		Tcl_AppendResult(interp, "wrong # args", (char *)NULL);
		return TCL_ERROR;
	}

	Bstring				action = Tcl_GetStringFromObj(objv[1], NULL);
	if ( verbose & VERB_DEBUG )
		cout << "DEBUG BimageCmd: Action: " << action << " (" << action.length() << ")" << endl;
	
	/* Name of object in Tcl/Tk script */
	Bstring				photoName = Tcl_GetStringFromObj(objv[2], NULL);
	if ( verbose & VERB_DEBUG )
		cout << "DEBUG BimageCmd: Image object name: " << photoName << "(" << photoName.length() << ")" << endl;
	
	Tcl_Obj*			returnObj = Tcl_NewObj();
	
	char				string[4] = " ";
	Tcl_SetStringObj(returnObj, string, 1);
	
	int					tmp(0);
	Bstring				file_name, item, id;
	Bimage*				p = NULL;
	Bimage*				ptemp = NULL;
	Bimage*				pnew = NULL;
	
	for ( p = imglist; p; p = p->next )
		if ( p->identifier() == photoName ) break;
		
	if ( !p && imgtemp && imgtemp->identifier() == photoName ) {
		p = imgtemp;
		tmp = 1;
	} else if ( photoName == "thetemp" ) tmp = 1;
	
/*
	if ( imglist && !p ) {
		cerr << "Error: image id \"" << photoName << "\" not recognised!" << endl;
		cerr << "Possible id's: ";
		for ( p = imglist; p; p = p->next )
			cerr << p->identifier() << " ";
		cerr << endl;
		bexit(-1);
	}
*/	
	if ( action == "exists" ) {
		if ( p ) Tcl_SetIntObj(returnObj, 1);
		else Tcl_SetIntObj(returnObj, 0);
	} else if ( action == "open" ) {

		if ( objc < 4 ) {
			Tcl_AppendResult(interp, "No file name given!", (char *)NULL);
			return TCL_ERROR;
		}

		// Image file name
		file_name = Tcl_GetStringFromObj(objv[3], NULL);
		if ( verbose & VERB_DEBUG )
			cout << "DEBUG BimageCmd: File name: " << file_name << "(" << file_name.length() << ")" << endl;

		// Sub-image number
		img_num = -1;
		if ( objc > 4 ) Tcl_GetIntFromObj(NULL, objv[4], &img_num);
		if ( verbose & VERB_DEBUG )
			cout << "DEBUG BimageCmd: Image number: " << img_num << endl;
		
		// First check of the image is readable
		ptemp = read_img(file_name, 0, img_num);
		if ( !ptemp ) {
			Tcl_AppendResult(interp, "File not read!", (char *)NULL);
			return TCL_ERROR;
		}
		
		delete ptemp;

		if ( verbose & VERB_DEBUG )
			cout << "DEBUG BimageCmd: list: " << imglist << " pointer: " << p << endl;
		
		if ( p ) {
			if ( p == imgtemp ) {
				tmp = 1;
			} else if ( p == imglist ) {
				if ( p->next ) imglist = p->next;
				else imglist = NULL;
			} else {
				for ( ptemp = imglist; ptemp; ptemp = ptemp->next ) {
					if ( ptemp->next == p ) {
						ptemp->next = p->next;
						break;
					}
				}
			}
			delete p;		// Clear the image pointer if it has been allocated
			p = NULL;
		}
		
		pnew = read_img(file_name, 1, img_num);
		if ( verbose & VERB_DEBUG )
			cout << "DEBUG BimageCmd: Image pointer: " << pnew << endl;

		Tcl_SetIntObj(returnObj, -1);
		
		if ( !pnew ) {
			Tcl_AppendResult(interp, "File not read!", (char *)NULL);
			return TCL_ERROR;
		}
		
		if ( pnew->standard_deviation() <= 0 )
			pnew->statistics();
		
		if ( tmp ) {
			imgtemp = pnew;
//			cout << "imgtemp=" << imgtemp->file_name() << endl;
		} else if ( imglist ) {
			for ( p = imglist; p->next; p = p->next ) ;
			p->next = pnew;
		} else {
			imglist = pnew;
		}
		
		pnew->identifier(photoName);
		
		Tcl_SetIntObj(returnObj, pnew->images());
		
	} else if ( action == "close" ) {

		if ( objc < 4 ) {
			Tcl_AppendResult(interp, "No file name given!", (char *)NULL);
			return TCL_ERROR;
		}

		// Image file name
		file_name = Tcl_GetStringFromObj(objv[3], NULL);
		if ( verbose & VERB_DEBUG )
			cout << "DEBUG BimageCmd: File name: " << file_name << "(" << file_name.length() << ")" << endl;

		if ( p == imglist ) {
			if ( p->next ) imglist = p->next;
			else imglist = NULL;
		} else {
			for ( ptemp = imglist; ptemp; ptemp = ptemp->next ) {
				if ( ptemp->next == p ) {
					ptemp->next = p->next;
					break;
				}
			}
		}

		if ( verbose & VERB_DEBUG )
			cout << "DEBUG BimageCmd: Deleting: " << p->file_name() << endl;
		delete p;
		p = NULL;
		
	} else if ( action == "kill" ) {
		for ( p = imglist; p;  ) {
			imglist = imglist->next;
			delete p;
			p = imglist;
		}
	} else if ( action == "save" ) {
		if ( objc < 4 ) {
			Tcl_AppendResult(interp, "No file name given!", (char *)NULL);
			return TCL_ERROR;
		}
		
		/* Image file name */
		file_name = Tcl_GetStringFromObj(objv[3], NULL);
		if ( verbose & VERB_DEBUG )
			cout << "DEBUG BimageCmd: File name: " << file_name << "(" << file_name.length() << ")" << endl;

		if ( !p ) {
			Tcl_AppendResult(interp, "No file in memory!", (char *)NULL);
			return TCL_ERROR;
		}

		command = "Written from bshow";
		write_img(file_name, p, 0);
		
	} else if ( action == "save_montage" ) {
		if ( objc < 4 ) {
			Tcl_AppendResult(interp, "No file name given!", (char *)NULL);
			return TCL_ERROR;
		}
		
		/* Image file name */
		file_name = Tcl_GetStringFromObj(objv[3], NULL);
		if ( verbose & VERB_DEBUG )
			cout << "DEBUG BimageCmd: File name: " << file_name << "(" << file_name.length() << ")" << endl;

		if ( !p ) {
			Tcl_AppendResult(interp, "No file in memory!", (char *)NULL);
			return TCL_ERROR;
		}

		pnew = do_montage(p);

		command = "Written from bshow";
		write_img(file_name, pnew, 0);
		
		delete pnew;
		
	} else if ( action == "show" ) {
		if ( p ) do_show(p, interp, objc, objv);
	} else if ( action == "template" ) {
//		if ( imgtemp ) do_show(imgtemp, interp, objc, objv);
		if ( imgtemp ) do_template(imgtemp, interp, objc, objv);
	} else if ( action == "magnify" ) {
		p = imglist;
		do_magnify(p, interp, objc, objv);
	} else if ( action == "montage" ) {
		pnew = do_montage(p);
		if ( pnew ) {
			pnew->identifier(p->identifier());
			replace_item((char**) &imglist, (char *)p, (char *)pnew);
		}
	} else if ( action == "delete" ) {
		do_delete(p, objc, objv);
	} else if ( action == "statistics" ) {
		p->statistics();
	} else if ( action == "get" ) {
		returnObj = do_get(p, objc, objv);
	} else if ( action == "set" ) {
		do_set(p, objc, objv);
	} else if ( action == "switch" ) {
		do_switch(p, objc, objv);
	} else if ( action == "fixtype" ) {
		do_fix_type(p, objc, objv);
	} else if ( action == "stats" ) {
		returnObj = do_stats(p, objc, objv);
	} else if ( action == "center" ) {
		do_center(p, objc, objv);
	} else if ( action == "zero_origin" ) {
		do_zero_origin(p, objc, objv);
	} else if ( action == "extract" ) {
		do_extract(p, objc, objv);
	} else if ( action == "crop" ) {
		do_crop(p, objc, objv);
	} else if ( action == "pad" ) {
		do_pad(p, objc, objv);
	} else if ( action == "invert" ) {
		do_invert(p, objc, objv);
	} else if ( action == "truncate" ) {
		do_truncate(p, objc, objv);
	} else if ( action == "rescale" ) {
		do_rescale(p, objc, objv);
	} else if ( action == "reslice" ) {
		do_reslice(p, objc, objv);
	} else if ( action == "rotate" ) {
		do_rotate(p, objc, objv);
	} else if ( action == "bin" ) {
		do_bin(p, objc, objv);
	} else if ( action == "average" ) {
		do_average(p, objc, objv);
	} else if ( action == "variance" ) {
		do_variance(p, objc, objv);
	} else if ( action == "normalize" ) {
		do_normalize(p, objc, objv);
	} else if ( action == "gaussian" ) {
		do_gaussian(p, objc, objv);
	} else if ( action == "histogram" ) {
		returnObj = do_histogram(p, objc, objv);
	} else if ( action == "histofit" ) {
		returnObj = do_histogram_fit(p, objc, objv);
	} else if ( action == "radial" ) {
		returnObj = do_radial_average(p, objc, objv);
	} else if ( action == "fft" ) {
		do_fft(p, objc, objv);
	} else if ( action == "powerspec" ) {
		pnew = do_powerspec(p, objc, objv);
		if ( pnew ) {
			pnew->identifier(p->identifier());
			replace_item((char**) &imglist, (char *)p, (char *)pnew);
		}
	} else if ( action == "diffori" ) {
		do_diffraction_origin(p, objc, objv);
	} else {
		cerr << "Error: Action " << action << " not recognized!" << endl;
	}
	
	Tcl_SetObjResult(interp, returnObj);
//	Tcl_SetResult(interp, returnObj);

	return TCL_OK;
}

int			image_render(Bimage* p, long i, Tcl_Interp *interp, Bstring& photoName)
{
	Tk_PhotoHandle		photoHandle = Tk_FindPhoto(interp, photoName.c_str());
	Tk_PhotoImageBlock  block;

	if ( verbose & VERB_DEBUG )
		cout << "DEBUG image_render: photoName = " << photoName << endl;

#ifdef USE_PANIC_ON_PHOTO_ALLOC_FAILURE
	Tk_PhotoSetSize(photoHandle, p->sizeX(), p->sizeY());
#else
	Tk_PhotoSetSize(interp, photoHandle, p->sizeX(), p->sizeY());
#endif
	
	unsigned long		imgsize = p->sizeX()*p->sizeY()*p->channels();

	// Pointer to the data
	block.pixelPtr = (unsigned char *) (p->data_pointer() + i*imgsize);

	// the dimensions of the data
	block.width = p->sizeX();
	block.height = p->sizeY();

	if ( verbose & VERB_DEBUG )
		cout << "DEBUG image_render: width = " << block.width << " height = " << block.height << endl;

	// number of bytes between adjacent scanlines
	block.pitch = p->sizeX()*p->channels();

	// number of bytes of one pixel
	block.pixelSize = p->channels();

	if ( verbose & VERB_DEBUG )
		cout << "DEBUG image_render: pixelSize = " << block.pixelSize << " pitch = " << block.pitch << endl;

	// byte offsets for grayscale are all zero. 
	block.offset[0] = block.offset[1] = block.offset[2] = 0;
	
	// byte offsets to each of three color bands (r, g, b). 
	if ( p->channels() >= 3 ) {
		block.offset[1] = 1;
		block.offset[2] = 2;
	}

	// offset for the alpha channel
	if ( sizeof(block.offset) > 12 ) {
		block.offset[3] = 0;
		if ( p->channels() == 4 ) block.offset[3] = 3;
	}

	if ( verbose & VERB_DEBUG )
		cout << "DEBUG image_render: offset=" << block.offset[0] <<
			"," << block.offset[1] << "," << block.offset[2] << 
			"," << block.offset[3] << endl;
						
	// Load the data into the display frame
#ifdef TK_PHOTO_COMPOSITE_SET
#	ifdef USE_PANIC_ON_PHOTO_ALLOC_FAILURE
		Tk_PhotoPutBlock(photoHandle, &block, 0, 0, p->sizeX(), p->sizeY(), TK_PHOTO_COMPOSITE_SET);
//		cout << "111" << endl;
#	else
		Tk_PhotoPutBlock(interp, photoHandle, &block, 0, 0, p->sizeX(), p->sizeY(), TK_PHOTO_COMPOSITE_SET);
//		cout << "222" << endl;
#	endif
#else
		Tk_PhotoPutBlock(photoHandle, &block, 0, 0, p->sizeX(), p->sizeY());
//		cout << "333" << endl;
#endif

	return 0;
}

int			do_show(Bimage* p, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	int 				mode(0);
	int 				slice_num(p->show_slice()), img_num(p->show_image());
	double				dscale(p->show_scale());
	Tk_PhotoHandle  	photoHandle;

	// Name of object in Tcl/Tk script
	Bstring				photoName = Tcl_GetStringFromObj(objv[2], NULL);
	
	if ( verbose & VERB_DEBUG )
		cout << "DEBUG do_show: Image pointer: " << p << endl;
		
	// Sub-image number
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &img_num);
	if ( verbose & VERB_DEBUG )
		cout << "DEBUG do_show: Image number: " << img_num << endl;
		
	if ( img_num < 0 || img_num >= (long)p->images() ) img_num = 0;
	
	// Slice number
	if ( objc > 4 ) Tcl_GetIntFromObj(NULL, objv[4], &slice_num);
	if ( verbose & VERB_DEBUG )
		cout << "DEBUG do_show: Slice number: " << slice_num << endl;

	if ( slice_num < 0 || slice_num >= (long)p->sizeZ() ) slice_num = 0;
	
	// Scale
	if ( objc > 5 ) Tcl_GetDoubleFromObj(NULL, objv[5], &dscale);
	if ( verbose & VERB_DEBUG )
		cout << "DEBUG do_show: Scale: " << dscale << endl;

	if ( dscale < 0.1 ) dscale = 0.1;
	if ( dscale > 10 )  dscale = 10;
		
	// Mode
	if ( objc > 6 ) Tcl_GetIntFromObj(NULL, objv[6], &mode);
	if ( verbose & VERB_DEBUG )
		cout << "DEBUG do_show: Mode: " << mode << endl;
	
	// Handle to object in Tcl/Tk script
	photoHandle = Tk_FindPhoto(interp, photoName.c_str());
	if ( photoHandle ==  NULL ) {
		Tcl_AppendResult(interp, "can't find photo named \"",
			photoName.c_str(), "\"", (char *)NULL);
		return TCL_ERROR;
	}
	
	p->show_image(img_num);
	p->show_slice(slice_num);
	p->show_scale(dscale);
	
//	verbose = 32;
	double		t = timer_start();

	Bimage* 	pshow = NULL;
		
	// Extract only the slice to be shown
	if ( mont.ncol < 1 || mont.nrow < 1 ) {
		pshow = p->extract_show(mode);
	} else {
//		cout << "montaging" << endl;
		Bimage*		pm = do_montage(p);
//		cout << "extracting" << endl;
//		verbose = 255;
		pm->show_scale(dscale);
		pm->show_image(0);
		pm->show_slice(0);
		pm->show_minimum(p->show_minimum());
		pm->show_maximum(p->show_maximum());
		pshow = pm->extract_show(mode);
		delete pm;
	}

	if ( verbose & VERB_TIME )
		cout << "Time to extract: ";
	timer_report(t);

	t = timer_start();

	image_render(pshow, 0, interp, photoName);

	if ( verbose & VERB_TIME )
		cout << "Time to render: ";
	timer_report(t);
	verbose = 0;
		
	delete pshow;
	
	return 0;
}

int			do_magnify(Bimage* p, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	int					h, img_num(0);
	Vector3<int>		center, size;
	double				scale(2);

	Bstring				photoName;
	Bstring				baseName = Tcl_GetStringFromObj(objv[2], NULL);
	
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &img_num);
	if ( objc > 4 ) Tcl_GetIntFromObj(NULL, objv[4], &center[0]);
	if ( objc > 5 ) Tcl_GetIntFromObj(NULL, objv[5], &center[1]);
	if ( objc > 6 ) Tcl_GetIntFromObj(NULL, objv[6], &center[2]);
	if ( objc > 7 ) Tcl_GetDoubleFromObj(NULL, objv[7], &scale);
	if ( objc > 8 ) Tcl_GetIntFromObj(NULL, objv[8], &size[0]);
	if ( objc > 9 ) Tcl_GetIntFromObj(NULL, objv[9], &size[1]);
	if ( objc > 10 ) Tcl_GetIntFromObj(NULL, objv[10], &size[2]);

	if ( verbose & VERB_DEBUG ) {
		cout << "DEBUG do_magnify: img=" << img_num << " center=" << center << endl;
	}

	Bimage*				pmag = p->extract_magnify(img_num, center, size, scale);
	if ( !pmag ) return 0;
//	write_img("t.tif", pmag);
	
	for ( h=0; h<pmag->images(); h++ ) {
		photoName = baseName + Bstring(h, "%d");
		image_render(pmag, h, interp, photoName);
	}
	
	delete pmag;
	
	return 0;
}

int			do_template(Bimage* p, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	int 				slice_num(p->show_slice());
	double				dscale(p->show_scale());

	Bstring				photoName = Tcl_GetStringFromObj(objv[2], NULL);
	
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &slice_num);
	if ( slice_num < 0 || slice_num >= p->sizeZ() ) slice_num = p->sizeZ()/2;

	if ( objc > 4 ) Tcl_GetDoubleFromObj(NULL, objv[4], &dscale);

	if ( verbose & VERB_DEBUG )
		cout << "DEBUG do_template: slice_num=" << slice_num << " dscale=" << dscale << endl;

	Bimage*				pt = p->extract_slice(slice_num);
	if ( !pt ) return 0;
	
//	write_img("pt.pif", pt);

	if ( verbose & VERB_DEBUG )
		cout << "DEBUG do_template: slices=" << pt->images() << endl;

	Bimage*				pm = pt->montage(0, pt->images(), 1);

//	write_img("pm.pif", pm);

	delete pt;
	
	pm->show_image(0);
	pm->show_slice(0);
	pm->show_scale(dscale);

	Bimage* 			pshow = pm->extract_show(1);
	
	delete pm;
	
	image_render(pshow, 0, interp, photoName);
	
	delete pshow;
	
	return 0;
}

Bimage*		do_montage(Bimage* p)
{
	if ( !p ) return NULL;
	
//	cout << "montaging" << endl;
	
	Bimage*		pp = p;
	if ( mont.pad ) {
		Vector3<long>	newsize(p->sizeX()+2*mont.pad, p->sizeY()+2*mont.pad, p->sizeZ());
		Vector3<long>	translate(mont.pad, mont.pad, 0);
		pp = p->resize_copy(newsize, translate, FILL_USER, mont.fill);
	}
	
	Bimage*		pm = pp->montage(mont.first, mont.ncol, mont.nrow, mont.skip, mont.flip);
	
	if ( pp != p ) delete pp;
	
//	cout << "done montaging" << endl;
	
	return pm;
}

Tcl_Obj*	do_delete(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	Tcl_Obj*	returnObj = Tcl_NewObj();
	
	if ( !p ) return returnObj;
		
	Bstring			delist;

	if ( objc > 3 ) delist = Tcl_GetStringFromObj(objv[3], NULL);
	
	p->delete_images(delist);
	
	return returnObj;
}

Tcl_Obj*	do_get(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	Tcl_Obj*		returnObj = Tcl_NewObj();
	
	if ( !p ) return returnObj;
	
	long   			i, c;
	int				j(-1), iz(0), n(0);
	long			ix, iy;
	double			x, y;
	char			string[MAXLINELEN] = " ";
	Bstring			datatype_string;
		
	Bstring			property = Tcl_GetStringFromObj(objv[3], NULL);
	if ( verbose & VERB_DEBUG )
		cout << "DEBUG do_get: Property: " << property << " (" << property.length() << ")" << endl;

	if ( objc > 4 ) {
		Tcl_GetIntFromObj(NULL, objv[4], &j);
		if ( j<0 || j>=p->images() ) j = 0;
	}
	
	if ( !p || property.empty() ) {
		Tcl_SetIntObj(returnObj, 0);
	} else if ( property == "type" ) {
		Tcl_SetStringObj(returnObj, (char *)(*p)["type"].value().c_str(), (*p)["type"].value().length());
	} else if ( property == "info" ) {
		p->information();
		p->subimage_information();
		Tcl_SetIntObj(returnObj, 0);
	} else if ( property == "filename" ) {
		Tcl_SetStringObj(returnObj, (char *)p->file_name().c_str(), p->file_name().length());
	} else if ( property == "label" ) {
		Tcl_SetStringObj(returnObj, (char *)p->label().c_str(), p->label().length());
	} else if ( property == "nimages" ) {
		Tcl_SetIntObj(returnObj, p->images());
	} else if ( property == "channels" ) {
		Tcl_SetIntObj(returnObj, p->channels());
	} else if ( property == "nslices" ) {
		Tcl_SetIntObj(returnObj, p->sizeZ());
	} else if ( property == "width" ) {
		Tcl_SetIntObj(returnObj, p->sizeX());
	} else if ( property == "height" ) {
		Tcl_SetIntObj(returnObj, p->sizeY());
	} else if ( property == "size" ) {
		snprintf(string, MAXLINELEN, "%ld %ld %ld", p->sizeX(), p->sizeY(), p->sizeZ());
		Tcl_AppendToObj(returnObj, string, strlen(string));
	} else if ( property == "center" ) {
		snprintf(string, MAXLINELEN, "%ld %ld %ld", p->sizeX()/2, p->sizeY()/2, p->sizeZ()/2);
		Tcl_AppendToObj(returnObj, string, strlen(string));
	} else if ( property == "origin" ) {
		if ( j < 0 ) j = 0;
		snprintf(string, MAXLINELEN, "%g %g %g ", p->image[j].origin()[0], p->image[j].origin()[1], p->image[j].origin()[2]);
		Tcl_AppendToObj(returnObj, string, strlen(string));
	} else if ( property == "select" ) {
		if ( j < 0 ) j = 0;
		Tcl_SetIntObj(returnObj, p->image[j].select());
	} else if ( property == "show_image" ) {
		Tcl_SetIntObj(returnObj, p->show_image());
	} else if ( property == "show_slice" ) {
		Tcl_SetIntObj(returnObj, p->show_slice());
	} else if ( property == "show_scale" ) {
		Tcl_SetDoubleObj(returnObj, p->show_scale());
	} else if ( property == "show_min" ) {
		Tcl_SetDoubleObj(returnObj, p->show_minimum());
	} else if ( property == "show_max" ) {
		Tcl_SetDoubleObj(returnObj, p->show_maximum());
	} else if ( property == "min" ) {
		if ( j < 0 ) Tcl_SetDoubleObj(returnObj, p->minimum());
		else Tcl_SetDoubleObj(returnObj, p->image[j].minimum());
	} else if ( property == "max" ) {
		if ( j < 0 ) Tcl_SetDoubleObj(returnObj, p->maximum());
		else Tcl_SetDoubleObj(returnObj, p->image[j].maximum());
	} else if ( property == "average" ) {
		if ( j < 0 ) Tcl_SetDoubleObj(returnObj, p->average());
		else Tcl_SetDoubleObj(returnObj, p->image[j].average());
	} else if ( property == "standard_deviation" ) {
		if ( j < 0 ) Tcl_SetDoubleObj(returnObj, p->standard_deviation());
		else Tcl_SetDoubleObj(returnObj, p->image[j].standard_deviation());
	} else if ( property == "background" ) {
		if ( j < 0 ) Tcl_SetDoubleObj(returnObj, p->background(long(0)));
		else Tcl_SetDoubleObj(returnObj, p->image[j].background());
	} else if ( property == "datatype" ) {
		datatype_string = p->data_type_string();
		Tcl_SetStringObj(returnObj, (char *)datatype_string.c_str(), datatype_string.length());
	} else if ( property == "pixel_size" ) {
		if ( j < 0 ) {
			for ( i=0; i<p->images(); ++i ) {
				snprintf(string, 128, "%g %g %g ", p->image[i].sampling()[0],  p->image[i].sampling()[1],  p->image[i].sampling()[2]);
				Tcl_AppendToObj(returnObj, string, strlen(string));
			}
		} else {
			snprintf(string, MAXLINELEN, "%g %g %g ", p->image[j].sampling()[0], p->image[j].sampling()[1], p->image[j].sampling()[2]);
			Tcl_AppendToObj(returnObj, string, strlen(string));
		}
	} else if ( property == "pixel" ) {
//		cout << p->compound_type() << endl;
		if ( objc > 4 ) {
			Tcl_GetDoubleFromObj(NULL, objv[4], &x);
			ix = (long) x;
			if ( ix >=0 && ix < p->sizeX() ) {
				if ( p->compound_type() == TComplex ) {
					ix -= p->sizeX()/2;
					if ( ix < 0 ) ix += p->sizeX();
				}
				if ( objc > 5 ) {
					Tcl_GetDoubleFromObj(NULL, objv[5], &y);
					iy = (long) y;
					if ( iy >= 0 && iy < p->sizeY() ) {
						if ( objc > 6 ) Tcl_GetIntFromObj(NULL, objv[6], &iz);
						if ( objc > 7 ) Tcl_GetIntFromObj(NULL, objv[7], &n);
						if ( p->compound_type() == TComplex ) {
							iy -= p->sizeY()/2;
							if ( iy < 0 ) iy += p->sizeY();
							iz -= p->sizeZ()/2;
							if ( iz < 0 ) iz += p->sizeZ();
						}
						i = p->index(0,ix,iy,iz,n);
						for ( c=0, j=0; c<p->channels(); c++, i++ ) {
							if ( p->data_type() <= Long )
								j += snprintf(&string[j], MAXLINELEN, "%.0f ", (*p)[i]);
							else
								j += snprintf(&string[j], MAXLINELEN, "%.4g ", (*p)[i]);
						}
					}
				}
			}
		}
		Tcl_AppendToObj(returnObj, string, strlen(string));
	} else if ( property == "line" ) {
		returnObj = do_line(p, objc, objv);
	} else {
		cerr << "Error in do_get: Property " << property << " not recognized!" << endl;
	}
	
	return returnObj;
}

Tcl_Obj*	do_line(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	Tcl_Obj*		returnObj = Tcl_NewObj();
	
	if ( !p ) return returnObj;
	
	int				n(0);
	long 			width(1);
	Vector3<double> start, end;
	
	if ( objc > 4 ) Tcl_GetDoubleFromObj(NULL, objv[4], &start[0]);
	if ( objc > 5 ) Tcl_GetDoubleFromObj(NULL, objv[5], &start[1]);
	if ( objc > 6 ) Tcl_GetDoubleFromObj(NULL, objv[6], &start[2]);
	if ( objc > 7 ) Tcl_GetDoubleFromObj(NULL, objv[7], &end[0]);
	if ( objc > 8 ) Tcl_GetDoubleFromObj(NULL, objv[8], &end[1]);
	if ( objc > 9 ) Tcl_GetDoubleFromObj(NULL, objv[9], &end[2]);
	if ( objc > 10 ) Tcl_GetIntFromObj(NULL, objv[10], &n);
	if ( objc > 11 ) Tcl_GetLongFromObj(NULL, objv[11], &width);

	char			string[128];
	long			i, j, wh(width/2);
	Vector3<double>	vec(end - start), vecp, coor;
	long			len(vec.length() + 1);
	double			value;
	
	vec.normalize();
	vecp = Vector3<double>(vec[1], vec[0], vec[2]);
	
	for ( i=0; i<len; i++ ) {
		coor = start + vec*i;
		for ( value=0, j=-wh; j<=wh; ++j )
			value += p->interpolate(coor + vecp*j, n);
		value /= width;
		snprintf(string, 128, " %d %g %g %g %g", n, coor[0], coor[1], coor[2], value);
		Tcl_AppendToObj(returnObj, string, strlen(string));
	}

	return returnObj;
}


int			do_set(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	int				i(0), n(1);
	double			ox, oy, oz;
	double			scale(1), smin, smax;
	char			*astring;
	string			str;
	Vector3<double>	sam(1,1,1);

	Bstring			property = Tcl_GetStringFromObj(objv[3], NULL);
	if ( verbose & VERB_DEBUG )
		cout << "DEBUG do_set: Property: " << property << " (" << property.length() << ")" << endl;

	if ( objc < 4 || !p ) return 0;
	
	if ( property == "type" ) {
		str = Tcl_GetStringFromObj(objv[4], NULL);
		(*p)["type"] = str;
	} else if ( property == "label" ) {
		astring = Tcl_GetStringFromObj(objv[4], NULL);
		p->label(astring);
	} else if ( property == "origin" ) {
		i = -1;
		if ( objc > 7 ) Tcl_GetIntFromObj(NULL, objv[7], &i);
		if ( verbose & VERB_DEBUG )
			cout << "DEBUG do_set: setting origin for " << i << endl;
		if ( i < (int)p->images() ) {
			if ( objc > 4 ) {
				Tcl_GetDoubleFromObj(NULL, objv[4], &ox);
				if ( p->sizeX() < 2 ) ox = 0;
			}
			if ( objc > 5 ) {
				Tcl_GetDoubleFromObj(NULL, objv[5], &oy);
				if ( p->sizeY() < 2 ) oy = 0;
			}
			if ( objc > 6 ) {
				Tcl_GetDoubleFromObj(NULL, objv[6], &oz);
				if ( p->sizeZ() < 2 ) oz = 0;
			}
			if ( i < 0 ) p->origin(ox, oy, oz);
			else p->origin(i, ox, oy, oz);
			if ( verbose & VERB_DEBUG )
				cout << "DEBUG do_set: origin set: " << p->image->origin() << endl;
		}
	} else if ( property == "select" ) {
		i = -1;
		n = 1;
		if ( objc > 4 ) Tcl_GetIntFromObj(NULL, objv[4], &i);
		if ( objc > 5 ) Tcl_GetIntFromObj(NULL, objv[5], &n);
		if ( verbose & VERB_DEBUG )
			cout << "DEBUG do_set: setting selection for " << i << endl;
		if ( i<0 )
			for ( i=0; i<p->images(); i++ )
				p->image[i].select(n);
		else if ( i < p->images() )
			p->image[i].select(n);
	} else if ( property == "show_image" ) {
		Tcl_GetIntFromObj(NULL, objv[4], &i);
		p->show_image(i);
	} else if ( property == "show_slice" ) {
		Tcl_GetIntFromObj(NULL, objv[4], &i);
		p->show_slice(i);
	} else if ( property == "show_scale" ) {
		Tcl_GetDoubleFromObj(NULL, objv[4], &scale);
		p->show_scale(scale);
	} else if ( property == "show_min" ) {
		Tcl_GetDoubleFromObj(NULL, objv[4], &smin);
		p->show_minimum(smin);
	} else if ( property == "show_max" ) {
		Tcl_GetDoubleFromObj(NULL, objv[4], &smax);
		p->show_maximum(smax);
	} else if ( property == "datatype" ) {
		astring = Tcl_GetStringFromObj(objv[4], NULL);
		p->change_type(astring);
	} else if ( property == "pixel_size" ) {
		if ( objc > 4 ) Tcl_GetIntFromObj(NULL, objv[4], &i);
		if ( objc > 5 ) Tcl_GetDoubleFromObj(NULL, objv[5], &sam[0]);
		if ( objc > 6 ) Tcl_GetDoubleFromObj(NULL, objv[6], &sam[1]);
		if ( objc > 7 ) Tcl_GetDoubleFromObj(NULL, objv[7], &sam[2]);
		if ( i < 0 ) p->sampling(sam);
		else p->image[i].sampling(sam);
	} else if ( property == "montage" ) {
		if ( objc > 4 ) Tcl_GetIntFromObj(NULL, objv[4], &mont.ncol);
		if ( objc > 5 ) Tcl_GetIntFromObj(NULL, objv[5], &mont.nrow);
		if ( objc > 6 ) Tcl_GetIntFromObj(NULL, objv[6], &mont.first);
		if ( objc > 7 ) Tcl_GetIntFromObj(NULL, objv[7], &mont.skip);
		if ( objc > 8 ) Tcl_GetIntFromObj(NULL, objv[8], &mont.pad);
		if ( objc > 9 ) Tcl_GetDoubleFromObj(NULL, objv[9], &mont.fill);
		if ( objc > 10 ) Tcl_GetIntFromObj(NULL, objv[10], &mont.flip);
//		cout << "montage: " << mont.ncol << " x " << mont.nrow << endl;
	} else {
		cerr << "Error in do_set: Property " << property << " not recognized!" << endl;
	}
	
	return 0;
}

int			do_switch(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return -1;

	if ( p->images() > 1 ) 
		p->images_to_slices();
	else if ( p->sizeZ() > 1 ) 
		p->slices_to_images();
	
	p->statistics();

	return 1;
}

int			do_fix_type(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return -1;

	p->fix_type();
	
	p->statistics();

	return 1;
}

Tcl_Obj*	do_stats(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	Tcl_Obj*		returnObj = Tcl_NewObj();
	
	if ( !p ) return returnObj;

	if ( objc < 4 ) return returnObj;
	
	int				img_num(-1), type(0), nvert(0), i, k;
	Vector3<double>	start, end;
	
	Tcl_GetIntFromObj(NULL, objv[3], &img_num);

	Tcl_GetIntFromObj(NULL, objv[4], &type);
	
	if ( type < 1 || type > 3 ) return returnObj;

	Bstring				alist = Tcl_GetStringFromObj(objv[5], NULL);
	vector<double>		v = alist.split_into_doubles(" ");
	long				n(v.size());
	Vector3<double>*	poly = NULL;
	vector<double>		stats;
	
	switch ( type ) {
		case 1:
		case 2: if ( n > 5 ) {
					start = Vector3<long>((long)v[0], (long)v[1], (long)v[2]);
					end = Vector3<long>((long)v[3], (long)v[4], (long)v[5]);
					stats = p->stats_in_shape(img_num, type, start, end);
				}
				break;
		case 3: nvert = n/3;
				cout << "Number of vertices = " << nvert << endl;
				if ( nvert > 2 ) {
					poly = new Vector3<double>[nvert];
					for ( i=k=0; i<nvert; i++, k+=3 ) {
						poly[i] = Vector3<double>(v[k], v[k+1], v[k+2]);
						cout << poly[i][0] << " " << poly[i][1] << " " << poly[i][2] << endl;
					}
					stats = p->stats_in_poly(img_num, nvert, poly);
					delete[] poly;
				}
				break;
		default:
				break;
	}
	
	char		string[MAXLINELEN];
	snprintf(string, MAXLINELEN, "%ld %g %g %g %g %g", long(stats[0]),
		stats[1], stats[2], stats[3], stats[4], stats[0]*stats[3]);
	Tcl_AppendToObj(returnObj, string, strlen(string));

	return returnObj;
}

int			do_center(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	p->center_wrap();

	return 1;
}

int			do_zero_origin(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;

	p->zero_origin();

	return 1;
}

int			do_extract(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	if ( objc < 4 ) return 0;
	
	int				img_num(-1);
	Vector3<double>	start;
	Vector3<long>	size(p->size());
	
	Bstring			file_name = Tcl_GetStringFromObj(objv[3], NULL);
	Tcl_GetIntFromObj(NULL, objv[4], &img_num);
	
	if ( objc > 5 ) {
		Bstring				alist = Tcl_GetStringFromObj(objv[5], NULL);
		vector<double>		v = alist.split_into_doubles(" ");
		if ( v.size() < 6 ) return 0;
		if ( v[0] > v[3] ) swap(v[0], v[3]);
		if ( v[1] > v[4] ) swap(v[1], v[4]);
		if ( v[2] > v[5] ) swap(v[2], v[5]);
		start = Vector3<float>(v[0], v[1], v[2]);
		size = Vector3<int>((int) (v[3]-v[0]+1), (int) (v[4]-v[1]+1), (int) (v[5]-v[2]+1));
	}
	
	start = start.max(0);
	if ( size[0] < 1 || size[0] >= p->sizeX() ) size[0] = p->sizeX();
	if ( size[1] < 1 || size[1] >= p->sizeY() ) size[1] = p->sizeY();
	if ( size[2] < 1 || size[2] >= p->sizeZ() ) size[2] = p->sizeZ();

	Bimage*			pex = p->extract(img_num, start, size);

	Vector3<double>	origin(p->image[img_num].origin());

	origin -= start;
	
	pex->origin(origin);
	
	write_img(file_name, pex, 0);
	
	delete pex;

	return 1;
}

int			do_crop(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	if ( objc < 4 ) return 0;
	
//	int				img_num(-1);

	Bstring			alist = Tcl_GetStringFromObj(objv[4], NULL);
	vector<long>	v = alist.split_into_integers(" ");
	
	if ( v.size() < 6 ) return 0;

	Vector3<long>	start = Vector3<long>(v[0], v[1], v[2]);
	Vector3<long>	end = Vector3<long>(v[3], v[4], v[5]);
	
	if ( start[0] > end[0] ) swap(start[0], end[0]);
	if ( start[1] > end[1] ) swap(start[1], end[1]);
	if ( start[2] > end[2] ) swap(start[2], end[2]);
	
	start = start.max(0);
	if ( end[0] >= p->sizeX() ) end[0] = p->sizeX() - 1;
	if ( end[1] >= p->sizeY() ) end[1] = p->sizeY() - 1;
	if ( end[2] >= p->sizeZ() ) end[2] = p->sizeZ() - 1;

	Vector3<long>	newsize(1,1,1);
	
	newsize += end - start;

	Vector3<long>	translate = -start;
	
	return p->resize(newsize, translate, 0, 0);
}

int			do_pad(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	if ( objc < 4 ) return 0;
	
	int				filltype(2);
	double			fill(0);

	Vector3<int>	size;
	Vector3<int>	translate;
	
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &translate[0]);
	if ( objc > 4 ) Tcl_GetIntFromObj(NULL, objv[4], &translate[1]);
	if ( objc > 5 ) Tcl_GetIntFromObj(NULL, objv[5], &translate[2]);
	if ( objc > 6 ) Tcl_GetIntFromObj(NULL, objv[6], &size[0]);
	if ( objc > 7 ) Tcl_GetIntFromObj(NULL, objv[7], &size[1]);
	if ( objc > 8 ) Tcl_GetIntFromObj(NULL, objv[8], &size[2]);
	if ( objc > 9 ) Tcl_GetIntFromObj(NULL, objv[9], &filltype);
	if ( objc > 10 ) Tcl_GetDoubleFromObj(NULL, objv[10], &fill);

//	size += translate + p->size();

	return p->resize(size, translate, filltype, fill);
}

int			do_invert(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	p->invert();
	
	return 1;
}

int			do_truncate(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	double		min, max, tol = 0.001*(p->maximum() - p->minimum());
	
	if ( objc > 4 ) {
		Tcl_GetDoubleFromObj(NULL, objv[3], &min);
		Tcl_GetDoubleFromObj(NULL, objv[4], &max);
		if ( fabs(min - p->minimum()) > tol || fabs(max - p->maximum()) > tol ) {
			p->truncate_to_min_max(min, max);
		}
	}

	return 0;
}

int			do_rescale(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	double		avg, std, tol = 0.001*(p->maximum() - p->minimum());
	
	if ( objc > 4 ) {
		Tcl_GetDoubleFromObj(NULL, objv[3], &avg);
		Tcl_GetDoubleFromObj(NULL, objv[4], &std);
		if ( ( std > 0 ) && ( fabs(avg - p->average()) > tol || fabs(std - p->standard_deviation()) > tol ) ) {
//			img_rescale_to_avg_std(p, avg, std);
			p->rescale_to_avg_std(avg, std);
		}
	}

	return 0;
}

int			do_reslice(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	Bstring		order;
	
	if ( objc > 3 ) {
		order = Tcl_GetStringFromObj(objv[3], NULL);
		p->reslice(order);
	}

	return 0;
}

int			do_rotate(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	Euler		euler;
	
	if ( objc > 3 ) Tcl_GetDoubleFromObj(NULL, objv[3], &euler[0]);
	if ( objc > 4 ) Tcl_GetDoubleFromObj(NULL, objv[4], &euler[1]);
	if ( objc > 5 ) Tcl_GetDoubleFromObj(NULL, objv[5], &euler[2]);
	
	euler[0] *= M_PI/180.0;
	euler[1] *= M_PI/180.0;
	euler[2] *= M_PI/180.0;

	if ( euler.psi() || euler.theta() || euler.phi() )
//		img_rotate(p, euler);
//		p->rotate(euler.view());
		p->rotate(euler.matrix());

	return 0;
}

int			do_bin(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	Vector3<int>		bin(1,1,1);
	
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &bin[0]);
	if ( objc > 4 ) Tcl_GetIntFromObj(NULL, objv[4], &bin[1]);
	if ( objc > 5 ) Tcl_GetIntFromObj(NULL, objv[5], &bin[2]);
	
	if ( bin[0]*bin[1]*bin[2] > 1 ) p->bin(bin);
		
	return 0;
}

int			do_average(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	Vector3<int>	k(1,1,1);
	
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &k[0]);
	if ( objc > 4 ) Tcl_GetIntFromObj(NULL, objv[4], &k[1]);
	if ( objc > 5 ) Tcl_GetIntFromObj(NULL, objv[5], &k[2]);
	
	if ( k.volume() > 1 ) p->filter_average(k);
		
	return 0;
}

int			do_variance(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	int				k(1);
	
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &k);
	
	if ( k > 1 ) p->variance(k);
		
	return 0;
}

int			do_normalize(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	Vector3<int>	k(1,1,1);
	
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &k[0]);
	if ( objc > 4 ) Tcl_GetIntFromObj(NULL, objv[4], &k[1]);
	if ( objc > 5 ) Tcl_GetIntFromObj(NULL, objv[5], &k[2]);
	
	if ( k.volume() > 1 ) p->normalize_local(k);
		
	return 0;
}

int			do_gaussian(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	int				k(3);
	double			sigma(1);
	
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &k);
	if ( objc > 4 ) Tcl_GetDoubleFromObj(NULL, objv[4], &sigma);
	
	if ( k > 3 ) p->filter_gaussian(k, sigma);
		
	return 0;
}

Tcl_Obj*	do_histogram(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	Tcl_Obj*		returnObj = Tcl_NewObj();
	
	if ( !p ) return returnObj;
		
	int				bins(200);
	
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &bins);
	
	double			scale, offset;
	vector<long>	h = p->histogram(bins, scale, offset);
	char			string[128];
	for ( auto it = h.begin(); it != h.end(); ++it ) {
		snprintf(string, 128, "%ld ", *it);
		Tcl_AppendToObj(returnObj, string, strlen(string));
	}
	
	return returnObj;
}

Tcl_Obj*	do_histogram_fit(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	Tcl_Obj*		returnObj = Tcl_NewObj();
	
	if ( !p ) return returnObj;
		
	int				bins(200), ngauss(1);
	
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &bins);
	if ( objc > 4 ) Tcl_GetIntFromObj(NULL, objv[4], &ngauss);
	
	vector<double>	h = p->histogram_gauss_fit2(bins, ngauss);

	char			string[128];
	for ( auto it = h.begin(); it != h.end(); ++it ) {
		snprintf(string, 128, "%g ", *it);
		Tcl_AppendToObj(returnObj, string, strlen(string));
	}
	
	return returnObj;
}

Tcl_Obj*	do_radial_average(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	int				wrap(0);
	double			ox(0), oy(0), oz(0), angle(0);
	char*			maskname = NULL;
	
	Tcl_Obj*		returnObj = Tcl_NewObj();

	if ( !p ) return returnObj;
		
	if ( p->image->origin()[0] <= 0 || p->image->origin()[0] >= p->sizeX() ) ox = p->sizeX()/2;
	if ( p->image->origin()[1] <= 0 || p->image->origin()[1] >= p->sizeY() ) oy = p->sizeY()/2;
	if ( p->image->origin()[2] <= 0 || p->image->origin()[2] >= p->sizeZ() ) oz = p->sizeZ()/2;
	
	if ( objc > 3 ) Tcl_GetDoubleFromObj(NULL, objv[3], &ox);
	if ( objc > 4 ) Tcl_GetDoubleFromObj(NULL, objv[4], &oy);
	if ( objc > 5 ) Tcl_GetDoubleFromObj(NULL, objv[5], &oz);
	
	p->origin(ox, oy, oz);
	
	if ( objc > 6 ) Tcl_GetDoubleFromObj(NULL, objv[6], &angle);
	
	if ( objc > 7 ) maskname = Tcl_GetStringFromObj(objv[7], NULL);
	
	if ( objc > 8 ) Tcl_GetIntFromObj(NULL, objv[8], &wrap);
	
	angle *= M_PI/180.0;
	
	Bimage*			pmask = NULL;
	if ( maskname && strlen(maskname) > 2 ) pmask = read_img(maskname, 1, -1);
	
	long			i, len(p->sizeX()/2);
	char			string[128];
	Bimage*			prad = p->radial(0, len, 1, pmask, wrap);
	
	for ( i=0; i<prad->sizeX(); i++ ) {
		if ( !isfinite((*prad)[i]) ) cerr << "Warning: Point " << i << " is a NaN!" << endl;
		snprintf(string, 128, " %g", (*prad)[i]);
		Tcl_AppendToObj(returnObj, string, strlen(string));
	}
	
	delete prad;
	
	Vector3<double>		end(cos(angle)*len, sin(angle)*len, 0);
	prad = p->extract_line(0, p->image->origin(), end, 5);

	for ( i=0; i<len; i++ ) {
		if ( !isfinite((*prad)[i]) ) cerr << "Warning: Point " << i << " is a NaN!" << endl;
		snprintf(string, 128, " %g", (*prad)[i]);
		Tcl_AppendToObj(returnObj, string, strlen(string));
	}

	delete prad;
	
	end = Vector3<double>(sin(angle)*len, cos(angle)*len, 0);
	prad = p->extract_line(0, p->image->origin(), end, 5);

	for ( i=0; i<len; i++ ) {
		if ( !isfinite((*prad)[i]) ) cerr << "Warning: Point " << i << " is a NaN!" << endl;
		snprintf(string, 128, " %g", (*prad)[i]);
		Tcl_AppendToObj(returnObj, string, strlen(string));
//		cout << i << tab << (*prad)[i] << endl;
	}

	delete prad;
	delete pmask;
	pmask = NULL;
	
	return returnObj;
}

int			do_diffraction_origin(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	double			ox(0), oy(0), oz =0;
	char*			maskname = NULL;
	
	if ( objc > 3 ) Tcl_GetDoubleFromObj(NULL, objv[3], &ox);
		
	if ( objc > 4 ) Tcl_GetDoubleFromObj(NULL, objv[4], &oy);
	
	if ( objc > 5 ) Tcl_GetDoubleFromObj(NULL, objv[5], &oz);
	
	if ( objc > 7 ) maskname = Tcl_GetStringFromObj(objv[7], NULL);
	
	if ( ox > 0 ) p->origin(ox, oy, oz);
	
	Bimage*			pmask = NULL;
	if ( maskname && strlen(maskname) > 2 ) pmask = read_img(maskname, 1, -1);
	
	double 			hires(p->sampling(0)[0]*10), lores(p->sampling(0)[0]*1000);
	double			radius(p->sizeX()/4.0), sigma(0);
	p->find_center(pmask, hires, lores, radius, sigma, 1);
	
	delete pmask;

	return 1;
}

int			do_fft(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;

	int			dir(-1);
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &dir);

	if ( dir > 0 ) {
		if ( p->compound_type() == TComplex ) p->fft(FFTW_BACKWARD, 1);
	} else if ( dir < 0 ) {
		if ( p->compound_type() == TSimple ) p->fft(FFTW_FORWARD, 1);
	}
	
	p->statistics();
	
	return 1;
}

Bimage*		do_powerspec(Bimage* p, int objc, Tcl_Obj *CONST objv[])
{
	if ( !p ) return 0;
	
	int				flags(4);
	double			tilt_axis(0), tilt_angle(0), tilt_offset(0);
	double			defocus(0), Cs(2), volt(300);
	Vector3<int>	tile_size(p->size());
	
	if ( objc > 3 ) Tcl_GetIntFromObj(NULL, objv[3], &flags);
	if ( objc > 4 ) Tcl_GetIntFromObj(NULL, objv[4], &tile_size[0]);
	if ( objc > 5 ) Tcl_GetIntFromObj(NULL, objv[5], &tile_size[1]);
	if ( objc > 6 ) Tcl_GetIntFromObj(NULL, objv[6], &tile_size[2]);
	if ( objc > 7 ) Tcl_GetDoubleFromObj(NULL, objv[7], &tilt_axis);
	if ( objc > 8 ) Tcl_GetDoubleFromObj(NULL, objv[8], &tilt_angle);
	if ( objc > 9 ) Tcl_GetDoubleFromObj(NULL, objv[9], &tilt_offset);
	if ( objc > 10 ) Tcl_GetDoubleFromObj(NULL, objv[10], &defocus);
	if ( objc > 11 ) Tcl_GetDoubleFromObj(NULL, objv[11], &Cs);
	if ( objc > 12 ) Tcl_GetDoubleFromObj(NULL, objv[12], &volt);
	
	Bimage*			ps = NULL;
	
	if ( objc > 5 ) {
		flags |= 2;
		tilt_axis *= M_PI/180.0;
		tilt_angle *= M_PI/180.0;
		if ( defocus < 100 ) defocus *= 1e4;
		if ( Cs < 100 ) Cs *= 1e7;
		if ( volt < 10000 ) volt *= 1000;
		double		lamda(volt);
		double		iCL2(1.0/(Cs*lamda*lamda));
		ps = p->powerspectrum_tiled_and_tilted(tile_size, tilt_axis, 
				tilt_angle, tilt_offset, defocus, iCL2, flags);
	} else
		p->power_spectrum(flags);
	
	return ps;
}
