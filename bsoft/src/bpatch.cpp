/**
@file	bpatch.cpp
@brief	Program to patch tiled image files
@author Bernard Heymann
@date	Created: 20040712
@date	Modified: 20190218
**/

#include "rwmg.h"
#include "rwimg.h"
#include "file_util.h"
#include "utilities.h"
#include "options.h"
#include "timer.h"
#include <fstream>

// Declaration of global variables
extern int 	verbose;		// Level of output to the screen

Bimage*		img_patch(Bstring* file_list, Bstring tile_file, DataType nudatatype,
				double cutmin, double cutmax, double nuavg, double nustd);

// Usage assistance
const char* use[] = {
" ",
"Usage: bpatch [options] input.images/input.star",
"-----------------------------------------------",
"Patches a list of tiles together with overlap.",
"Requires a text file generated by btile that specifies the size and order of the tiles.",
"Any number of input images may be given and may include the wild card \"*\".",
"All images must have the same data type.",
" ",
"Parameters:",
"-verbose 3               Verbosity of output.",
"-datatype u              Force writing of a new data type.",
"-sampling 1.5,1.5,1.5    Sampling (A/pixel; a single value can be given).",
"-origin 0.8,-10,15.7     Set the origin of the output image (default 0,0,0).",
"-size 1024,1024,120      Output image size (default from tile file).",
"-mode 1                  Overlap handling: 0=average(default), 1=weigh, 2=central.",
"-rescale 127,27.5        Rescale all input data to average and standard deviation.",
"-truncate -5,5.5         Truncate data to minimum and maximum after rescaling.",
" ",
"Input:",
"-tiles text.tiles        Text file with overall size and tile origins.",
" ",
"Output:",
"-output output.img       Output image (default patch.pif).",
"-parameters file.star    Output micrograph parameter file.",
" ",
NULL
};

int 		main(int argc, char **argv)
{
	// Initialize variables
	DataType 		nudatatype(Unknown_Type);	// Conversion to new type
	Vector3<double> sampling;					// Units for the three axes (A/pixel)
	Vector3<double> origin;						// New image origin
	int				set_origin(0);				// Flag to set origin
	Vector3<long>	size;						// Output image size
	int				flag(0);					// Overlap flag
	double			nuavg(0), nustd(0);			// Rescaling to average and stdev
	double			cutmin(0), cutmax(0); 		// Truncation
	Bstring			patchfile("patch.pif");
	Bstring			tile_file;					// Text file with overall size and tile origins
	Bstring			outparam;					// Output micrograph parameter file
	
	int				optind;
	Boption*		option = get_option_list(use, argc, argv, optind);
	Boption*		curropt;
	for ( curropt = option; curropt; curropt = curropt->next ) {
		if ( curropt->tag == "datatype" )
			nudatatype = curropt->datatype();
		if ( curropt->tag == "sampling" )
			sampling = curropt->scale();
		if ( curropt->tag == "origin" ) {
			if ( curropt->value[0] == 'c' ) {
				set_origin = 2;
			} else {
				origin = curropt->origin();
				set_origin = 1;
			}
		}
		if ( curropt->tag == "size" )
			size = curropt->size();
		if ( curropt->tag == "mode" )
			flag = curropt->value.integer();
		if ( curropt->tag == "rescale" )
        	if ( curropt->values(nuavg, nustd) < 2 )
				cerr << "-rescale: Both average and standard deviation must be specified!" << endl;
		if ( curropt->tag == "truncate" )
			if ( curropt->values(cutmin, cutmax) < 2 )
				cerr << "-truncate: Both min and max must be specified!" << endl;
		if ( curropt->tag == "output" )
			patchfile = curropt->filename();
		if ( curropt->tag == "tiles" )
			tile_file = curropt->filename();
		if ( curropt->tag == "parameters" )
			outparam = curropt->filename();
    }
	option_kill(option);

	if ( verbose && argc < 3 ) bexit(-1);
	
	double			ti = timer_start();
/*
	if ( !tile_file.length() ) {
		cerr << "Error: A text file specifying the size and tile origins must be given!" << endl;
		bexit(-1);
	}
*/
	if ( argc - optind < 1 ) {
		cerr << "Error: No tiles found!" << endl;
		bexit(-1);
	}

	Bstring*			file_list = NULL;
	while ( optind < argc ) string_add(&file_list, argv[optind++]);
	Bstring				paramfile = *file_list;
	Bproject*			project = NULL;	
	Breconstruction*	rec;

	if ( file_type(paramfile) == Micrograph ) {
		project = read_project(file_list);
		string_kill(file_list);
		file_list = NULL;
		for ( rec = project->rec; rec; rec = rec->next )
			string_add(&file_list, rec->frec);
		project_kill(project);
	}

	Bimage*		ppatch = NULL;
	
	if ( tile_file.length() )
		ppatch = img_patch(file_list, tile_file, nudatatype,
							cutmin, cutmax, nuavg, nustd);
	else {
		Bimage*			p = read_img(*file_list, 1, -1);
		if ( size.volume() < 1 )
			for ( long nn=0; nn<p->images(); ++nn )
				size = size.max(p->size()+p->image[nn].origin());
		ppatch = p->copy_header(1);
		ppatch->size(size);
		ppatch->data_alloc_and_clear();
		ppatch->assemble_tiles(p, flag);
		delete p;
	}
	
	if ( sampling.volume() > 0 ) ppatch->sampling(sampling);

	if ( set_origin ) {
		if ( set_origin == 2 ) ppatch->origin(ppatch->size()/2);
		else ppatch->origin(origin);
	}

	write_img(patchfile, ppatch, 0);
	
	Bstring			id("1");
	if ( outparam.length() ) {
		project = read_project(paramfile);
		if ( !project->rec ) reconstruction_add(&project->rec, id);
		project->rec->frec = patchfile;
		write_project(outparam, project, 0, 0);
		project_kill(project);
	}

	string_kill(file_list);
	delete ppatch;
	patchfile = 0;
	id = 0;
	
	if ( verbose & VERB_TIME )
		timer_report(ti);
	
	bexit(0);
}

int			img_pack_into_image(Bimage* p, Bimage* ppatch, Vector3<int> start, Vector3<int> overlap)
{
	long   			i, j, c, x, y, z, xx, yy, zz;
	Vector3<double>	w;
	
	overlap *= 0.5;
	
	if ( verbose & VERB_PROCESS )
		cout << "Placing tile of size " << p->size() << " at " << start << endl << endl;
	
	for ( z=0; z<p->sizeZ(); z++ ) {
		zz = start[2] + z;
		w[2] = 0;
		if ( z >= overlap[2] && z < p->sizeZ() - overlap[2] ) w[2] = 1;
		if ( zz <= overlap[2] ) w[2] = 1;
		if ( zz >= ppatch->sizeZ() - overlap[2] ) w[2] = 1;
		for ( y=0; y<p->sizeY(); y++ ) {
			yy = start[1] + y;
			w[1] = 0;
			if ( y >= overlap[1] && y < p->sizeY() - overlap[1] ) w[1] = 1;
			if ( yy <= overlap[1] ) w[1] = 1;
			if ( yy >= ppatch->sizeY() - overlap[1] ) w[1] = 1;
			for ( x=0; x<p->sizeX(); x++ ) {
				xx = start[0] + x;
				w[0] = 0;
				if ( x >= overlap[0] && x < p->sizeX() - overlap[0] ) w[0] = 1;
				if ( xx <= overlap[0] ) w[0] = 1;
				if ( xx >= ppatch->sizeX() - overlap[0] ) w[0] = 1;
				if ( w.volume() ) {
					i = ((z*p->sizeY() + y)*p->sizeX() + x)*p->channels();
					j = ((zz*ppatch->sizeY() + yy)*ppatch->sizeX() + xx)*p->channels();
					for ( c=0; c<p->channels(); c++, i++, j++ ) ppatch->set(j, (*p)[i]);
				}
			}
		}
	}

	return(0);
}

/**
@brief 	Assembles overlapping tiles into a single image.
@param 	*file_list		list of files with tiles.
@param 	tile_file		text file specifying the tile size, overlap and locations.
@param 	nudatatype		new data type to convert to.
@param 	cutmin			minimum to truncate each tile before assembly.
@param 	cutmax			maximum to truncate each tile before assembly.
@param 	nuavg			new average to set each tile before assembly.
@param 	nustd			new standard deviation to set each tile before assembly.
@return Bimage*			new composite image.

	Each tile extents halfway into overlapped areas, representing a step
	function between tiles.

**/
Bimage*		img_patch(Bstring* file_list, Bstring tile_file, DataType nudatatype,
				double cutmin, double cutmax, double nuavg, double nustd)
{
	long				i, n(1);
	Bstring*			file_ptr = NULL;
	Vector3<long>		size;						// Overall size after patching
	Vector3<long>		overlap;					// Tile overlap
	
	// Get the number of tiles and find the last tile
	for ( file_ptr = file_list; file_ptr->next; file_ptr = file_ptr->next ) n++;

	// Read the tile size, overlap and locations
	ifstream		fd(tile_file.c_str());
	if ( fd.fail() ) {
		cerr << "Error: A text file specifying the size and tile origins must be given!" << endl;
		bexit(-1);
	}
	
	fd >> size[0] >> size[1] >> size[2];
	fd >> overlap[0] >> overlap[1] >> overlap[2];

	Vector3<int>*	tile_origin = new Vector3<int>[n];
	
	for ( i=0; i<n; i++ )
		fd >> tile_origin[i][0] >> tile_origin[i][1] >> tile_origin[i][2];
		
	fd.close();

	// Get the overall size
	Bimage*			p = read_img(*file_list, 0, 0);
	
	Vector3<long>	tile_size(p->size());			// Tile size from first image
	
	if ( verbose & VERB_DEBUG ) {
		cout << "DEBUG img_patch: tilesize=" << tile_size << " overlap=" << overlap << endl;
		cout << "DEBUG img_patch: tiles=" << n << endl;
	}
	
	delete p;
	
	// Get the overall size
	p = read_img(*file_ptr, 0, 0);
	
	if ( size != tile_origin[n-1] + p->size() ) {
		cerr << "Error: The expected size does not match the size given in file " << tile_file << endl;
		cerr << "	Expected size:  " << tile_origin[n-1] + p->size() << endl;
		cerr << "	Given size:     " << size << endl;
		cerr << "	Make sure all the tiles are present." << endl;
		bexit(-1);
	}
	
	// Set up the receiving image
	if ( nudatatype == Unknown_Type ) nudatatype = p->data_type();
	Bimage*			ppatch = new Bimage(nudatatype, p->compound_type(), size, 1);
	ppatch->sampling(p->sampling(0));
	ppatch->image[0] = p->image[0];
	ppatch->origin(ppatch->default_origin());
	delete p;

	if ( verbose ) {
		cout << "Patching tiles:" << endl;
		cout << "Size:                           " << size << endl;
		cout << "Overlap:                        " << overlap << endl;
		cout << "Number of tiles:                " << n << endl << endl;
	}
	
	for ( i=0, file_ptr = file_list; i<n && file_ptr; i++, file_ptr = file_ptr->next ) {
		if ( ( p = read_img(*file_ptr, 1, 0) ) ) {
			if ( verbose & VERB_DEBUG )
				cout << p->file_name() << ": " << p->size() << " " << p->channels() << " " << p->images() << endl;
			if ( nustd ) p->rescale_to_avg_std(nuavg, nustd);
			if ( cutmin || cutmax )
				p->truncate_to_min_max(cutmin, cutmax);
			p->change_type(nudatatype);
//			ppatch->place_with_overlap(p, i, tile_size, n, tile_origin);
			img_pack_into_image(p, ppatch, tile_origin[i], overlap);
			delete p;
		}
	}
	
	ppatch->calculate_background();

	delete[] tile_origin;

	return ppatch;
}


